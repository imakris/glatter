/*
Copyright 2018 Ioannis Makris

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// This file was generated by glatter.py script.



#ifdef GLATTER_GL
#if defined(__gl_glext_h_)
#if defined(GL_3DFX_tbuffer)
#ifndef glTbufferMask3DFX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTbufferMask3DFX, (mask), (GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glTbufferMask3DFX_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTbufferMask3DFX, "(%u)", (unsigned int)mask)
    glatter_glTbufferMask3DFX(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTbufferMask3DFX_defined
#endif
#endif // defined(GL_3DFX_tbuffer)
#if defined(GL_AMD_debug_output)
#ifndef glDebugMessageCallbackAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageCallbackAMD, (callback, userParam), (GLDEBUGPROCAMD callback, void *userParam))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageCallbackAMD_debug(GLDEBUGPROCAMD callback, void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackAMD, "(%s, %p)", GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackAMD(callback, userParam);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageCallbackAMD_defined
#endif
#ifndef glDebugMessageEnableAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageEnableAMD, (category, severity, count, ids, enabled), (GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageEnableAMD_debug(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageEnableAMD, "(%s, %s, %d, %p, %u)", enum_to_string_GL(category), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageEnableAMD(category, severity, count, ids, enabled);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageEnableAMD_defined
#endif
#ifndef glDebugMessageInsertAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageInsertAMD, (category, severity, id, length, buf), (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageInsertAMD_debug(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertAMD, "(%s, %s, %u, %d, %p)", enum_to_string_GL(category), enum_to_string_GL(severity), (unsigned int)id, (int)length, (void*)buf)
    glatter_glDebugMessageInsertAMD(category, severity, id, length, buf);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageInsertAMD_defined
#endif
#ifndef glGetDebugMessageLogAMD_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetDebugMessageLogAMD, (count, bufSize, categories, severities, ids, lengths, message), (GLuint count, GLsizei bufSize, GLenum *categories, GLenum *severities, GLuint *ids, GLsizei *lengths, GLchar *message))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetDebugMessageLogAMD_debug(GLuint count, GLsizei bufSize, GLenum *categories, GLenum *severities, GLuint *ids, GLsizei *lengths, GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogAMD, "(%u, %d, %p, %p, %p, %p, %p)", (unsigned int)count, (int)bufSize, (void*)categories, (void*)severities, (void*)ids, (void*)lengths, (void*)message)
    GLuint rval = glatter_glGetDebugMessageLogAMD(count, bufSize, categories, severities, ids, lengths, message);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetDebugMessageLogAMD_defined
#endif
#endif // defined(GL_AMD_debug_output)
#if defined(GL_AMD_draw_buffers_blend)
#ifndef glBlendEquationIndexedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationIndexedAMD, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationIndexedAMD_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationIndexedAMD, "(%u, %s)", (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationIndexedAMD(buf, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationIndexedAMD_defined
#endif
#ifndef glBlendEquationSeparateIndexedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationSeparateIndexedAMD, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationSeparateIndexedAMD_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateIndexedAMD, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationSeparateIndexedAMD_defined
#endif
#ifndef glBlendFuncIndexedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncIndexedAMD, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncIndexedAMD_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncIndexedAMD, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFuncIndexedAMD(buf, src, dst);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncIndexedAMD_defined
#endif
#ifndef glBlendFuncSeparateIndexedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparateIndexedAMD, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparateIndexedAMD_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateIndexedAMD, "(%u, %s, %s, %s, %s)", (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparateIndexedAMD_defined
#endif
#endif // defined(GL_AMD_draw_buffers_blend)
#if defined(GL_AMD_framebuffer_multisample_advanced)
#ifndef glNamedRenderbufferStorageMultisampleAdvancedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorageMultisampleAdvancedAMD, (renderbuffer, samples, storageSamples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorageMultisampleAdvancedAMD_debug(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisampleAdvancedAMD, "(%u, %d, %d, %s, %d, %d)", (unsigned int)renderbuffer, (int)samples, (int)storageSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorageMultisampleAdvancedAMD_defined
#endif
#ifndef glRenderbufferStorageMultisampleAdvancedAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorageMultisampleAdvancedAMD, (target, samples, storageSamples, internalformat, width, height), (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorageMultisampleAdvancedAMD_debug(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleAdvancedAMD, "(%s, %d, %d, %s, %d, %d)", enum_to_string_GL(target), (int)samples, (int)storageSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorageMultisampleAdvancedAMD_defined
#endif
#endif // defined(GL_AMD_framebuffer_multisample_advanced)
#if defined(GL_AMD_framebuffer_sample_positions)
#ifndef glFramebufferSamplePositionsfvAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferSamplePositionsfvAMD, (target, numsamples, pixelindex, values), (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferSamplePositionsfvAMD_debug(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSamplePositionsfvAMD, "(%s, %u, %u, %p)", enum_to_string_GL(target), (unsigned int)numsamples, (unsigned int)pixelindex, (void*)values)
    glatter_glFramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferSamplePositionsfvAMD_defined
#endif
#ifndef glGetFramebufferParameterfvAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferParameterfvAMD, (target, pname, numsamples, pixelindex, size, values), (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferParameterfvAMD_debug(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameterfvAMD, "(%s, %s, %u, %u, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (unsigned int)numsamples, (unsigned int)pixelindex, (int)size, (void*)values)
    glatter_glGetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferParameterfvAMD_defined
#endif
#ifndef glGetNamedFramebufferParameterfvAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedFramebufferParameterfvAMD, (framebuffer, pname, numsamples, pixelindex, size, values), (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedFramebufferParameterfvAMD_debug(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameterfvAMD, "(%u, %s, %u, %u, %d, %p)", (unsigned int)framebuffer, enum_to_string_GL(pname), (unsigned int)numsamples, (unsigned int)pixelindex, (int)size, (void*)values)
    glatter_glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedFramebufferParameterfvAMD_defined
#endif
#ifndef glNamedFramebufferSamplePositionsfvAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferSamplePositionsfvAMD, (framebuffer, numsamples, pixelindex, values), (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferSamplePositionsfvAMD_debug(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSamplePositionsfvAMD, "(%u, %u, %u, %p)", (unsigned int)framebuffer, (unsigned int)numsamples, (unsigned int)pixelindex, (void*)values)
    glatter_glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferSamplePositionsfvAMD_defined
#endif
#endif // defined(GL_AMD_framebuffer_sample_positions)
#if defined(GL_AMD_gpu_shader_int64)
#ifndef glGetUniformi64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformi64vNV, (program, location, params), (GLuint program, GLint location, GLint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformi64vNV_debug(GLuint program, GLint location, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vNV, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vNV(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformi64vNV_defined
#endif
#ifndef glGetUniformui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformui64vNV, (program, location, params), (GLuint program, GLint location, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformui64vNV_debug(GLuint program, GLint location, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformui64vNV, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformui64vNV(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformui64vNV_defined
#endif
#ifndef glProgramUniform1i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1i64NV, (program, location, x), (GLuint program, GLint location, GLint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1i64NV_debug(GLuint program, GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64NV, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64NV(program, location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1i64NV_defined
#endif
#ifndef glProgramUniform1i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1i64vNV_defined
#endif
#ifndef glProgramUniform1ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ui64NV, (program, location, x), (GLuint program, GLint location, GLuint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64NV, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64NV(program, location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ui64NV_defined
#endif
#ifndef glProgramUniform1ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ui64vNV_defined
#endif
#ifndef glProgramUniform2i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2i64NV, (program, location, x, y), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64NV, "(%u, %d, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64NV(program, location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2i64NV_defined
#endif
#ifndef glProgramUniform2i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2i64vNV_defined
#endif
#ifndef glProgramUniform2ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ui64NV, (program, location, x, y), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64NV, "(%u, %d, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64NV(program, location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ui64NV_defined
#endif
#ifndef glProgramUniform2ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ui64vNV_defined
#endif
#ifndef glProgramUniform3i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3i64NV, (program, location, x, y, z), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64NV, "(%u, %d, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64NV(program, location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3i64NV_defined
#endif
#ifndef glProgramUniform3i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3i64vNV_defined
#endif
#ifndef glProgramUniform3ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ui64NV, (program, location, x, y, z), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64NV, "(%u, %d, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64NV(program, location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ui64NV_defined
#endif
#ifndef glProgramUniform3ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ui64vNV_defined
#endif
#ifndef glProgramUniform4i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4i64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64NV, "(%u, %d, %s, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64NV(program, location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4i64NV_defined
#endif
#ifndef glProgramUniform4i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4i64vNV_defined
#endif
#ifndef glProgramUniform4ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ui64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64NV, "(%u, %d, %s, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64NV(program, location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ui64NV_defined
#endif
#ifndef glProgramUniform4ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ui64vNV_defined
#endif
#ifndef glUniform1i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1i64NV, (location, x), (GLint location, GLint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glUniform1i64NV_debug(GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64NV, "(%d, %s)", (int)location, GET_PRS(x))
    glatter_glUniform1i64NV(location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1i64NV_defined
#endif
#ifndef glUniform1i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1i64vNV_defined
#endif
#ifndef glUniform1ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ui64NV, (location, x), (GLint location, GLuint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ui64NV_debug(GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64NV, "(%d, %s)", (int)location, GET_PRS(x))
    glatter_glUniform1ui64NV(location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ui64NV_defined
#endif
#ifndef glUniform1ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ui64vNV_defined
#endif
#ifndef glUniform2i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2i64NV, (location, x, y), (GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glUniform2i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64NV, "(%d, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64NV(location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2i64NV_defined
#endif
#ifndef glUniform2i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2i64vNV_defined
#endif
#ifndef glUniform2ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ui64NV, (location, x, y), (GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64NV, "(%d, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64NV(location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ui64NV_defined
#endif
#ifndef glUniform2ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ui64vNV_defined
#endif
#ifndef glUniform3i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3i64NV, (location, x, y, z), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glUniform3i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64NV, "(%d, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64NV(location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3i64NV_defined
#endif
#ifndef glUniform3i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3i64vNV_defined
#endif
#ifndef glUniform3ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ui64NV, (location, x, y, z), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64NV, "(%d, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64NV(location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ui64NV_defined
#endif
#ifndef glUniform3ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ui64vNV_defined
#endif
#ifndef glUniform4i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4i64NV, (location, x, y, z, w), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glUniform4i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64NV, "(%d, %s, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64NV(location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4i64NV_defined
#endif
#ifndef glUniform4i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4i64vNV_defined
#endif
#ifndef glUniform4ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ui64NV, (location, x, y, z, w), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64NV, "(%d, %s, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64NV(location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ui64NV_defined
#endif
#ifndef glUniform4ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ui64vNV_defined
#endif
#endif // defined(GL_AMD_gpu_shader_int64)
#if defined(GL_AMD_interleaved_elements)
#ifndef glVertexAttribParameteriAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribParameteriAMD, (index, pname, param), (GLuint index, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribParameteriAMD_debug(GLuint index, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribParameteriAMD, "(%u, %s, %d)", (unsigned int)index, enum_to_string_GL(pname), (int)param)
    glatter_glVertexAttribParameteriAMD(index, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribParameteriAMD_defined
#endif
#endif // defined(GL_AMD_interleaved_elements)
#if defined(GL_AMD_multi_draw_indirect)
#ifndef glMultiDrawArraysIndirectAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirectAMD, (mode, indirect, primcount, stride), (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirectAMD_debug(GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectAMD, "(%s, %p, %d, %d)", enum_to_string_GL(mode), (void*)indirect, (int)primcount, (int)stride)
    glatter_glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirectAMD_defined
#endif
#ifndef glMultiDrawElementsIndirectAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirectAMD, (mode, type, indirect, primcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirectAMD_debug(GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectAMD, "(%s, %s, %p, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)primcount, (int)stride)
    glatter_glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirectAMD_defined
#endif
#endif // defined(GL_AMD_multi_draw_indirect)
#if defined(GL_AMD_name_gen_delete)
#ifndef glDeleteNamesAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteNamesAMD, (identifier, num, names), (GLenum identifier, GLuint num, const GLuint *names))
GLATTER_INLINE_OR_NOT void glatter_glDeleteNamesAMD_debug(GLenum identifier, GLuint num, const GLuint *names, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteNamesAMD, "(%s, %u, %p)", enum_to_string_GL(identifier), (unsigned int)num, (void*)names)
    glatter_glDeleteNamesAMD(identifier, num, names);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteNamesAMD_defined
#endif
#ifndef glGenNamesAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenNamesAMD, (identifier, num, names), (GLenum identifier, GLuint num, GLuint *names))
GLATTER_INLINE_OR_NOT void glatter_glGenNamesAMD_debug(GLenum identifier, GLuint num, GLuint *names, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenNamesAMD, "(%s, %u, %p)", enum_to_string_GL(identifier), (unsigned int)num, (void*)names)
    glatter_glGenNamesAMD(identifier, num, names);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenNamesAMD_defined
#endif
#ifndef glIsNameAMD_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsNameAMD, (identifier, name), (GLenum identifier, GLuint name))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsNameAMD_debug(GLenum identifier, GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNameAMD, "(%s, %u)", enum_to_string_GL(identifier), (unsigned int)name)
    GLboolean rval = glatter_glIsNameAMD(identifier, name);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsNameAMD_defined
#endif
#endif // defined(GL_AMD_name_gen_delete)
#if defined(GL_AMD_occlusion_query_event)
#ifndef glQueryObjectParameteruiAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glQueryObjectParameteruiAMD, (target, id, pname, param), (GLenum target, GLuint id, GLenum pname, GLuint param))
GLATTER_INLINE_OR_NOT void glatter_glQueryObjectParameteruiAMD_debug(GLenum target, GLuint id, GLenum pname, GLuint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryObjectParameteruiAMD, "(%s, %u, %s, %u)", enum_to_string_GL(target), (unsigned int)id, enum_to_string_GL(pname), (unsigned int)param)
    glatter_glQueryObjectParameteruiAMD(target, id, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glQueryObjectParameteruiAMD_defined
#endif
#endif // defined(GL_AMD_occlusion_query_event)
#if defined(GL_AMD_performance_monitor)
#ifndef glBeginPerfMonitorAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_INLINE_OR_NOT void glatter_glBeginPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfMonitorAMD, "(%u)", (unsigned int)monitor)
    glatter_glBeginPerfMonitorAMD(monitor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginPerfMonitorAMD_defined
#endif
#ifndef glDeletePerfMonitorsAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeletePerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_INLINE_OR_NOT void glatter_glDeletePerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfMonitorsAMD, "(%d, %p)", (int)n, (void*)monitors)
    glatter_glDeletePerfMonitorsAMD(n, monitors);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeletePerfMonitorsAMD_defined
#endif
#ifndef glEndPerfMonitorAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_INLINE_OR_NOT void glatter_glEndPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfMonitorAMD, "(%u)", (unsigned int)monitor)
    glatter_glEndPerfMonitorAMD(monitor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndPerfMonitorAMD_defined
#endif
#ifndef glGenPerfMonitorsAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenPerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_INLINE_OR_NOT void glatter_glGenPerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPerfMonitorsAMD, "(%d, %p)", (int)n, (void*)monitors)
    glatter_glGenPerfMonitorsAMD(n, monitors);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenPerfMonitorsAMD_defined
#endif
#ifndef glGetPerfMonitorCounterDataAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorCounterDataAMD, (monitor, pname, dataSize, data, bytesWritten), (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorCounterDataAMD_debug(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterDataAMD, "(%u, %s, %d, %p, %p)", (unsigned int)monitor, enum_to_string_GL(pname), (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorCounterDataAMD_defined
#endif
#ifndef glGetPerfMonitorCounterInfoAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorCounterInfoAMD, (group, counter, pname, data), (GLuint group, GLuint counter, GLenum pname, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorCounterInfoAMD_debug(GLuint group, GLuint counter, GLenum pname, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterInfoAMD, "(%u, %u, %s, %p)", (unsigned int)group, (unsigned int)counter, enum_to_string_GL(pname), (void*)data)
    glatter_glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorCounterInfoAMD_defined
#endif
#ifndef glGetPerfMonitorCounterStringAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorCounterStringAMD, (group, counter, bufSize, length, counterString), (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorCounterStringAMD_debug(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterStringAMD, "(%u, %u, %d, %p, %p)", (unsigned int)group, (unsigned int)counter, (int)bufSize, (void*)length, (void*)counterString)
    glatter_glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorCounterStringAMD_defined
#endif
#ifndef glGetPerfMonitorCountersAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorCountersAMD, (group, numCounters, maxActiveCounters, counterSize, counters), (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorCountersAMD_debug(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCountersAMD, "(%u, %p, %p, %d, %p)", (unsigned int)group, (void*)numCounters, (void*)maxActiveCounters, (int)counterSize, (void*)counters)
    glatter_glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorCountersAMD_defined
#endif
#ifndef glGetPerfMonitorGroupStringAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorGroupStringAMD, (group, bufSize, length, groupString), (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorGroupStringAMD_debug(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupStringAMD, "(%u, %d, %p, %p)", (unsigned int)group, (int)bufSize, (void*)length, (void*)groupString)
    glatter_glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorGroupStringAMD_defined
#endif
#ifndef glGetPerfMonitorGroupsAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfMonitorGroupsAMD, (numGroups, groupsSize, groups), (GLint *numGroups, GLsizei groupsSize, GLuint *groups))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfMonitorGroupsAMD_debug(GLint *numGroups, GLsizei groupsSize, GLuint *groups, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupsAMD, "(%p, %d, %p)", (void*)numGroups, (int)groupsSize, (void*)groups)
    glatter_glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfMonitorGroupsAMD_defined
#endif
#ifndef glSelectPerfMonitorCountersAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSelectPerfMonitorCountersAMD, (monitor, enable, group, numCounters, counterList), (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList))
GLATTER_INLINE_OR_NOT void glatter_glSelectPerfMonitorCountersAMD_debug(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSelectPerfMonitorCountersAMD, "(%u, %u, %u, %d, %p)", (unsigned int)monitor, (unsigned char)enable, (unsigned int)group, (int)numCounters, (void*)counterList)
    glatter_glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSelectPerfMonitorCountersAMD_defined
#endif
#endif // defined(GL_AMD_performance_monitor)
#if defined(GL_AMD_sample_positions)
#ifndef glSetMultisamplefvAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetMultisamplefvAMD, (pname, index, val), (GLenum pname, GLuint index, const GLfloat *val))
GLATTER_INLINE_OR_NOT void glatter_glSetMultisamplefvAMD_debug(GLenum pname, GLuint index, const GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetMultisamplefvAMD, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glSetMultisamplefvAMD(pname, index, val);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetMultisamplefvAMD_defined
#endif
#endif // defined(GL_AMD_sample_positions)
#if defined(GL_AMD_sparse_texture)
#ifndef glTexStorageSparseAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageSparseAMD, (target, internalFormat, width, height, depth, layers, flags), (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageSparseAMD_debug(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageSparseAMD, "(%s, %s, %d, %d, %d, %d, %u)", enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (int)layers, (unsigned int)flags)
    glatter_glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageSparseAMD_defined
#endif
#ifndef glTextureStorageSparseAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageSparseAMD, (texture, target, internalFormat, width, height, depth, layers, flags), (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageSparseAMD_debug(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageSparseAMD, "(%u, %s, %s, %d, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (int)layers, (unsigned int)flags)
    glatter_glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageSparseAMD_defined
#endif
#endif // defined(GL_AMD_sparse_texture)
#if defined(GL_AMD_stencil_operation_extended)
#ifndef glStencilOpValueAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilOpValueAMD, (face, value), (GLenum face, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glStencilOpValueAMD_debug(GLenum face, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpValueAMD, "(%s, %u)", enum_to_string_GL(face), (unsigned int)value)
    glatter_glStencilOpValueAMD(face, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilOpValueAMD_defined
#endif
#endif // defined(GL_AMD_stencil_operation_extended)
#if defined(GL_AMD_vertex_shader_tessellator)
#ifndef glTessellationFactorAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTessellationFactorAMD, (factor), (GLfloat factor))
GLATTER_INLINE_OR_NOT void glatter_glTessellationFactorAMD_debug(GLfloat factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTessellationFactorAMD, "(%f)", (float)factor)
    glatter_glTessellationFactorAMD(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTessellationFactorAMD_defined
#endif
#ifndef glTessellationModeAMD_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTessellationModeAMD, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glTessellationModeAMD_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTessellationModeAMD, "(%s)", enum_to_string_GL(mode))
    glatter_glTessellationModeAMD(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTessellationModeAMD_defined
#endif
#endif // defined(GL_AMD_vertex_shader_tessellator)
#if defined(GL_APPLE_element_array)
#ifndef glDrawElementArrayAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementArrayAPPLE, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementArrayAPPLE_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementArrayAPPLE, "(%s, %d, %d)", enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawElementArrayAPPLE(mode, first, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementArrayAPPLE_defined
#endif
#ifndef glDrawRangeElementArrayAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawRangeElementArrayAPPLE, (mode, start, end, first, count), (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glDrawRangeElementArrayAPPLE_debug(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementArrayAPPLE, "(%s, %u, %u, %d, %d)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)first, (int)count)
    glatter_glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawRangeElementArrayAPPLE_defined
#endif
#ifndef glElementPointerAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glElementPointerAPPLE, (type, pointer), (GLenum type, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glElementPointerAPPLE_debug(GLenum type, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glElementPointerAPPLE, "(%s, %p)", enum_to_string_GL(type), (void*)pointer)
    glatter_glElementPointerAPPLE(type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glElementPointerAPPLE_defined
#endif
#ifndef glMultiDrawElementArrayAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementArrayAPPLE, (mode, first, count, primcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementArrayAPPLE_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementArrayAPPLE, "(%s, %p, %p, %d)", enum_to_string_GL(mode), (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementArrayAPPLE_defined
#endif
#ifndef glMultiDrawRangeElementArrayAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawRangeElementArrayAPPLE, (mode, start, end, first, count, primcount), (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawRangeElementArrayAPPLE_debug(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawRangeElementArrayAPPLE, "(%s, %u, %u, %p, %p, %d)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawRangeElementArrayAPPLE_defined
#endif
#endif // defined(GL_APPLE_element_array)
#if defined(GL_APPLE_fence)
#ifndef glDeleteFencesAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteFencesAPPLE, (n, fences), (GLsizei n, const GLuint *fences))
GLATTER_INLINE_OR_NOT void glatter_glDeleteFencesAPPLE_debug(GLsizei n, const GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFencesAPPLE, "(%d, %p)", (int)n, (void*)fences)
    glatter_glDeleteFencesAPPLE(n, fences);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteFencesAPPLE_defined
#endif
#ifndef glFinishFenceAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFinishFenceAPPLE, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT void glatter_glFinishFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishFenceAPPLE, "(%u)", (unsigned int)fence)
    glatter_glFinishFenceAPPLE(fence);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFinishFenceAPPLE_defined
#endif
#ifndef glFinishObjectAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFinishObjectAPPLE, (object, name), (GLenum object, GLint name))
GLATTER_INLINE_OR_NOT void glatter_glFinishObjectAPPLE_debug(GLenum object, GLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishObjectAPPLE, "(%s, %d)", enum_to_string_GL(object), (int)name)
    glatter_glFinishObjectAPPLE(object, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFinishObjectAPPLE_defined
#endif
#ifndef glGenFencesAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenFencesAPPLE, (n, fences), (GLsizei n, GLuint *fences))
GLATTER_INLINE_OR_NOT void glatter_glGenFencesAPPLE_debug(GLsizei n, GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFencesAPPLE, "(%d, %p)", (int)n, (void*)fences)
    glatter_glGenFencesAPPLE(n, fences);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenFencesAPPLE_defined
#endif
#ifndef glIsFenceAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsFenceAPPLE, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFenceAPPLE, "(%u)", (unsigned int)fence)
    GLboolean rval = glatter_glIsFenceAPPLE(fence);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsFenceAPPLE_defined
#endif
#ifndef glSetFenceAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetFenceAPPLE, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT void glatter_glSetFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFenceAPPLE, "(%u)", (unsigned int)fence)
    glatter_glSetFenceAPPLE(fence);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetFenceAPPLE_defined
#endif
#ifndef glTestFenceAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glTestFenceAPPLE, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT GLboolean glatter_glTestFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestFenceAPPLE, "(%u)", (unsigned int)fence)
    GLboolean rval = glatter_glTestFenceAPPLE(fence);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glTestFenceAPPLE_defined
#endif
#ifndef glTestObjectAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glTestObjectAPPLE, (object, name), (GLenum object, GLuint name))
GLATTER_INLINE_OR_NOT GLboolean glatter_glTestObjectAPPLE_debug(GLenum object, GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestObjectAPPLE, "(%s, %u)", enum_to_string_GL(object), (unsigned int)name)
    GLboolean rval = glatter_glTestObjectAPPLE(object, name);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glTestObjectAPPLE_defined
#endif
#endif // defined(GL_APPLE_fence)
#if defined(GL_APPLE_flush_buffer_range)
#ifndef glBufferParameteriAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferParameteriAPPLE, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glBufferParameteriAPPLE_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferParameteriAPPLE, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glBufferParameteriAPPLE(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferParameteriAPPLE_defined
#endif
#ifndef glFlushMappedBufferRangeAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushMappedBufferRangeAPPLE, (target, offset, size), (GLenum target, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glFlushMappedBufferRangeAPPLE_debug(GLenum target, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRangeAPPLE, "(%s, %s, %s)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size))
    glatter_glFlushMappedBufferRangeAPPLE(target, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushMappedBufferRangeAPPLE_defined
#endif
#endif // defined(GL_APPLE_flush_buffer_range)
#if defined(GL_APPLE_object_purgeable)
#ifndef glGetObjectParameterivAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectParameterivAPPLE, (objectType, name, pname, params), (GLenum objectType, GLuint name, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectParameterivAPPLE_debug(GLenum objectType, GLuint name, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterivAPPLE, "(%s, %u, %s, %p)", enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterivAPPLE(objectType, name, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectParameterivAPPLE_defined
#endif
#ifndef glObjectPurgeableAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glObjectPurgeableAPPLE, (objectType, name, option), (GLenum objectType, GLuint name, GLenum option))
GLATTER_INLINE_OR_NOT GLenum glatter_glObjectPurgeableAPPLE_debug(GLenum objectType, GLuint name, GLenum option, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPurgeableAPPLE, "(%s, %u, %s)", enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(option))
    GLenum rval = glatter_glObjectPurgeableAPPLE(objectType, name, option);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glObjectPurgeableAPPLE_defined
#endif
#ifndef glObjectUnpurgeableAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glObjectUnpurgeableAPPLE, (objectType, name, option), (GLenum objectType, GLuint name, GLenum option))
GLATTER_INLINE_OR_NOT GLenum glatter_glObjectUnpurgeableAPPLE_debug(GLenum objectType, GLuint name, GLenum option, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectUnpurgeableAPPLE, "(%s, %u, %s)", enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(option))
    GLenum rval = glatter_glObjectUnpurgeableAPPLE(objectType, name, option);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glObjectUnpurgeableAPPLE_defined
#endif
#endif // defined(GL_APPLE_object_purgeable)
#if defined(GL_APPLE_texture_range)
#ifndef glGetTexParameterPointervAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterPointervAPPLE, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterPointervAPPLE_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterPointervAPPLE, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterPointervAPPLE(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterPointervAPPLE_defined
#endif
#ifndef glTextureRangeAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureRangeAPPLE, (target, length, pointer), (GLenum target, GLsizei length, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glTextureRangeAPPLE_debug(GLenum target, GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureRangeAPPLE, "(%s, %d, %p)", enum_to_string_GL(target), (int)length, (void*)pointer)
    glatter_glTextureRangeAPPLE(target, length, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureRangeAPPLE_defined
#endif
#endif // defined(GL_APPLE_texture_range)
#if defined(GL_APPLE_vertex_array_object)
#ifndef glBindVertexArrayAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVertexArrayAPPLE, (array), (GLuint array))
GLATTER_INLINE_OR_NOT void glatter_glBindVertexArrayAPPLE_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArrayAPPLE, "(%u)", (unsigned int)array)
    glatter_glBindVertexArrayAPPLE(array);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVertexArrayAPPLE_defined
#endif
#ifndef glDeleteVertexArraysAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteVertexArraysAPPLE, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_INLINE_OR_NOT void glatter_glDeleteVertexArraysAPPLE_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArraysAPPLE, "(%d, %p)", (int)n, (void*)arrays)
    glatter_glDeleteVertexArraysAPPLE(n, arrays);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteVertexArraysAPPLE_defined
#endif
#ifndef glGenVertexArraysAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenVertexArraysAPPLE, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_INLINE_OR_NOT void glatter_glGenVertexArraysAPPLE_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArraysAPPLE, "(%d, %p)", (int)n, (void*)arrays)
    glatter_glGenVertexArraysAPPLE(n, arrays);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenVertexArraysAPPLE_defined
#endif
#ifndef glIsVertexArrayAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsVertexArrayAPPLE, (array), (GLuint array))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsVertexArrayAPPLE_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArrayAPPLE, "(%u)", (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArrayAPPLE(array);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsVertexArrayAPPLE_defined
#endif
#endif // defined(GL_APPLE_vertex_array_object)
#if defined(GL_APPLE_vertex_array_range)
#ifndef glFlushVertexArrayRangeAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushVertexArrayRangeAPPLE, (length, pointer), (GLsizei length, void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glFlushVertexArrayRangeAPPLE_debug(GLsizei length, void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushVertexArrayRangeAPPLE, "(%d, %p)", (int)length, (void*)pointer)
    glatter_glFlushVertexArrayRangeAPPLE(length, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushVertexArrayRangeAPPLE_defined
#endif
#ifndef glVertexArrayParameteriAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayParameteriAPPLE, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayParameteriAPPLE_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayParameteriAPPLE, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glVertexArrayParameteriAPPLE(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayParameteriAPPLE_defined
#endif
#ifndef glVertexArrayRangeAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayRangeAPPLE, (length, pointer), (GLsizei length, void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayRangeAPPLE_debug(GLsizei length, void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayRangeAPPLE, "(%d, %p)", (int)length, (void*)pointer)
    glatter_glVertexArrayRangeAPPLE(length, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayRangeAPPLE_defined
#endif
#endif // defined(GL_APPLE_vertex_array_range)
#if defined(GL_APPLE_vertex_program_evaluators)
#ifndef glDisableVertexAttribAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexAttribAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexAttribAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribAPPLE, "(%u, %s)", (unsigned int)index, enum_to_string_GL(pname))
    glatter_glDisableVertexAttribAPPLE(index, pname);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexAttribAPPLE_defined
#endif
#ifndef glEnableVertexAttribAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexAttribAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexAttribAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribAPPLE, "(%u, %s)", (unsigned int)index, enum_to_string_GL(pname))
    glatter_glEnableVertexAttribAPPLE(index, pname);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexAttribAPPLE_defined
#endif
#ifndef glIsVertexAttribEnabledAPPLE_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsVertexAttribEnabledAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsVertexAttribEnabledAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexAttribEnabledAPPLE, "(%u, %s)", (unsigned int)index, enum_to_string_GL(pname))
    GLboolean rval = glatter_glIsVertexAttribEnabledAPPLE(index, pname);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsVertexAttribEnabledAPPLE_defined
#endif
#ifndef glMapVertexAttrib1dAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapVertexAttrib1dAPPLE, (index, size, u1, u2, stride, order, points), (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points))
GLATTER_INLINE_OR_NOT void glatter_glMapVertexAttrib1dAPPLE_debug(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib1dAPPLE, "(%u, %u, %f, %f, %d, %d, %p)", (unsigned int)index, (unsigned int)size, (double)u1, (double)u2, (int)stride, (int)order, (void*)points)
    glatter_glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapVertexAttrib1dAPPLE_defined
#endif
#ifndef glMapVertexAttrib1fAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapVertexAttrib1fAPPLE, (index, size, u1, u2, stride, order, points), (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glMapVertexAttrib1fAPPLE_debug(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib1fAPPLE, "(%u, %u, %f, %f, %d, %d, %p)", (unsigned int)index, (unsigned int)size, (float)u1, (float)u2, (int)stride, (int)order, (void*)points)
    glatter_glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapVertexAttrib1fAPPLE_defined
#endif
#ifndef glMapVertexAttrib2dAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapVertexAttrib2dAPPLE, (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points))
GLATTER_INLINE_OR_NOT void glatter_glMapVertexAttrib2dAPPLE_debug(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib2dAPPLE, "(%u, %u, %f, %f, %d, %d, %f, %f, %d, %d, %p)", (unsigned int)index, (unsigned int)size, (double)u1, (double)u2, (int)ustride, (int)uorder, (double)v1, (double)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapVertexAttrib2dAPPLE_defined
#endif
#ifndef glMapVertexAttrib2fAPPLE_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapVertexAttrib2fAPPLE, (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glMapVertexAttrib2fAPPLE_debug(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib2fAPPLE, "(%u, %u, %f, %f, %d, %d, %f, %f, %d, %d, %p)", (unsigned int)index, (unsigned int)size, (float)u1, (float)u2, (int)ustride, (int)uorder, (float)v1, (float)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapVertexAttrib2fAPPLE_defined
#endif
#endif // defined(GL_APPLE_vertex_program_evaluators)
#if defined(GL_ARB_ES3_2_compatibility)
#ifndef glPrimitiveBoundingBoxARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrimitiveBoundingBoxARB, (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW))
GLATTER_INLINE_OR_NOT void glatter_glPrimitiveBoundingBoxARB_debug(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveBoundingBoxARB, "(%f, %f, %f, %f, %f, %f, %f, %f)", (float)minX, (float)minY, (float)minZ, (float)minW, (float)maxX, (float)maxY, (float)maxZ, (float)maxW)
    glatter_glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrimitiveBoundingBoxARB_defined
#endif
#endif // defined(GL_ARB_ES3_2_compatibility)
#if defined(GL_ARB_bindless_texture)
#ifndef glGetImageHandleARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetImageHandleARB, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetImageHandleARB_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleARB, "(%u, %d, %u, %d, %s)", (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleARB(texture, level, layered, layer, format);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetImageHandleARB_defined
#endif
#ifndef glGetTextureHandleARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetTextureHandleARB, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetTextureHandleARB_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleARB, "(%u)", (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleARB(texture);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetTextureHandleARB_defined
#endif
#ifndef glGetTextureSamplerHandleARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetTextureSamplerHandleARB, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetTextureSamplerHandleARB_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleARB, "(%u, %u)", (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleARB(texture, sampler);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetTextureSamplerHandleARB_defined
#endif
#ifndef glGetVertexAttribLui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribLui64vARB, (index, pname, params), (GLuint index, GLenum pname, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribLui64vARB_debug(GLuint index, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLui64vARB, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLui64vARB(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribLui64vARB_defined
#endif
#ifndef glIsImageHandleResidentARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsImageHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsImageHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentARB, "(%s)", GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentARB(handle);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsImageHandleResidentARB_defined
#endif
#ifndef glIsTextureHandleResidentARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentARB, "(%s)", GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentARB(handle);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsTextureHandleResidentARB_defined
#endif
#ifndef glMakeImageHandleNonResidentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeImageHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeImageHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentARB, "(%s)", GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentARB(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeImageHandleNonResidentARB_defined
#endif
#ifndef glMakeImageHandleResidentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeImageHandleResidentARB, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_INLINE_OR_NOT void glatter_glMakeImageHandleResidentARB_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentARB, "(%s, %s)", GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentARB(handle, access);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeImageHandleResidentARB_defined
#endif
#ifndef glMakeTextureHandleNonResidentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeTextureHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeTextureHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentARB, "(%s)", GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentARB(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeTextureHandleNonResidentARB_defined
#endif
#ifndef glMakeTextureHandleResidentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentARB, "(%s)", GET_PRS(handle))
    glatter_glMakeTextureHandleResidentARB(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeTextureHandleResidentARB_defined
#endif
#ifndef glProgramUniformHandleui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformHandleui64ARB, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformHandleui64ARB_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64ARB, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64ARB(program, location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformHandleui64ARB_defined
#endif
#ifndef glProgramUniformHandleui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformHandleui64vARB, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformHandleui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vARB(program, location, count, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformHandleui64vARB_defined
#endif
#ifndef glUniformHandleui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformHandleui64ARB, (location, value), (GLint location, GLuint64 value))
GLATTER_INLINE_OR_NOT void glatter_glUniformHandleui64ARB_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64ARB, "(%d, %s)", (int)location, GET_PRS(value))
    glatter_glUniformHandleui64ARB(location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformHandleui64ARB_defined
#endif
#ifndef glUniformHandleui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformHandleui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformHandleui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformHandleui64vARB_defined
#endif
#ifndef glVertexAttribL1ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1ui64ARB, (index, x), (GLuint index, GLuint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1ui64ARB_debug(GLuint index, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64ARB, "(%u, %s)", (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1ui64ARB(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1ui64ARB_defined
#endif
#ifndef glVertexAttribL1ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1ui64vARB, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1ui64vARB_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64vARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1ui64vARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1ui64vARB_defined
#endif
#endif // defined(GL_ARB_bindless_texture)
#if defined(GL_ARB_cl_event)
#ifndef glCreateSyncFromCLeventARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLsync, APIENTRY, glCreateSyncFromCLeventARB, (context, event, flags), (struct _cl_context *context, struct _cl_event *event, GLbitfield flags))
GLATTER_INLINE_OR_NOT GLsync glatter_glCreateSyncFromCLeventARB_debug(struct _cl_context *context, struct _cl_event *event, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSyncFromCLeventARB, "(%p, %p, %u)", (void*)context, (void*)event, (unsigned int)flags)
    GLsync rval = glatter_glCreateSyncFromCLeventARB(context, event, flags);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateSyncFromCLeventARB_defined
#endif
#endif // defined(GL_ARB_cl_event)
#if defined(GL_ARB_color_buffer_float)
#ifndef glClampColorARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClampColorARB, (target, clamp), (GLenum target, GLenum clamp))
GLATTER_INLINE_OR_NOT void glatter_glClampColorARB_debug(GLenum target, GLenum clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClampColorARB, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(clamp))
    glatter_glClampColorARB(target, clamp);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClampColorARB_defined
#endif
#endif // defined(GL_ARB_color_buffer_float)
#if defined(GL_ARB_compute_variable_group_size)
#ifndef glDispatchComputeGroupSizeARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDispatchComputeGroupSizeARB, (num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z))
GLATTER_INLINE_OR_NOT void glatter_glDispatchComputeGroupSizeARB_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeGroupSizeARB, "(%u, %u, %u, %u, %u, %u)", (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z, (unsigned int)group_size_x, (unsigned int)group_size_y, (unsigned int)group_size_z)
    glatter_glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDispatchComputeGroupSizeARB_defined
#endif
#endif // defined(GL_ARB_compute_variable_group_size)
#if defined(GL_ARB_debug_output)
#ifndef glDebugMessageCallbackARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageCallbackARB, (callback, userParam), (GLDEBUGPROCARB callback, const void *userParam))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageCallbackARB_debug(GLDEBUGPROCARB callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackARB, "(%s, %p)", GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackARB(callback, userParam);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageCallbackARB_defined
#endif
#ifndef glDebugMessageControlARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageControlARB, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageControlARB_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControlARB, "(%s, %s, %s, %d, %p, %u)", enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControlARB(source, type, severity, count, ids, enabled);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageControlARB_defined
#endif
#ifndef glDebugMessageInsertARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageInsertARB, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageInsertARB_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertARB, "(%s, %s, %u, %s, %d, %p)", enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsertARB(source, type, id, severity, length, buf);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageInsertARB_defined
#endif
#ifndef glGetDebugMessageLogARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetDebugMessageLogARB, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetDebugMessageLogARB_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogARB, "(%u, %d, %p, %p, %p, %p, %p, %p)", (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetDebugMessageLogARB_defined
#endif
#endif // defined(GL_ARB_debug_output)
#if defined(GL_ARB_draw_buffers)
#ifndef glDrawBuffersARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawBuffersARB, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_INLINE_OR_NOT void glatter_glDrawBuffersARB_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersARB, "(%d, %p)", (int)n, (void*)bufs)
    glatter_glDrawBuffersARB(n, bufs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawBuffersARB_defined
#endif
#endif // defined(GL_ARB_draw_buffers)
#if defined(GL_ARB_draw_buffers_blend)
#ifndef glBlendEquationSeparateiARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationSeparateiARB, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationSeparateiARB_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateiARB, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationSeparateiARB_defined
#endif
#ifndef glBlendEquationiARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationiARB, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationiARB_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationiARB, "(%u, %s)", (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationiARB(buf, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationiARB_defined
#endif
#ifndef glBlendFuncSeparateiARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparateiARB, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparateiARB_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateiARB, "(%u, %s, %s, %s, %s)", (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparateiARB_defined
#endif
#ifndef glBlendFunciARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFunciARB, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_INLINE_OR_NOT void glatter_glBlendFunciARB_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunciARB, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunciARB(buf, src, dst);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFunciARB_defined
#endif
#endif // defined(GL_ARB_draw_buffers_blend)
#if defined(GL_ARB_draw_instanced)
#ifndef glDrawArraysInstancedARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysInstancedARB, (mode, first, count, primcount), (GLenum mode, GLint first, GLsizei count, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysInstancedARB_debug(GLenum mode, GLint first, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedARB, "(%s, %d, %d, %d)", enum_to_string_GL(mode), (int)first, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedARB(mode, first, count, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysInstancedARB_defined
#endif
#ifndef glDrawElementsInstancedARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstancedARB, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstancedARB_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedARB, "(%s, %d, %s, %p, %d)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedARB(mode, count, type, indices, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstancedARB_defined
#endif
#endif // defined(GL_ARB_draw_instanced)
#if defined(GL_ARB_fragment_program)
#ifndef glBindProgramARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindProgramARB, (target, program), (GLenum target, GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glBindProgramARB_debug(GLenum target, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramARB, "(%s, %u)", enum_to_string_GL(target), (unsigned int)program)
    glatter_glBindProgramARB(target, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindProgramARB_defined
#endif
#ifndef glDeleteProgramsARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteProgramsARB, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_INLINE_OR_NOT void glatter_glDeleteProgramsARB_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramsARB, "(%d, %p)", (int)n, (void*)programs)
    glatter_glDeleteProgramsARB(n, programs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteProgramsARB_defined
#endif
#ifndef glGenProgramsARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenProgramsARB, (n, programs), (GLsizei n, GLuint *programs))
GLATTER_INLINE_OR_NOT void glatter_glGenProgramsARB_debug(GLsizei n, GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramsARB, "(%d, %p)", (int)n, (void*)programs)
    glatter_glGenProgramsARB(n, programs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenProgramsARB_defined
#endif
#ifndef glGetProgramEnvParameterdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramEnvParameterdvARB, (target, index, params), (GLenum target, GLuint index, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramEnvParameterdvARB_debug(GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterdvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterdvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramEnvParameterdvARB_defined
#endif
#ifndef glGetProgramEnvParameterfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramEnvParameterfvARB, (target, index, params), (GLenum target, GLuint index, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramEnvParameterfvARB_debug(GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterfvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterfvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramEnvParameterfvARB_defined
#endif
#ifndef glGetProgramLocalParameterdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramLocalParameterdvARB, (target, index, params), (GLenum target, GLuint index, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramLocalParameterdvARB_debug(GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterdvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterdvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramLocalParameterdvARB_defined
#endif
#ifndef glGetProgramLocalParameterfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramLocalParameterfvARB, (target, index, params), (GLenum target, GLuint index, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramLocalParameterfvARB_debug(GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterfvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterfvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramLocalParameterfvARB_defined
#endif
#ifndef glGetProgramStringARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramStringARB, (target, pname, string), (GLenum target, GLenum pname, void *string))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramStringARB_debug(GLenum target, GLenum pname, void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStringARB, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)string)
    glatter_glGetProgramStringARB(target, pname, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramStringARB_defined
#endif
#ifndef glGetProgramivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramivARB, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramivARB(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramivARB_defined
#endif
#ifndef glIsProgramARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsProgramARB, (program), (GLuint program))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsProgramARB_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramARB, "(%u)", (unsigned int)program)
    GLboolean rval = glatter_glIsProgramARB(program);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsProgramARB_defined
#endif
#ifndef glProgramEnvParameter4dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameter4dARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameter4dARB_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4dARB, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramEnvParameter4dARB(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameter4dARB_defined
#endif
#ifndef glProgramEnvParameter4dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameter4dvARB, (target, index, params), (GLenum target, GLuint index, const GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameter4dvARB_debug(GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4dvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameter4dvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameter4dvARB_defined
#endif
#ifndef glProgramEnvParameter4fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameter4fARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameter4fARB_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4fARB, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramEnvParameter4fARB(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameter4fARB_defined
#endif
#ifndef glProgramEnvParameter4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameter4fvARB, (target, index, params), (GLenum target, GLuint index, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameter4fvARB_debug(GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4fvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameter4fvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameter4fvARB_defined
#endif
#ifndef glProgramLocalParameter4dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameter4dARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameter4dARB_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4dARB, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramLocalParameter4dARB(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameter4dARB_defined
#endif
#ifndef glProgramLocalParameter4dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameter4dvARB, (target, index, params), (GLenum target, GLuint index, const GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameter4dvARB_debug(GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4dvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameter4dvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameter4dvARB_defined
#endif
#ifndef glProgramLocalParameter4fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameter4fARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameter4fARB_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4fARB, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramLocalParameter4fARB(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameter4fARB_defined
#endif
#ifndef glProgramLocalParameter4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameter4fvARB, (target, index, params), (GLenum target, GLuint index, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameter4fvARB_debug(GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4fvARB, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameter4fvARB(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameter4fvARB_defined
#endif
#ifndef glProgramStringARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramStringARB, (target, format, len, string), (GLenum target, GLenum format, GLsizei len, const void *string))
GLATTER_INLINE_OR_NOT void glatter_glProgramStringARB_debug(GLenum target, GLenum format, GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramStringARB, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(format), (int)len, (void*)string)
    glatter_glProgramStringARB(target, format, len, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramStringARB_defined
#endif
#endif // defined(GL_ARB_fragment_program)
#if defined(GL_ARB_geometry_shader4)
#ifndef glFramebufferTextureARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureARB, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureARB, "(%s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureARB(target, attachment, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureARB_defined
#endif
#ifndef glFramebufferTextureFaceARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureFaceARB, (target, attachment, texture, level, face), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureFaceARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureFaceARB, "(%s, %s, %u, %d, %s)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glFramebufferTextureFaceARB(target, attachment, texture, level, face);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureFaceARB_defined
#endif
#ifndef glFramebufferTextureLayerARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureLayerARB, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureLayerARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayerARB, "(%s, %s, %u, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureLayerARB_defined
#endif
#ifndef glProgramParameteriARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameteriARB, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameteriARB_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteriARB, "(%u, %s, %d)", (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteriARB(program, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameteriARB_defined
#endif
#endif // defined(GL_ARB_geometry_shader4)
#if defined(GL_ARB_gl_spirv)
#ifndef glSpecializeShaderARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpecializeShaderARB, (shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue), (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue))
GLATTER_INLINE_OR_NOT void glatter_glSpecializeShaderARB_debug(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpecializeShaderARB, "(%u, %p, %u, %p, %p)", (unsigned int)shader, (void*)pEntryPoint, (unsigned int)numSpecializationConstants, (void*)pConstantIndex, (void*)pConstantValue)
    glatter_glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpecializeShaderARB_defined
#endif
#endif // defined(GL_ARB_gl_spirv)
#if defined(GL_ARB_gpu_shader_int64)
#ifndef glGetUniformi64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformi64vARB, (program, location, params), (GLuint program, GLint location, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformi64vARB_debug(GLuint program, GLint location, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vARB, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vARB(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformi64vARB_defined
#endif
#ifndef glGetUniformui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformui64vARB, (program, location, params), (GLuint program, GLint location, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformui64vARB_debug(GLuint program, GLint location, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformui64vARB, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformui64vARB(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformui64vARB_defined
#endif
#ifndef glGetnUniformi64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformi64vARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformi64vARB_debug(GLuint program, GLint location, GLsizei bufSize, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformi64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformi64vARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformi64vARB_defined
#endif
#ifndef glGetnUniformui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformui64vARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformui64vARB_debug(GLuint program, GLint location, GLsizei bufSize, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformui64vARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformui64vARB_defined
#endif
#ifndef glProgramUniform1i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1i64ARB, (program, location, x), (GLuint program, GLint location, GLint64 x))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1i64ARB_debug(GLuint program, GLint location, GLint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64ARB, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64ARB(program, location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1i64ARB_defined
#endif
#ifndef glProgramUniform1i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1i64vARB_defined
#endif
#ifndef glProgramUniform1ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ui64ARB, (program, location, x), (GLuint program, GLint location, GLuint64 x))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ui64ARB_debug(GLuint program, GLint location, GLuint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64ARB, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64ARB(program, location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ui64ARB_defined
#endif
#ifndef glProgramUniform1ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ui64vARB_defined
#endif
#ifndef glProgramUniform2i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2i64ARB, (program, location, x, y), (GLuint program, GLint location, GLint64 x, GLint64 y))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64ARB, "(%u, %d, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64ARB(program, location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2i64ARB_defined
#endif
#ifndef glProgramUniform2i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2i64vARB_defined
#endif
#ifndef glProgramUniform2ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ui64ARB, (program, location, x, y), (GLuint program, GLint location, GLuint64 x, GLuint64 y))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64ARB, "(%u, %d, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64ARB(program, location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ui64ARB_defined
#endif
#ifndef glProgramUniform2ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ui64vARB_defined
#endif
#ifndef glProgramUniform3i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3i64ARB, (program, location, x, y, z), (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64ARB, "(%u, %d, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64ARB(program, location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3i64ARB_defined
#endif
#ifndef glProgramUniform3i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3i64vARB_defined
#endif
#ifndef glProgramUniform3ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ui64ARB, (program, location, x, y, z), (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64ARB, "(%u, %d, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64ARB(program, location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ui64ARB_defined
#endif
#ifndef glProgramUniform3ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ui64vARB_defined
#endif
#ifndef glProgramUniform4i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4i64ARB, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64ARB, "(%u, %d, %s, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64ARB(program, location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4i64ARB_defined
#endif
#ifndef glProgramUniform4i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4i64vARB_defined
#endif
#ifndef glProgramUniform4ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ui64ARB, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64ARB, "(%u, %d, %s, %s, %s, %s)", (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64ARB(program, location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ui64ARB_defined
#endif
#ifndef glProgramUniform4ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vARB(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ui64vARB_defined
#endif
#ifndef glUniform1i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1i64ARB, (location, x), (GLint location, GLint64 x))
GLATTER_INLINE_OR_NOT void glatter_glUniform1i64ARB_debug(GLint location, GLint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64ARB, "(%d, %s)", (int)location, GET_PRS(x))
    glatter_glUniform1i64ARB(location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1i64ARB_defined
#endif
#ifndef glUniform1i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1i64vARB_defined
#endif
#ifndef glUniform1ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ui64ARB, (location, x), (GLint location, GLuint64 x))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ui64ARB_debug(GLint location, GLuint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64ARB, "(%d, %s)", (int)location, GET_PRS(x))
    glatter_glUniform1ui64ARB(location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ui64ARB_defined
#endif
#ifndef glUniform1ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ui64vARB_defined
#endif
#ifndef glUniform2i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2i64ARB, (location, x, y), (GLint location, GLint64 x, GLint64 y))
GLATTER_INLINE_OR_NOT void glatter_glUniform2i64ARB_debug(GLint location, GLint64 x, GLint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64ARB, "(%d, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64ARB(location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2i64ARB_defined
#endif
#ifndef glUniform2i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2i64vARB_defined
#endif
#ifndef glUniform2ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ui64ARB, (location, x, y), (GLint location, GLuint64 x, GLuint64 y))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64ARB, "(%d, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64ARB(location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ui64ARB_defined
#endif
#ifndef glUniform2ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ui64vARB_defined
#endif
#ifndef glUniform3i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3i64ARB, (location, x, y, z), (GLint location, GLint64 x, GLint64 y, GLint64 z))
GLATTER_INLINE_OR_NOT void glatter_glUniform3i64ARB_debug(GLint location, GLint64 x, GLint64 y, GLint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64ARB, "(%d, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64ARB(location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3i64ARB_defined
#endif
#ifndef glUniform3i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3i64vARB_defined
#endif
#ifndef glUniform3ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ui64ARB, (location, x, y, z), (GLint location, GLuint64 x, GLuint64 y, GLuint64 z))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64ARB, "(%d, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64ARB(location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ui64ARB_defined
#endif
#ifndef glUniform3ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ui64vARB_defined
#endif
#ifndef glUniform4i64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4i64ARB, (location, x, y, z, w), (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w))
GLATTER_INLINE_OR_NOT void glatter_glUniform4i64ARB_debug(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64ARB, "(%d, %s, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64ARB(location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4i64ARB_defined
#endif
#ifndef glUniform4i64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4i64vARB_defined
#endif
#ifndef glUniform4ui64ARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ui64ARB, (location, x, y, z, w), (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64ARB, "(%d, %s, %s, %s, %s)", (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64ARB(location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ui64ARB_defined
#endif
#ifndef glUniform4ui64vARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ui64vARB_defined
#endif
#endif // defined(GL_ARB_gpu_shader_int64)
#if defined(GL_ARB_imaging)
#ifndef glColorSubTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorSubTable, (target, start, count, format, type, data), (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glColorSubTable_debug(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorSubTable, "(%s, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)start, (int)count, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glColorSubTable(target, start, count, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorSubTable_defined
#endif
#ifndef glColorTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTable, (target, internalformat, width, format, type, table), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_INLINE_OR_NOT void glatter_glColorTable_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTable, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTable(target, internalformat, width, format, type, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTable_defined
#endif
#ifndef glColorTableParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glColorTableParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableParameterfv_defined
#endif
#ifndef glColorTableParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glColorTableParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableParameteriv_defined
#endif
#ifndef glConvolutionFilter1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionFilter1D, (target, internalformat, width, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionFilter1D_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter1D, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter1D(target, internalformat, width, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionFilter1D_defined
#endif
#ifndef glConvolutionFilter2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionFilter2D, (target, internalformat, width, height, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionFilter2D_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter2D, "(%s, %s, %d, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionFilter2D_defined
#endif
#ifndef glConvolutionParameterf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterf, (target, pname, params), (GLenum target, GLenum pname, GLfloat params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterf_debug(GLenum target, GLenum pname, GLfloat params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterf, "(%s, %s, %f)", enum_to_string_GL(target), enum_to_string_GL(pname), (float)params)
    glatter_glConvolutionParameterf(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterf_defined
#endif
#ifndef glConvolutionParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterfv_defined
#endif
#ifndef glConvolutionParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameteri, (target, pname, params), (GLenum target, GLenum pname, GLint params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameteri_debug(GLenum target, GLenum pname, GLint params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteri, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)params)
    glatter_glConvolutionParameteri(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameteri_defined
#endif
#ifndef glConvolutionParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameteriv_defined
#endif
#ifndef glCopyColorSubTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyColorSubTable, (target, start, x, y, width), (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyColorSubTable_debug(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorSubTable, "(%s, %d, %d, %d, %d)", enum_to_string_GL(target), (int)start, (int)x, (int)y, (int)width)
    glatter_glCopyColorSubTable(target, start, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyColorSubTable_defined
#endif
#ifndef glCopyColorTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyColorTable, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyColorTable_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorTable, "(%s, %s, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyColorTable(target, internalformat, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyColorTable_defined
#endif
#ifndef glCopyConvolutionFilter1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyConvolutionFilter1D, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyConvolutionFilter1D_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter1D, "(%s, %s, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyConvolutionFilter1D(target, internalformat, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyConvolutionFilter1D_defined
#endif
#ifndef glCopyConvolutionFilter2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyConvolutionFilter2D, (target, internalformat, x, y, width, height), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyConvolutionFilter2D_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter2D, "(%s, %s, %d, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyConvolutionFilter2D_defined
#endif
#ifndef glGetColorTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTable, (target, format, type, table), (GLenum target, GLenum format, GLenum type, void *table))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTable_debug(GLenum target, GLenum format, GLenum type, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTable, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glGetColorTable(target, format, type, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTable_defined
#endif
#ifndef glGetColorTableParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameterfv_defined
#endif
#ifndef glGetColorTableParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameteriv_defined
#endif
#ifndef glGetConvolutionFilter_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionFilter, (target, format, type, image), (GLenum target, GLenum format, GLenum type, void *image))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionFilter_debug(GLenum target, GLenum format, GLenum type, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionFilter, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glGetConvolutionFilter(target, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionFilter_defined
#endif
#ifndef glGetConvolutionParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionParameterfv_defined
#endif
#ifndef glGetConvolutionParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionParameteriv_defined
#endif
#ifndef glGetHistogram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogram, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogram_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogram, "(%s, %u, %s, %s, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetHistogram(target, reset, format, type, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogram_defined
#endif
#ifndef glGetHistogramParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramParameterfv_defined
#endif
#ifndef glGetHistogramParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramParameteriv_defined
#endif
#ifndef glGetMinmax_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmax, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmax_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmax, "(%s, %u, %s, %s, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetMinmax(target, reset, format, type, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmax_defined
#endif
#ifndef glGetMinmaxParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmaxParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmaxParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterfv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterfv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmaxParameterfv_defined
#endif
#ifndef glGetMinmaxParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmaxParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmaxParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmaxParameteriv_defined
#endif
#ifndef glGetSeparableFilter_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSeparableFilter, (target, format, type, row, column, span), (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span))
GLATTER_INLINE_OR_NOT void glatter_glGetSeparableFilter_debug(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSeparableFilter, "(%s, %s, %s, %p, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column, (void*)span)
    glatter_glGetSeparableFilter(target, format, type, row, column, span);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSeparableFilter_defined
#endif
#ifndef glHistogram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glHistogram, (target, width, internalformat, sink), (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink))
GLATTER_INLINE_OR_NOT void glatter_glHistogram_debug(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHistogram, "(%s, %d, %s, %u)", enum_to_string_GL(target), (int)width, enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glHistogram(target, width, internalformat, sink);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glHistogram_defined
#endif
#ifndef glMinmax_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMinmax, (target, internalformat, sink), (GLenum target, GLenum internalformat, GLboolean sink))
GLATTER_INLINE_OR_NOT void glatter_glMinmax_debug(GLenum target, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinmax, "(%s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glMinmax(target, internalformat, sink);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMinmax_defined
#endif
#ifndef glResetHistogram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResetHistogram, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glResetHistogram_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetHistogram, "(%s)", enum_to_string_GL(target))
    glatter_glResetHistogram(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResetHistogram_defined
#endif
#ifndef glResetMinmax_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResetMinmax, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glResetMinmax_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetMinmax, "(%s)", enum_to_string_GL(target))
    glatter_glResetMinmax(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResetMinmax_defined
#endif
#ifndef glSeparableFilter2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSeparableFilter2D, (target, internalformat, width, height, format, type, row, column), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column))
GLATTER_INLINE_OR_NOT void glatter_glSeparableFilter2D_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSeparableFilter2D, "(%s, %s, %d, %d, %s, %s, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column)
    glatter_glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSeparableFilter2D_defined
#endif
#endif // defined(GL_ARB_imaging)
#if defined(GL_ARB_indirect_parameters)
#ifndef glMultiDrawArraysIndirectCountARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirectCountARB, (mode, indirect, drawcount, maxdrawcount, stride), (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirectCountARB_debug(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectCountARB, "(%s, %p, %s, %d, %d)", enum_to_string_GL(mode), (void*)indirect, GET_PRS(drawcount), (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirectCountARB_defined
#endif
#ifndef glMultiDrawElementsIndirectCountARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirectCountARB, (mode, type, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirectCountARB_debug(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectCountARB, "(%s, %s, %p, %s, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, GET_PRS(drawcount), (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawElementsIndirectCountARB(mode, type, indirect, drawcount, maxdrawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirectCountARB_defined
#endif
#endif // defined(GL_ARB_indirect_parameters)
#if defined(GL_ARB_instanced_arrays)
#ifndef glVertexAttribDivisorARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribDivisorARB, (index, divisor), (GLuint index, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribDivisorARB_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisorARB, "(%u, %u)", (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisorARB(index, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribDivisorARB_defined
#endif
#endif // defined(GL_ARB_instanced_arrays)
#if defined(GL_ARB_matrix_palette)
#ifndef glCurrentPaletteMatrixARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCurrentPaletteMatrixARB, (index), (GLint index))
GLATTER_INLINE_OR_NOT void glatter_glCurrentPaletteMatrixARB_debug(GLint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCurrentPaletteMatrixARB, "(%d)", (int)index)
    glatter_glCurrentPaletteMatrixARB(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCurrentPaletteMatrixARB_defined
#endif
#ifndef glMatrixIndexPointerARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixIndexPointerARB, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glMatrixIndexPointerARB_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexPointerARB, "(%d, %s, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glMatrixIndexPointerARB(size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixIndexPointerARB_defined
#endif
#ifndef glMatrixIndexubvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixIndexubvARB, (size, indices), (GLint size, const GLubyte *indices))
GLATTER_INLINE_OR_NOT void glatter_glMatrixIndexubvARB_debug(GLint size, const GLubyte *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexubvARB, "(%d, %p)", (int)size, (void*)indices)
    glatter_glMatrixIndexubvARB(size, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixIndexubvARB_defined
#endif
#ifndef glMatrixIndexuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixIndexuivARB, (size, indices), (GLint size, const GLuint *indices))
GLATTER_INLINE_OR_NOT void glatter_glMatrixIndexuivARB_debug(GLint size, const GLuint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexuivARB, "(%d, %p)", (int)size, (void*)indices)
    glatter_glMatrixIndexuivARB(size, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixIndexuivARB_defined
#endif
#ifndef glMatrixIndexusvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixIndexusvARB, (size, indices), (GLint size, const GLushort *indices))
GLATTER_INLINE_OR_NOT void glatter_glMatrixIndexusvARB_debug(GLint size, const GLushort *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexusvARB, "(%d, %p)", (int)size, (void*)indices)
    glatter_glMatrixIndexusvARB(size, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixIndexusvARB_defined
#endif
#endif // defined(GL_ARB_matrix_palette)
#if defined(GL_ARB_multisample)
#ifndef glSampleCoverageARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleCoverageARB, (value, invert), (GLfloat value, GLboolean invert))
GLATTER_INLINE_OR_NOT void glatter_glSampleCoverageARB_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverageARB, "(%f, %u)", (float)value, (unsigned char)invert)
    glatter_glSampleCoverageARB(value, invert);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleCoverageARB_defined
#endif
#endif // defined(GL_ARB_multisample)
#if defined(GL_ARB_multitexture)
#ifndef glActiveTextureARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveTextureARB, (texture), (GLenum texture))
GLATTER_INLINE_OR_NOT void glatter_glActiveTextureARB_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTextureARB, "(%s)", enum_to_string_GL(texture))
    glatter_glActiveTextureARB(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveTextureARB_defined
#endif
#ifndef glClientActiveTextureARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClientActiveTextureARB, (texture), (GLenum texture))
GLATTER_INLINE_OR_NOT void glatter_glClientActiveTextureARB_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveTextureARB, "(%s)", enum_to_string_GL(texture))
    glatter_glClientActiveTextureARB(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClientActiveTextureARB_defined
#endif
#ifndef glMultiTexCoord1dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1dARB, (target, s), (GLenum target, GLdouble s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1dARB_debug(GLenum target, GLdouble s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dARB, "(%s, %f)", enum_to_string_GL(target), (double)s)
    glatter_glMultiTexCoord1dARB(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1dARB_defined
#endif
#ifndef glMultiTexCoord1dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1dvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1dvARB_defined
#endif
#ifndef glMultiTexCoord1fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1fARB, (target, s), (GLenum target, GLfloat s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1fARB_debug(GLenum target, GLfloat s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fARB, "(%s, %f)", enum_to_string_GL(target), (float)s)
    glatter_glMultiTexCoord1fARB(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1fARB_defined
#endif
#ifndef glMultiTexCoord1fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1fvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1fvARB_defined
#endif
#ifndef glMultiTexCoord1iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1iARB, (target, s), (GLenum target, GLint s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1iARB_debug(GLenum target, GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1iARB, "(%s, %d)", enum_to_string_GL(target), (int)s)
    glatter_glMultiTexCoord1iARB(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1iARB_defined
#endif
#ifndef glMultiTexCoord1ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1ivARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1ivARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1ivARB_defined
#endif
#ifndef glMultiTexCoord1sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1sARB, (target, s), (GLenum target, GLshort s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1sARB_debug(GLenum target, GLshort s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1sARB, "(%s, %hi)", enum_to_string_GL(target), (short)s)
    glatter_glMultiTexCoord1sARB(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1sARB_defined
#endif
#ifndef glMultiTexCoord1svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1svARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1svARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1svARB_defined
#endif
#ifndef glMultiTexCoord2dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2dARB, (target, s, t), (GLenum target, GLdouble s, GLdouble t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2dARB_debug(GLenum target, GLdouble s, GLdouble t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dARB, "(%s, %f, %f)", enum_to_string_GL(target), (double)s, (double)t)
    glatter_glMultiTexCoord2dARB(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2dARB_defined
#endif
#ifndef glMultiTexCoord2dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2dvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2dvARB_defined
#endif
#ifndef glMultiTexCoord2fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2fARB, (target, s, t), (GLenum target, GLfloat s, GLfloat t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2fARB_debug(GLenum target, GLfloat s, GLfloat t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fARB, "(%s, %f, %f)", enum_to_string_GL(target), (float)s, (float)t)
    glatter_glMultiTexCoord2fARB(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2fARB_defined
#endif
#ifndef glMultiTexCoord2fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2fvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2fvARB_defined
#endif
#ifndef glMultiTexCoord2iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2iARB, (target, s, t), (GLenum target, GLint s, GLint t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2iARB_debug(GLenum target, GLint s, GLint t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2iARB, "(%s, %d, %d)", enum_to_string_GL(target), (int)s, (int)t)
    glatter_glMultiTexCoord2iARB(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2iARB_defined
#endif
#ifndef glMultiTexCoord2ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2ivARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2ivARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2ivARB_defined
#endif
#ifndef glMultiTexCoord2sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2sARB, (target, s, t), (GLenum target, GLshort s, GLshort t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2sARB_debug(GLenum target, GLshort s, GLshort t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2sARB, "(%s, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t)
    glatter_glMultiTexCoord2sARB(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2sARB_defined
#endif
#ifndef glMultiTexCoord2svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2svARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2svARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2svARB_defined
#endif
#ifndef glMultiTexCoord3dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3dARB, (target, s, t, r), (GLenum target, GLdouble s, GLdouble t, GLdouble r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3dARB_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dARB, "(%s, %f, %f, %f)", enum_to_string_GL(target), (double)s, (double)t, (double)r)
    glatter_glMultiTexCoord3dARB(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3dARB_defined
#endif
#ifndef glMultiTexCoord3dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3dvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3dvARB_defined
#endif
#ifndef glMultiTexCoord3fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3fARB, (target, s, t, r), (GLenum target, GLfloat s, GLfloat t, GLfloat r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3fARB_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fARB, "(%s, %f, %f, %f)", enum_to_string_GL(target), (float)s, (float)t, (float)r)
    glatter_glMultiTexCoord3fARB(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3fARB_defined
#endif
#ifndef glMultiTexCoord3fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3fvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3fvARB_defined
#endif
#ifndef glMultiTexCoord3iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3iARB, (target, s, t, r), (GLenum target, GLint s, GLint t, GLint r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3iARB_debug(GLenum target, GLint s, GLint t, GLint r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3iARB, "(%s, %d, %d, %d)", enum_to_string_GL(target), (int)s, (int)t, (int)r)
    glatter_glMultiTexCoord3iARB(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3iARB_defined
#endif
#ifndef glMultiTexCoord3ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3ivARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3ivARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3ivARB_defined
#endif
#ifndef glMultiTexCoord3sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3sARB, (target, s, t, r), (GLenum target, GLshort s, GLshort t, GLshort r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3sARB_debug(GLenum target, GLshort s, GLshort t, GLshort r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3sARB, "(%s, %hi, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t, (short)r)
    glatter_glMultiTexCoord3sARB(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3sARB_defined
#endif
#ifndef glMultiTexCoord3svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3svARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3svARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3svARB_defined
#endif
#ifndef glMultiTexCoord4dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4dARB, (target, s, t, r, q), (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4dARB_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dARB, "(%s, %f, %f, %f, %f)", enum_to_string_GL(target), (double)s, (double)t, (double)r, (double)q)
    glatter_glMultiTexCoord4dARB(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4dARB_defined
#endif
#ifndef glMultiTexCoord4dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4dvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4dvARB_defined
#endif
#ifndef glMultiTexCoord4fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4fARB, (target, s, t, r, q), (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4fARB_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fARB, "(%s, %f, %f, %f, %f)", enum_to_string_GL(target), (float)s, (float)t, (float)r, (float)q)
    glatter_glMultiTexCoord4fARB(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4fARB_defined
#endif
#ifndef glMultiTexCoord4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fvARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4fvARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4fvARB_defined
#endif
#ifndef glMultiTexCoord4iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4iARB, (target, s, t, r, q), (GLenum target, GLint s, GLint t, GLint r, GLint q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4iARB_debug(GLenum target, GLint s, GLint t, GLint r, GLint q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4iARB, "(%s, %d, %d, %d, %d)", enum_to_string_GL(target), (int)s, (int)t, (int)r, (int)q)
    glatter_glMultiTexCoord4iARB(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4iARB_defined
#endif
#ifndef glMultiTexCoord4ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4ivARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4ivARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4ivARB_defined
#endif
#ifndef glMultiTexCoord4sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4sARB, (target, s, t, r, q), (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4sARB_debug(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4sARB, "(%s, %hi, %hi, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t, (short)r, (short)q)
    glatter_glMultiTexCoord4sARB(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4sARB_defined
#endif
#ifndef glMultiTexCoord4svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4svARB, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4svARB(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4svARB_defined
#endif
#endif // defined(GL_ARB_multitexture)
#if defined(GL_ARB_occlusion_query)
#ifndef glBeginQueryARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginQueryARB, (target, id), (GLenum target, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBeginQueryARB_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryARB, "(%s, %u)", enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQueryARB(target, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginQueryARB_defined
#endif
#ifndef glDeleteQueriesARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteQueriesARB, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glDeleteQueriesARB_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueriesARB, "(%d, %p)", (int)n, (void*)ids)
    glatter_glDeleteQueriesARB(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteQueriesARB_defined
#endif
#ifndef glEndQueryARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndQueryARB, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glEndQueryARB_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryARB, "(%s)", enum_to_string_GL(target))
    glatter_glEndQueryARB(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndQueryARB_defined
#endif
#ifndef glGenQueriesARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenQueriesARB, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glGenQueriesARB_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueriesARB, "(%d, %p)", (int)n, (void*)ids)
    glatter_glGenQueriesARB(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenQueriesARB_defined
#endif
#ifndef glGetQueryObjectivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectivARB, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectivARB_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectivARB, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectivARB(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectivARB_defined
#endif
#ifndef glGetQueryObjectuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectuivARB, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectuivARB_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuivARB, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuivARB(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectuivARB_defined
#endif
#ifndef glGetQueryivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryivARB, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryivARB(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryivARB_defined
#endif
#ifndef glIsQueryARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsQueryARB, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsQueryARB_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQueryARB, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsQueryARB(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsQueryARB_defined
#endif
#endif // defined(GL_ARB_occlusion_query)
#if defined(GL_ARB_parallel_shader_compile)
#ifndef glMaxShaderCompilerThreadsARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMaxShaderCompilerThreadsARB, (count), (GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glMaxShaderCompilerThreadsARB_debug(GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaxShaderCompilerThreadsARB, "(%u)", (unsigned int)count)
    glatter_glMaxShaderCompilerThreadsARB(count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMaxShaderCompilerThreadsARB_defined
#endif
#endif // defined(GL_ARB_parallel_shader_compile)
#if defined(GL_ARB_point_parameters)
#ifndef glPointParameterfARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfARB, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfARB_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfARB, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfARB(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfARB_defined
#endif
#ifndef glPointParameterfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfvARB, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfvARB_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvARB, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvARB(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfvARB_defined
#endif
#endif // defined(GL_ARB_point_parameters)
#if defined(GL_ARB_robustness)
#ifndef glGetGraphicsResetStatusARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glGetGraphicsResetStatusARB, (), (void))
GLATTER_INLINE_OR_NOT GLenum glatter_glGetGraphicsResetStatusARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatusARB, "()")
    GLenum rval = glatter_glGetGraphicsResetStatusARB();
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetGraphicsResetStatusARB_defined
#endif
#ifndef glGetnColorTableARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnColorTableARB, (target, format, type, bufSize, table), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table))
GLATTER_INLINE_OR_NOT void glatter_glGetnColorTableARB_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnColorTableARB, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)table)
    glatter_glGetnColorTableARB(target, format, type, bufSize, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnColorTableARB_defined
#endif
#ifndef glGetnCompressedTexImageARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnCompressedTexImageARB, (target, lod, bufSize, img), (GLenum target, GLint lod, GLsizei bufSize, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetnCompressedTexImageARB_debug(GLenum target, GLint lod, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImageARB, "(%s, %d, %d, %p)", enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)img)
    glatter_glGetnCompressedTexImageARB(target, lod, bufSize, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnCompressedTexImageARB_defined
#endif
#ifndef glGetnConvolutionFilterARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnConvolutionFilterARB, (target, format, type, bufSize, image), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image))
GLATTER_INLINE_OR_NOT void glatter_glGetnConvolutionFilterARB_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnConvolutionFilterARB, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)image)
    glatter_glGetnConvolutionFilterARB(target, format, type, bufSize, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnConvolutionFilterARB_defined
#endif
#ifndef glGetnHistogramARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnHistogramARB, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnHistogramARB_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnHistogramARB, "(%s, %u, %s, %s, %d, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnHistogramARB(target, reset, format, type, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnHistogramARB_defined
#endif
#ifndef glGetnMapdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapdvARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapdvARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapdvARB, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapdvARB(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapdvARB_defined
#endif
#ifndef glGetnMapfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapfvARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapfvARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapfvARB, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapfvARB(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapfvARB_defined
#endif
#ifndef glGetnMapivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapivARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapivARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapivARB, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapivARB(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapivARB_defined
#endif
#ifndef glGetnMinmaxARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMinmaxARB, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnMinmaxARB_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMinmaxARB, "(%s, %u, %s, %s, %d, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnMinmaxARB(target, reset, format, type, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMinmaxARB_defined
#endif
#ifndef glGetnPixelMapfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapfvARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapfvARB_debug(GLenum map, GLsizei bufSize, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapfvARB, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapfvARB(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapfvARB_defined
#endif
#ifndef glGetnPixelMapuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapuivARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLuint *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapuivARB_debug(GLenum map, GLsizei bufSize, GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapuivARB, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapuivARB(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapuivARB_defined
#endif
#ifndef glGetnPixelMapusvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapusvARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLushort *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapusvARB_debug(GLenum map, GLsizei bufSize, GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapusvARB, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapusvARB(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapusvARB_defined
#endif
#ifndef glGetnPolygonStippleARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPolygonStippleARB, (bufSize, pattern), (GLsizei bufSize, GLubyte *pattern))
GLATTER_INLINE_OR_NOT void glatter_glGetnPolygonStippleARB_debug(GLsizei bufSize, GLubyte *pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPolygonStippleARB, "(%d, %p)", (int)bufSize, (void*)pattern)
    glatter_glGetnPolygonStippleARB(bufSize, pattern);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPolygonStippleARB_defined
#endif
#ifndef glGetnSeparableFilterARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnSeparableFilterARB, (target, format, type, rowBufSize, row, columnBufSize, column, span), (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span))
GLATTER_INLINE_OR_NOT void glatter_glGetnSeparableFilterARB_debug(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnSeparableFilterARB, "(%s, %s, %s, %d, %p, %d, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)rowBufSize, (void*)row, (int)columnBufSize, (void*)column, (void*)span)
    glatter_glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnSeparableFilterARB_defined
#endif
#ifndef glGetnTexImageARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnTexImageARB, (target, level, format, type, bufSize, img), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetnTexImageARB_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImageARB, "(%s, %d, %s, %s, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)img)
    glatter_glGetnTexImageARB(target, level, format, type, bufSize, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnTexImageARB_defined
#endif
#ifndef glGetnUniformdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformdvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformdvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdvARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdvARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformdvARB_defined
#endif
#ifndef glGetnUniformfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformfvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformfvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfvARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfvARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformfvARB_defined
#endif
#ifndef glGetnUniformivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformivARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformivARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformivARB_defined
#endif
#ifndef glGetnUniformuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformuivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformuivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuivARB, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuivARB(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformuivARB_defined
#endif
#ifndef glReadnPixelsARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReadnPixelsARB, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
GLATTER_INLINE_OR_NOT void glatter_glReadnPixelsARB_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixelsARB, "(%d, %d, %d, %d, %s, %s, %d, %p)", (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReadnPixelsARB_defined
#endif
#endif // defined(GL_ARB_robustness)
#if defined(GL_ARB_sample_locations)
#ifndef glEvaluateDepthValuesARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvaluateDepthValuesARB, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEvaluateDepthValuesARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvaluateDepthValuesARB, "()")
    glatter_glEvaluateDepthValuesARB();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvaluateDepthValuesARB_defined
#endif
#ifndef glFramebufferSampleLocationsfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferSampleLocationsfvARB, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferSampleLocationsfvARB_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvARB, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvARB(target, start, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferSampleLocationsfvARB_defined
#endif
#ifndef glNamedFramebufferSampleLocationsfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferSampleLocationsfvARB, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferSampleLocationsfvARB_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvARB, "(%u, %u, %d, %p)", (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferSampleLocationsfvARB_defined
#endif
#endif // defined(GL_ARB_sample_locations)
#if defined(GL_ARB_sample_shading)
#ifndef glMinSampleShadingARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMinSampleShadingARB, (value), (GLfloat value))
GLATTER_INLINE_OR_NOT void glatter_glMinSampleShadingARB_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShadingARB, "(%f)", (float)value)
    glatter_glMinSampleShadingARB(value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMinSampleShadingARB_defined
#endif
#endif // defined(GL_ARB_sample_shading)
#if defined(GL_ARB_shader_objects)
#ifndef glAttachObjectARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAttachObjectARB, (containerObj, obj), (GLhandleARB containerObj, GLhandleARB obj))
GLATTER_INLINE_OR_NOT void glatter_glAttachObjectARB_debug(GLhandleARB containerObj, GLhandleARB obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachObjectARB, "(%u, %u)", (unsigned int)containerObj, (unsigned int)obj)
    glatter_glAttachObjectARB(containerObj, obj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAttachObjectARB_defined
#endif
#ifndef glCompileShaderARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompileShaderARB, (shaderObj), (GLhandleARB shaderObj))
GLATTER_INLINE_OR_NOT void glatter_glCompileShaderARB_debug(GLhandleARB shaderObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShaderARB, "(%u)", (unsigned int)shaderObj)
    glatter_glCompileShaderARB(shaderObj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompileShaderARB_defined
#endif
#ifndef glCreateProgramObjectARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLhandleARB, APIENTRY, glCreateProgramObjectARB, (), (void))
GLATTER_INLINE_OR_NOT GLhandleARB glatter_glCreateProgramObjectARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgramObjectARB, "()")
    GLhandleARB rval = glatter_glCreateProgramObjectARB();
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateProgramObjectARB_defined
#endif
#ifndef glCreateShaderObjectARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLhandleARB, APIENTRY, glCreateShaderObjectARB, (shaderType), (GLenum shaderType))
GLATTER_INLINE_OR_NOT GLhandleARB glatter_glCreateShaderObjectARB_debug(GLenum shaderType, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderObjectARB, "(%s)", enum_to_string_GL(shaderType))
    GLhandleARB rval = glatter_glCreateShaderObjectARB(shaderType);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateShaderObjectARB_defined
#endif
#ifndef glDeleteObjectARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteObjectARB, (obj), (GLhandleARB obj))
GLATTER_INLINE_OR_NOT void glatter_glDeleteObjectARB_debug(GLhandleARB obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteObjectARB, "(%u)", (unsigned int)obj)
    glatter_glDeleteObjectARB(obj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteObjectARB_defined
#endif
#ifndef glDetachObjectARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDetachObjectARB, (containerObj, attachedObj), (GLhandleARB containerObj, GLhandleARB attachedObj))
GLATTER_INLINE_OR_NOT void glatter_glDetachObjectARB_debug(GLhandleARB containerObj, GLhandleARB attachedObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachObjectARB, "(%u, %u)", (unsigned int)containerObj, (unsigned int)attachedObj)
    glatter_glDetachObjectARB(containerObj, attachedObj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDetachObjectARB_defined
#endif
#ifndef glGetActiveUniformARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniformARB, (programObj, index, maxLength, length, size, type, name), (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniformARB_debug(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformARB, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)programObj, (unsigned int)index, (int)maxLength, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniformARB_defined
#endif
#ifndef glGetAttachedObjectsARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetAttachedObjectsARB, (containerObj, maxCount, count, obj), (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj))
GLATTER_INLINE_OR_NOT void glatter_glGetAttachedObjectsARB_debug(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedObjectsARB, "(%u, %d, %p, %p)", (unsigned int)containerObj, (int)maxCount, (void*)count, (void*)obj)
    glatter_glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetAttachedObjectsARB_defined
#endif
#ifndef glGetHandleARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLhandleARB, APIENTRY, glGetHandleARB, (pname), (GLenum pname))
GLATTER_INLINE_OR_NOT GLhandleARB glatter_glGetHandleARB_debug(GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHandleARB, "(%s)", enum_to_string_GL(pname))
    GLhandleARB rval = glatter_glGetHandleARB(pname);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetHandleARB_defined
#endif
#ifndef glGetInfoLogARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInfoLogARB, (obj, maxLength, length, infoLog), (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog))
GLATTER_INLINE_OR_NOT void glatter_glGetInfoLogARB_debug(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInfoLogARB, "(%u, %d, %p, %p)", (unsigned int)obj, (int)maxLength, (void*)length, (void*)infoLog)
    glatter_glGetInfoLogARB(obj, maxLength, length, infoLog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInfoLogARB_defined
#endif
#ifndef glGetObjectParameterfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectParameterfvARB, (obj, pname, params), (GLhandleARB obj, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectParameterfvARB_debug(GLhandleARB obj, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterfvARB, "(%u, %s, %p)", (unsigned int)obj, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterfvARB(obj, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectParameterfvARB_defined
#endif
#ifndef glGetObjectParameterivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectParameterivARB, (obj, pname, params), (GLhandleARB obj, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectParameterivARB_debug(GLhandleARB obj, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterivARB, "(%u, %s, %p)", (unsigned int)obj, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterivARB(obj, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectParameterivARB_defined
#endif
#ifndef glGetShaderSourceARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShaderSourceARB, (obj, maxLength, length, source), (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source))
GLATTER_INLINE_OR_NOT void glatter_glGetShaderSourceARB_debug(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSourceARB, "(%u, %d, %p, %p)", (unsigned int)obj, (int)maxLength, (void*)length, (void*)source)
    glatter_glGetShaderSourceARB(obj, maxLength, length, source);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShaderSourceARB_defined
#endif
#ifndef glGetUniformLocationARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetUniformLocationARB, (programObj, name), (GLhandleARB programObj, const GLcharARB *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetUniformLocationARB_debug(GLhandleARB programObj, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocationARB, "(%u, %p)", (unsigned int)programObj, (void*)name)
    GLint rval = glatter_glGetUniformLocationARB(programObj, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetUniformLocationARB_defined
#endif
#ifndef glGetUniformfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformfvARB, (programObj, location, params), (GLhandleARB programObj, GLint location, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformfvARB_debug(GLhandleARB programObj, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfvARB, "(%u, %d, %p)", (unsigned int)programObj, (int)location, (void*)params)
    glatter_glGetUniformfvARB(programObj, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformfvARB_defined
#endif
#ifndef glGetUniformivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformivARB, (programObj, location, params), (GLhandleARB programObj, GLint location, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformivARB_debug(GLhandleARB programObj, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformivARB, "(%u, %d, %p)", (unsigned int)programObj, (int)location, (void*)params)
    glatter_glGetUniformivARB(programObj, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformivARB_defined
#endif
#ifndef glLinkProgramARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLinkProgramARB, (programObj), (GLhandleARB programObj))
GLATTER_INLINE_OR_NOT void glatter_glLinkProgramARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgramARB, "(%u)", (unsigned int)programObj)
    glatter_glLinkProgramARB(programObj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLinkProgramARB_defined
#endif
#ifndef glShaderSourceARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderSourceARB, (shaderObj, count, string, length), (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length))
GLATTER_INLINE_OR_NOT void glatter_glShaderSourceARB_debug(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSourceARB, "(%u, %d, %p, %p)", (unsigned int)shaderObj, (int)count, (void*)string, (void*)length)
    glatter_glShaderSourceARB(shaderObj, count, string, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderSourceARB_defined
#endif
#ifndef glUniform1fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1fARB, (location, v0), (GLint location, GLfloat v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1fARB_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fARB, "(%d, %f)", (int)location, (float)v0)
    glatter_glUniform1fARB(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1fARB_defined
#endif
#ifndef glUniform1fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fvARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1fvARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1fvARB_defined
#endif
#ifndef glUniform1iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1iARB, (location, v0), (GLint location, GLint v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1iARB_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iARB, "(%d, %d)", (int)location, (int)v0)
    glatter_glUniform1iARB(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1iARB_defined
#endif
#ifndef glUniform1ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ivARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1ivARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ivARB_defined
#endif
#ifndef glUniform2fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2fARB, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2fARB_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fARB, "(%d, %f, %f)", (int)location, (float)v0, (float)v1)
    glatter_glUniform2fARB(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2fARB_defined
#endif
#ifndef glUniform2fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fvARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2fvARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2fvARB_defined
#endif
#ifndef glUniform2iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2iARB, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2iARB_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iARB, "(%d, %d, %d)", (int)location, (int)v0, (int)v1)
    glatter_glUniform2iARB(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2iARB_defined
#endif
#ifndef glUniform2ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ivARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2ivARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ivARB_defined
#endif
#ifndef glUniform3fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3fARB, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3fARB_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fARB, "(%d, %f, %f, %f)", (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3fARB(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3fARB_defined
#endif
#ifndef glUniform3fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fvARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3fvARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3fvARB_defined
#endif
#ifndef glUniform3iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3iARB, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3iARB_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iARB, "(%d, %d, %d, %d)", (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3iARB(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3iARB_defined
#endif
#ifndef glUniform3ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ivARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3ivARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ivARB_defined
#endif
#ifndef glUniform4fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4fARB, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4fARB_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fARB, "(%d, %f, %f, %f, %f)", (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4fARB(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4fARB_defined
#endif
#ifndef glUniform4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fvARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4fvARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4fvARB_defined
#endif
#ifndef glUniform4iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4iARB, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4iARB_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iARB, "(%d, %d, %d, %d, %d)", (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4iARB(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4iARB_defined
#endif
#ifndef glUniform4ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ivARB, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4ivARB(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ivARB_defined
#endif
#ifndef glUniformMatrix2fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fvARB, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fvARB(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2fvARB_defined
#endif
#ifndef glUniformMatrix3fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fvARB, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fvARB(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3fvARB_defined
#endif
#ifndef glUniformMatrix4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fvARB, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fvARB(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4fvARB_defined
#endif
#ifndef glUseProgramObjectARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUseProgramObjectARB, (programObj), (GLhandleARB programObj))
GLATTER_INLINE_OR_NOT void glatter_glUseProgramObjectARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramObjectARB, "(%u)", (unsigned int)programObj)
    glatter_glUseProgramObjectARB(programObj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUseProgramObjectARB_defined
#endif
#ifndef glValidateProgramARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glValidateProgramARB, (programObj), (GLhandleARB programObj))
GLATTER_INLINE_OR_NOT void glatter_glValidateProgramARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramARB, "(%u)", (unsigned int)programObj)
    glatter_glValidateProgramARB(programObj);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glValidateProgramARB_defined
#endif
#endif // defined(GL_ARB_shader_objects)
#if defined(GL_ARB_shading_language_include)
#ifndef glCompileShaderIncludeARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompileShaderIncludeARB, (shader, count, path, length), (GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length))
GLATTER_INLINE_OR_NOT void glatter_glCompileShaderIncludeARB_debug(GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShaderIncludeARB, "(%u, %d, %p, %p)", (unsigned int)shader, (int)count, (void*)path, (void*)length)
    glatter_glCompileShaderIncludeARB(shader, count, path, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompileShaderIncludeARB_defined
#endif
#ifndef glDeleteNamedStringARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glDeleteNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteNamedStringARB, "(%d, %p)", (int)namelen, (void*)name)
    glatter_glDeleteNamedStringARB(namelen, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteNamedStringARB_defined
#endif
#ifndef glGetNamedStringARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedStringARB, (namelen, name, bufSize, stringlen, string), (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedStringARB_debug(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringARB, "(%d, %p, %d, %p, %p)", (int)namelen, (void*)name, (int)bufSize, (void*)stringlen, (void*)string)
    glatter_glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedStringARB_defined
#endif
#ifndef glGetNamedStringivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedStringivARB, (namelen, name, pname, params), (GLint namelen, const GLchar *name, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedStringivARB_debug(GLint namelen, const GLchar *name, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringivARB, "(%d, %p, %s, %p)", (int)namelen, (void*)name, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedStringivARB(namelen, name, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedStringivARB_defined
#endif
#ifndef glIsNamedStringARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNamedStringARB, "(%d, %p)", (int)namelen, (void*)name)
    GLboolean rval = glatter_glIsNamedStringARB(namelen, name);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsNamedStringARB_defined
#endif
#ifndef glNamedStringARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedStringARB, (type, namelen, name, stringlen, string), (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string))
GLATTER_INLINE_OR_NOT void glatter_glNamedStringARB_debug(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedStringARB, "(%s, %d, %p, %d, %p)", enum_to_string_GL(type), (int)namelen, (void*)name, (int)stringlen, (void*)string)
    glatter_glNamedStringARB(type, namelen, name, stringlen, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedStringARB_defined
#endif
#endif // defined(GL_ARB_shading_language_include)
#if defined(GL_ARB_sparse_buffer)
#ifndef glBufferPageCommitmentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferPageCommitmentARB, (target, offset, size, commit), (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glBufferPageCommitmentARB_debug(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferPageCommitmentARB, "(%s, %s, %s, %u)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (unsigned char)commit)
    glatter_glBufferPageCommitmentARB(target, offset, size, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferPageCommitmentARB_defined
#endif
#ifndef glNamedBufferPageCommitmentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferPageCommitmentARB, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferPageCommitmentARB_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentARB, "(%u, %s, %s, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferPageCommitmentARB_defined
#endif
#ifndef glNamedBufferPageCommitmentEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferPageCommitmentEXT, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferPageCommitmentEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentEXT, "(%u, %s, %s, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferPageCommitmentEXT_defined
#endif
#endif // defined(GL_ARB_sparse_buffer)
#if defined(GL_ARB_sparse_texture)
#ifndef glTexPageCommitmentARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexPageCommitmentARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glTexPageCommitmentARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexPageCommitmentARB, "(%s, %d, %d, %d, %d, %d, %d, %d, %u)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexPageCommitmentARB_defined
#endif
#endif // defined(GL_ARB_sparse_texture)
#if defined(GL_ARB_texture_buffer_object)
#ifndef glTexBufferARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBufferARB, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTexBufferARB_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferARB, "(%s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferARB(target, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBufferARB_defined
#endif
#endif // defined(GL_ARB_texture_buffer_object)
#if defined(GL_ARB_texture_compression)
#ifndef glCompressedTexImage1DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage1DARB, (target, level, internalformat, width, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage1DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage1DARB, "(%s, %d, %s, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage1DARB_defined
#endif
#ifndef glCompressedTexImage2DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage2DARB, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage2DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2DARB, "(%s, %d, %s, %d, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage2DARB_defined
#endif
#ifndef glCompressedTexImage3DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage3DARB, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage3DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3DARB, "(%s, %d, %s, %d, %d, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage3DARB_defined
#endif
#ifndef glCompressedTexSubImage1DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage1DARB, (target, level, xoffset, width, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage1DARB_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage1DARB, "(%s, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage1DARB_defined
#endif
#ifndef glCompressedTexSubImage2DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage2DARB, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage2DARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2DARB, "(%s, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage2DARB_defined
#endif
#ifndef glCompressedTexSubImage3DARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage3DARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage3DARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3DARB, "(%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage3DARB_defined
#endif
#ifndef glGetCompressedTexImageARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedTexImageARB, (target, level, img), (GLenum target, GLint level, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedTexImageARB_debug(GLenum target, GLint level, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTexImageARB, "(%s, %d, %p)", enum_to_string_GL(target), (int)level, (void*)img)
    glatter_glGetCompressedTexImageARB(target, level, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedTexImageARB_defined
#endif
#endif // defined(GL_ARB_texture_compression)
#if defined(GL_ARB_transpose_matrix)
#ifndef glLoadTransposeMatrixdARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadTransposeMatrixdARB, (m), (const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadTransposeMatrixdARB_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixdARB, "(%p)", (void*)m)
    glatter_glLoadTransposeMatrixdARB(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadTransposeMatrixdARB_defined
#endif
#ifndef glLoadTransposeMatrixfARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadTransposeMatrixfARB, (m), (const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadTransposeMatrixfARB_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixfARB, "(%p)", (void*)m)
    glatter_glLoadTransposeMatrixfARB(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadTransposeMatrixfARB_defined
#endif
#ifndef glMultTransposeMatrixdARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultTransposeMatrixdARB, (m), (const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMultTransposeMatrixdARB_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixdARB, "(%p)", (void*)m)
    glatter_glMultTransposeMatrixdARB(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultTransposeMatrixdARB_defined
#endif
#ifndef glMultTransposeMatrixfARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultTransposeMatrixfARB, (m), (const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMultTransposeMatrixfARB_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixfARB, "(%p)", (void*)m)
    glatter_glMultTransposeMatrixfARB(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultTransposeMatrixfARB_defined
#endif
#endif // defined(GL_ARB_transpose_matrix)
#if defined(GL_ARB_vertex_blend)
#ifndef glVertexBlendARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexBlendARB, (count), (GLint count))
GLATTER_INLINE_OR_NOT void glatter_glVertexBlendARB_debug(GLint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendARB, "(%d)", (int)count)
    glatter_glVertexBlendARB(count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexBlendARB_defined
#endif
#ifndef glWeightPointerARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightPointerARB, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glWeightPointerARB_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPointerARB, "(%d, %s, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glWeightPointerARB(size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightPointerARB_defined
#endif
#ifndef glWeightbvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightbvARB, (size, weights), (GLint size, const GLbyte *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightbvARB_debug(GLint size, const GLbyte *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightbvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightbvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightbvARB_defined
#endif
#ifndef glWeightdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightdvARB, (size, weights), (GLint size, const GLdouble *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightdvARB_debug(GLint size, const GLdouble *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightdvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightdvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightdvARB_defined
#endif
#ifndef glWeightfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightfvARB, (size, weights), (GLint size, const GLfloat *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightfvARB_debug(GLint size, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightfvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightfvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightfvARB_defined
#endif
#ifndef glWeightivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightivARB, (size, weights), (GLint size, const GLint *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightivARB_debug(GLint size, const GLint *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightivARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightivARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightivARB_defined
#endif
#ifndef glWeightsvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightsvARB, (size, weights), (GLint size, const GLshort *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightsvARB_debug(GLint size, const GLshort *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightsvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightsvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightsvARB_defined
#endif
#ifndef glWeightubvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightubvARB, (size, weights), (GLint size, const GLubyte *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightubvARB_debug(GLint size, const GLubyte *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightubvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightubvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightubvARB_defined
#endif
#ifndef glWeightuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightuivARB, (size, weights), (GLint size, const GLuint *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightuivARB_debug(GLint size, const GLuint *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightuivARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightuivARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightuivARB_defined
#endif
#ifndef glWeightusvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightusvARB, (size, weights), (GLint size, const GLushort *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightusvARB_debug(GLint size, const GLushort *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightusvARB, "(%d, %p)", (int)size, (void*)weights)
    glatter_glWeightusvARB(size, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightusvARB_defined
#endif
#endif // defined(GL_ARB_vertex_blend)
#if defined(GL_ARB_vertex_buffer_object)
#ifndef glBindBufferARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferARB, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferARB_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferARB, "(%s, %u)", enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBufferARB(target, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferARB_defined
#endif
#ifndef glBufferDataARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferDataARB, (target, size, data, usage), (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage))
GLATTER_INLINE_OR_NOT void glatter_glBufferDataARB_debug(GLenum target, GLsizeiptrARB size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferDataARB, "(%s, %s, %p, %s)", enum_to_string_GL(target), GET_PRS(size), (void*)data, enum_to_string_GL(usage))
    glatter_glBufferDataARB(target, size, data, usage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferDataARB_defined
#endif
#ifndef glBufferSubDataARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferSubDataARB, (target, offset, size, data), (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glBufferSubDataARB_debug(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubDataARB, "(%s, %s, %s, %p)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glBufferSubDataARB(target, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferSubDataARB_defined
#endif
#ifndef glDeleteBuffersARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteBuffersARB, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteBuffersARB_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffersARB, "(%d, %p)", (int)n, (void*)buffers)
    glatter_glDeleteBuffersARB(n, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteBuffersARB_defined
#endif
#ifndef glGenBuffersARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenBuffersARB, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glGenBuffersARB_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffersARB, "(%d, %p)", (int)n, (void*)buffers)
    glatter_glGenBuffersARB(n, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenBuffersARB_defined
#endif
#ifndef glGetBufferParameterivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferParameterivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferParameterivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameterivARB, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameterivARB(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferParameterivARB_defined
#endif
#ifndef glGetBufferPointervARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferPointervARB, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferPointervARB_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointervARB, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointervARB(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferPointervARB_defined
#endif
#ifndef glGetBufferSubDataARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferSubDataARB, (target, offset, size, data), (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferSubDataARB_debug(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferSubDataARB, "(%s, %s, %s, %p)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glGetBufferSubDataARB(target, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferSubDataARB_defined
#endif
#ifndef glIsBufferARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsBufferARB, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsBufferARB_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBufferARB, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glIsBufferARB(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsBufferARB_defined
#endif
#ifndef glMapBufferARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapBufferARB, (target, access), (GLenum target, GLenum access))
GLATTER_INLINE_OR_NOT void * glatter_glMapBufferARB_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferARB, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBufferARB(target, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapBufferARB_defined
#endif
#ifndef glUnmapBufferARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glUnmapBufferARB, (target), (GLenum target))
GLATTER_INLINE_OR_NOT GLboolean glatter_glUnmapBufferARB_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBufferARB, "(%s)", enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBufferARB(target);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glUnmapBufferARB_defined
#endif
#endif // defined(GL_ARB_vertex_buffer_object)
#if defined(GL_ARB_vertex_program)
#ifndef glDisableVertexAttribArrayARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexAttribArrayARB, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexAttribArrayARB_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArrayARB, "(%u)", (unsigned int)index)
    glatter_glDisableVertexAttribArrayARB(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexAttribArrayARB_defined
#endif
#ifndef glEnableVertexAttribArrayARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexAttribArrayARB, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexAttribArrayARB_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArrayARB, "(%u)", (unsigned int)index)
    glatter_glEnableVertexAttribArrayARB(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexAttribArrayARB_defined
#endif
#ifndef glGetVertexAttribPointervARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribPointervARB, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribPointervARB_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointervARB, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointervARB(index, pname, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribPointervARB_defined
#endif
#ifndef glGetVertexAttribdvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribdvARB, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribdvARB_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdvARB, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdvARB(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribdvARB_defined
#endif
#ifndef glGetVertexAttribfvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribfvARB, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribfvARB_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfvARB, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfvARB(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribfvARB_defined
#endif
#ifndef glGetVertexAttribivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribivARB, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribivARB_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribivARB, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribivARB(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribivARB_defined
#endif
#ifndef glVertexAttrib1dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1dARB, (index, x), (GLuint index, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1dARB_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dARB, "(%u, %f)", (unsigned int)index, (double)x)
    glatter_glVertexAttrib1dARB(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1dARB_defined
#endif
#ifndef glVertexAttrib1dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1dvARB_defined
#endif
#ifndef glVertexAttrib1fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1fARB, (index, x), (GLuint index, GLfloat x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1fARB_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fARB, "(%u, %f)", (unsigned int)index, (float)x)
    glatter_glVertexAttrib1fARB(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1fARB_defined
#endif
#ifndef glVertexAttrib1fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1fvARB_defined
#endif
#ifndef glVertexAttrib1sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1sARB, (index, x), (GLuint index, GLshort x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1sARB_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sARB, "(%u, %hi)", (unsigned int)index, (short)x)
    glatter_glVertexAttrib1sARB(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1sARB_defined
#endif
#ifndef glVertexAttrib1svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1svARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1svARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1svARB_defined
#endif
#ifndef glVertexAttrib2dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2dARB, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2dARB_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dARB, "(%u, %f, %f)", (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2dARB(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2dARB_defined
#endif
#ifndef glVertexAttrib2dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2dvARB_defined
#endif
#ifndef glVertexAttrib2fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2fARB, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2fARB_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fARB, "(%u, %f, %f)", (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2fARB(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2fARB_defined
#endif
#ifndef glVertexAttrib2fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2fvARB_defined
#endif
#ifndef glVertexAttrib2sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2sARB, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2sARB_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sARB, "(%u, %hi, %hi)", (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2sARB(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2sARB_defined
#endif
#ifndef glVertexAttrib2svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2svARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2svARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2svARB_defined
#endif
#ifndef glVertexAttrib3dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3dARB, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3dARB_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dARB, "(%u, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3dARB(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3dARB_defined
#endif
#ifndef glVertexAttrib3dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3dvARB_defined
#endif
#ifndef glVertexAttrib3fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3fARB, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3fARB_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fARB, "(%u, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3fARB(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3fARB_defined
#endif
#ifndef glVertexAttrib3fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3fvARB_defined
#endif
#ifndef glVertexAttrib3sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3sARB, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3sARB_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sARB, "(%u, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3sARB(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3sARB_defined
#endif
#ifndef glVertexAttrib3svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3svARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3svARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3svARB_defined
#endif
#ifndef glVertexAttrib4NbvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NbvARB, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NbvARB_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NbvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NbvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NbvARB_defined
#endif
#ifndef glVertexAttrib4NivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NivARB, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NivARB_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NivARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NivARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NivARB_defined
#endif
#ifndef glVertexAttrib4NsvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NsvARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NsvARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NsvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NsvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NsvARB_defined
#endif
#ifndef glVertexAttrib4NubARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NubARB, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NubARB_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NubARB, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4NubARB(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NubARB_defined
#endif
#ifndef glVertexAttrib4NubvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NubvARB, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NubvARB_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NubvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NubvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NubvARB_defined
#endif
#ifndef glVertexAttrib4NuivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NuivARB, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NuivARB_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NuivARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NuivARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NuivARB_defined
#endif
#ifndef glVertexAttrib4NusvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4NusvARB, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4NusvARB_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NusvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NusvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4NusvARB_defined
#endif
#ifndef glVertexAttrib4bvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4bvARB, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4bvARB_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4bvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4bvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4bvARB_defined
#endif
#ifndef glVertexAttrib4dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4dARB, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4dARB_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dARB, "(%u, %f, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4dARB(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4dARB_defined
#endif
#ifndef glVertexAttrib4dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4dvARB_defined
#endif
#ifndef glVertexAttrib4fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4fARB, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4fARB_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fARB, "(%u, %f, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4fARB(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4fARB_defined
#endif
#ifndef glVertexAttrib4fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4fvARB_defined
#endif
#ifndef glVertexAttrib4ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4ivARB, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4ivARB_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ivARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ivARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4ivARB_defined
#endif
#ifndef glVertexAttrib4sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4sARB, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4sARB_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sARB, "(%u, %hi, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4sARB(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4sARB_defined
#endif
#ifndef glVertexAttrib4svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4svARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4svARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4svARB_defined
#endif
#ifndef glVertexAttrib4ubvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4ubvARB, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4ubvARB_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4ubvARB_defined
#endif
#ifndef glVertexAttrib4uivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4uivARB, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4uivARB_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4uivARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4uivARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4uivARB_defined
#endif
#ifndef glVertexAttrib4usvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4usvARB, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4usvARB_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4usvARB, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4usvARB(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4usvARB_defined
#endif
#ifndef glVertexAttribPointerARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribPointerARB, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribPointerARB_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointerARB, "(%u, %d, %s, %u, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribPointerARB_defined
#endif
#endif // defined(GL_ARB_vertex_program)
#if defined(GL_ARB_vertex_shader)
#ifndef glBindAttribLocationARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindAttribLocationARB, (programObj, index, name), (GLhandleARB programObj, GLuint index, const GLcharARB *name))
GLATTER_INLINE_OR_NOT void glatter_glBindAttribLocationARB_debug(GLhandleARB programObj, GLuint index, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocationARB, "(%u, %u, %p)", (unsigned int)programObj, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocationARB(programObj, index, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindAttribLocationARB_defined
#endif
#ifndef glGetActiveAttribARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveAttribARB, (programObj, index, maxLength, length, size, type, name), (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveAttribARB_debug(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttribARB, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)programObj, (unsigned int)index, (int)maxLength, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveAttribARB_defined
#endif
#ifndef glGetAttribLocationARB_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetAttribLocationARB, (programObj, name), (GLhandleARB programObj, const GLcharARB *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetAttribLocationARB_debug(GLhandleARB programObj, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocationARB, "(%u, %p)", (unsigned int)programObj, (void*)name)
    GLint rval = glatter_glGetAttribLocationARB(programObj, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetAttribLocationARB_defined
#endif
#endif // defined(GL_ARB_vertex_shader)
#if defined(GL_ARB_viewport_array)
#ifndef glDepthRangeArraydvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangeArraydvNV, (first, count, v), (GLuint first, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangeArraydvNV_debug(GLuint first, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArraydvNV, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArraydvNV(first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangeArraydvNV_defined
#endif
#ifndef glDepthRangeIndexeddNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangeIndexeddNV, (index, n, f), (GLuint index, GLdouble n, GLdouble f))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangeIndexeddNV_debug(GLuint index, GLdouble n, GLdouble f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexeddNV, "(%u, %f, %f)", (unsigned int)index, (double)n, (double)f)
    glatter_glDepthRangeIndexeddNV(index, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangeIndexeddNV_defined
#endif
#endif // defined(GL_ARB_viewport_array)
#if defined(GL_ARB_window_pos)
#ifndef glWindowPos2dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2dARB, (x, y), (GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2dARB_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dARB, "(%f, %f)", (double)x, (double)y)
    glatter_glWindowPos2dARB(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2dARB_defined
#endif
#ifndef glWindowPos2dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2dvARB, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2dvARB_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dvARB, "(%p)", (void*)v)
    glatter_glWindowPos2dvARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2dvARB_defined
#endif
#ifndef glWindowPos2fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2fARB, (x, y), (GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2fARB_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fARB, "(%f, %f)", (float)x, (float)y)
    glatter_glWindowPos2fARB(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2fARB_defined
#endif
#ifndef glWindowPos2fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2fvARB, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2fvARB_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fvARB, "(%p)", (void*)v)
    glatter_glWindowPos2fvARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2fvARB_defined
#endif
#ifndef glWindowPos2iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2iARB, (x, y), (GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2iARB_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iARB, "(%d, %d)", (int)x, (int)y)
    glatter_glWindowPos2iARB(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2iARB_defined
#endif
#ifndef glWindowPos2ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2ivARB, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2ivARB_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2ivARB, "(%p)", (void*)v)
    glatter_glWindowPos2ivARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2ivARB_defined
#endif
#ifndef glWindowPos2sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2sARB, (x, y), (GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2sARB_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sARB, "(%hi, %hi)", (short)x, (short)y)
    glatter_glWindowPos2sARB(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2sARB_defined
#endif
#ifndef glWindowPos2svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2svARB, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2svARB_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2svARB, "(%p)", (void*)v)
    glatter_glWindowPos2svARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2svARB_defined
#endif
#ifndef glWindowPos3dARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3dARB, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3dARB_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dARB, "(%f, %f, %f)", (double)x, (double)y, (double)z)
    glatter_glWindowPos3dARB(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3dARB_defined
#endif
#ifndef glWindowPos3dvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3dvARB, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3dvARB_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dvARB, "(%p)", (void*)v)
    glatter_glWindowPos3dvARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3dvARB_defined
#endif
#ifndef glWindowPos3fARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3fARB, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3fARB_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fARB, "(%f, %f, %f)", (float)x, (float)y, (float)z)
    glatter_glWindowPos3fARB(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3fARB_defined
#endif
#ifndef glWindowPos3fvARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3fvARB, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3fvARB_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fvARB, "(%p)", (void*)v)
    glatter_glWindowPos3fvARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3fvARB_defined
#endif
#ifndef glWindowPos3iARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3iARB, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3iARB_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iARB, "(%d, %d, %d)", (int)x, (int)y, (int)z)
    glatter_glWindowPos3iARB(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3iARB_defined
#endif
#ifndef glWindowPos3ivARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3ivARB, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3ivARB_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3ivARB, "(%p)", (void*)v)
    glatter_glWindowPos3ivARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3ivARB_defined
#endif
#ifndef glWindowPos3sARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3sARB, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3sARB_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sARB, "(%hi, %hi, %hi)", (short)x, (short)y, (short)z)
    glatter_glWindowPos3sARB(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3sARB_defined
#endif
#ifndef glWindowPos3svARB_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3svARB, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3svARB_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3svARB, "(%p)", (void*)v)
    glatter_glWindowPos3svARB(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3svARB_defined
#endif
#endif // defined(GL_ARB_window_pos)
#if defined(GL_ATI_draw_buffers)
#ifndef glDrawBuffersATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawBuffersATI, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_INLINE_OR_NOT void glatter_glDrawBuffersATI_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersATI, "(%d, %p)", (int)n, (void*)bufs)
    glatter_glDrawBuffersATI(n, bufs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawBuffersATI_defined
#endif
#endif // defined(GL_ATI_draw_buffers)
#if defined(GL_ATI_element_array)
#ifndef glDrawElementArrayATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementArrayATI, (mode, count), (GLenum mode, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementArrayATI_debug(GLenum mode, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementArrayATI, "(%s, %d)", enum_to_string_GL(mode), (int)count)
    glatter_glDrawElementArrayATI(mode, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementArrayATI_defined
#endif
#ifndef glDrawRangeElementArrayATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawRangeElementArrayATI, (mode, start, end, count), (GLenum mode, GLuint start, GLuint end, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glDrawRangeElementArrayATI_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementArrayATI, "(%s, %u, %u, %d)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count)
    glatter_glDrawRangeElementArrayATI(mode, start, end, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawRangeElementArrayATI_defined
#endif
#ifndef glElementPointerATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glElementPointerATI, (type, pointer), (GLenum type, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glElementPointerATI_debug(GLenum type, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glElementPointerATI, "(%s, %p)", enum_to_string_GL(type), (void*)pointer)
    glatter_glElementPointerATI(type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glElementPointerATI_defined
#endif
#endif // defined(GL_ATI_element_array)
#if defined(GL_ATI_envmap_bumpmap)
#ifndef glGetTexBumpParameterfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexBumpParameterfvATI, (pname, param), (GLenum pname, GLfloat *param))
GLATTER_INLINE_OR_NOT void glatter_glGetTexBumpParameterfvATI_debug(GLenum pname, GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexBumpParameterfvATI, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glGetTexBumpParameterfvATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexBumpParameterfvATI_defined
#endif
#ifndef glGetTexBumpParameterivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexBumpParameterivATI, (pname, param), (GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetTexBumpParameterivATI_debug(GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexBumpParameterivATI, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glGetTexBumpParameterivATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexBumpParameterivATI_defined
#endif
#ifndef glTexBumpParameterfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBumpParameterfvATI, (pname, param), (GLenum pname, const GLfloat *param))
GLATTER_INLINE_OR_NOT void glatter_glTexBumpParameterfvATI_debug(GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBumpParameterfvATI, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glTexBumpParameterfvATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBumpParameterfvATI_defined
#endif
#ifndef glTexBumpParameterivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBumpParameterivATI, (pname, param), (GLenum pname, const GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glTexBumpParameterivATI_debug(GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBumpParameterivATI, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glTexBumpParameterivATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBumpParameterivATI_defined
#endif
#endif // defined(GL_ATI_envmap_bumpmap)
#if defined(GL_ATI_fragment_shader)
#ifndef glAlphaFragmentOp1ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAlphaFragmentOp1ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod))
GLATTER_INLINE_OR_NOT void glatter_glAlphaFragmentOp1ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp1ATI, "(%s, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod)
    glatter_glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAlphaFragmentOp1ATI_defined
#endif
#ifndef glAlphaFragmentOp2ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAlphaFragmentOp2ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod))
GLATTER_INLINE_OR_NOT void glatter_glAlphaFragmentOp2ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp2ATI, "(%s, %u, %u, %u, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod)
    glatter_glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAlphaFragmentOp2ATI_defined
#endif
#ifndef glAlphaFragmentOp3ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAlphaFragmentOp3ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod))
GLATTER_INLINE_OR_NOT void glatter_glAlphaFragmentOp3ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp3ATI, "(%s, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod, (unsigned int)arg3, (unsigned int)arg3Rep, (unsigned int)arg3Mod)
    glatter_glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAlphaFragmentOp3ATI_defined
#endif
#ifndef glBeginFragmentShaderATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginFragmentShaderATI, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glBeginFragmentShaderATI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginFragmentShaderATI, "()")
    glatter_glBeginFragmentShaderATI();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginFragmentShaderATI_defined
#endif
#ifndef glBindFragmentShaderATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFragmentShaderATI, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBindFragmentShaderATI_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragmentShaderATI, "(%u)", (unsigned int)id)
    glatter_glBindFragmentShaderATI(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFragmentShaderATI_defined
#endif
#ifndef glColorFragmentOp1ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorFragmentOp1ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod))
GLATTER_INLINE_OR_NOT void glatter_glColorFragmentOp1ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp1ATI, "(%s, %u, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod)
    glatter_glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorFragmentOp1ATI_defined
#endif
#ifndef glColorFragmentOp2ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorFragmentOp2ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod))
GLATTER_INLINE_OR_NOT void glatter_glColorFragmentOp2ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp2ATI, "(%s, %u, %u, %u, %u, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod)
    glatter_glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorFragmentOp2ATI_defined
#endif
#ifndef glColorFragmentOp3ATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorFragmentOp3ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod))
GLATTER_INLINE_OR_NOT void glatter_glColorFragmentOp3ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp3ATI, "(%s, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod, (unsigned int)arg3, (unsigned int)arg3Rep, (unsigned int)arg3Mod)
    glatter_glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorFragmentOp3ATI_defined
#endif
#ifndef glDeleteFragmentShaderATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteFragmentShaderATI, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glDeleteFragmentShaderATI_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFragmentShaderATI, "(%u)", (unsigned int)id)
    glatter_glDeleteFragmentShaderATI(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteFragmentShaderATI_defined
#endif
#ifndef glEndFragmentShaderATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndFragmentShaderATI, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndFragmentShaderATI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndFragmentShaderATI, "()")
    glatter_glEndFragmentShaderATI();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndFragmentShaderATI_defined
#endif
#ifndef glGenFragmentShadersATI_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGenFragmentShadersATI, (range), (GLuint range))
GLATTER_INLINE_OR_NOT GLuint glatter_glGenFragmentShadersATI_debug(GLuint range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFragmentShadersATI, "(%u)", (unsigned int)range)
    GLuint rval = glatter_glGenFragmentShadersATI(range);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGenFragmentShadersATI_defined
#endif
#ifndef glPassTexCoordATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPassTexCoordATI, (dst, coord, swizzle), (GLuint dst, GLuint coord, GLenum swizzle))
GLATTER_INLINE_OR_NOT void glatter_glPassTexCoordATI_debug(GLuint dst, GLuint coord, GLenum swizzle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPassTexCoordATI, "(%u, %u, %s)", (unsigned int)dst, (unsigned int)coord, enum_to_string_GL(swizzle))
    glatter_glPassTexCoordATI(dst, coord, swizzle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPassTexCoordATI_defined
#endif
#ifndef glSampleMapATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleMapATI, (dst, interp, swizzle), (GLuint dst, GLuint interp, GLenum swizzle))
GLATTER_INLINE_OR_NOT void glatter_glSampleMapATI_debug(GLuint dst, GLuint interp, GLenum swizzle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMapATI, "(%u, %u, %s)", (unsigned int)dst, (unsigned int)interp, enum_to_string_GL(swizzle))
    glatter_glSampleMapATI(dst, interp, swizzle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleMapATI_defined
#endif
#ifndef glSetFragmentShaderConstantATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetFragmentShaderConstantATI, (dst, value), (GLuint dst, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glSetFragmentShaderConstantATI_debug(GLuint dst, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFragmentShaderConstantATI, "(%u, %p)", (unsigned int)dst, (void*)value)
    glatter_glSetFragmentShaderConstantATI(dst, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetFragmentShaderConstantATI_defined
#endif
#endif // defined(GL_ATI_fragment_shader)
#if defined(GL_ATI_map_object_buffer)
#ifndef glMapObjectBufferATI_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT void * glatter_glMapObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapObjectBufferATI, "(%u)", (unsigned int)buffer)
    void * rval = glatter_glMapObjectBufferATI(buffer);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapObjectBufferATI_defined
#endif
#ifndef glUnmapObjectBufferATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUnmapObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glUnmapObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapObjectBufferATI, "(%u)", (unsigned int)buffer)
    glatter_glUnmapObjectBufferATI(buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUnmapObjectBufferATI_defined
#endif
#endif // defined(GL_ATI_map_object_buffer)
#if defined(GL_ATI_pn_triangles)
#ifndef glPNTrianglesfATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPNTrianglesfATI, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPNTrianglesfATI_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPNTrianglesfATI, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPNTrianglesfATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPNTrianglesfATI_defined
#endif
#ifndef glPNTrianglesiATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPNTrianglesiATI, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glPNTrianglesiATI_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPNTrianglesiATI, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glPNTrianglesiATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPNTrianglesiATI_defined
#endif
#endif // defined(GL_ATI_pn_triangles)
#if defined(GL_ATI_separate_stencil)
#ifndef glStencilFuncSeparateATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilFuncSeparateATI, (frontfunc, backfunc, ref, mask), (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glStencilFuncSeparateATI_debug(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparateATI, "(%s, %s, %d, %u)", enum_to_string_GL(frontfunc), enum_to_string_GL(backfunc), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilFuncSeparateATI_defined
#endif
#ifndef glStencilOpSeparateATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilOpSeparateATI, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
GLATTER_INLINE_OR_NOT void glatter_glStencilOpSeparateATI_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparateATI, "(%s, %s, %s, %s)", enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparateATI(face, sfail, dpfail, dppass);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilOpSeparateATI_defined
#endif
#endif // defined(GL_ATI_separate_stencil)
#if defined(GL_ATI_vertex_array_object)
#ifndef glArrayObjectATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glArrayObjectATI, (array, size, type, stride, buffer, offset), (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset))
GLATTER_INLINE_OR_NOT void glatter_glArrayObjectATI_debug(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glArrayObjectATI, "(%s, %d, %s, %d, %u, %u)", enum_to_string_GL(array), (int)size, enum_to_string_GL(type), (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glArrayObjectATI(array, size, type, stride, buffer, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glArrayObjectATI_defined
#endif
#ifndef glFreeObjectBufferATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFreeObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glFreeObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFreeObjectBufferATI, "(%u)", (unsigned int)buffer)
    glatter_glFreeObjectBufferATI(buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFreeObjectBufferATI_defined
#endif
#ifndef glGetArrayObjectfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetArrayObjectfvATI, (array, pname, params), (GLenum array, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetArrayObjectfvATI_debug(GLenum array, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetArrayObjectfvATI, "(%s, %s, %p)", enum_to_string_GL(array), enum_to_string_GL(pname), (void*)params)
    glatter_glGetArrayObjectfvATI(array, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetArrayObjectfvATI_defined
#endif
#ifndef glGetArrayObjectivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetArrayObjectivATI, (array, pname, params), (GLenum array, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetArrayObjectivATI_debug(GLenum array, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetArrayObjectivATI, "(%s, %s, %p)", enum_to_string_GL(array), enum_to_string_GL(pname), (void*)params)
    glatter_glGetArrayObjectivATI(array, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetArrayObjectivATI_defined
#endif
#ifndef glGetObjectBufferfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectBufferfvATI, (buffer, pname, params), (GLuint buffer, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectBufferfvATI_debug(GLuint buffer, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectBufferfvATI, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectBufferfvATI(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectBufferfvATI_defined
#endif
#ifndef glGetObjectBufferivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectBufferivATI, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectBufferivATI_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectBufferivATI, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectBufferivATI(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectBufferivATI_defined
#endif
#ifndef glGetVariantArrayObjectfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantArrayObjectfvATI, (id, pname, params), (GLuint id, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantArrayObjectfvATI_debug(GLuint id, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantArrayObjectfvATI, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVariantArrayObjectfvATI(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantArrayObjectfvATI_defined
#endif
#ifndef glGetVariantArrayObjectivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantArrayObjectivATI, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantArrayObjectivATI_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantArrayObjectivATI, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVariantArrayObjectivATI(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantArrayObjectivATI_defined
#endif
#ifndef glIsObjectBufferATI_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsObjectBufferATI, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glIsObjectBufferATI(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsObjectBufferATI_defined
#endif
#ifndef glNewObjectBufferATI_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glNewObjectBufferATI, (size, pointer, usage), (GLsizei size, const void *pointer, GLenum usage))
GLATTER_INLINE_OR_NOT GLuint glatter_glNewObjectBufferATI_debug(GLsizei size, const void *pointer, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNewObjectBufferATI, "(%d, %p, %s)", (int)size, (void*)pointer, enum_to_string_GL(usage))
    GLuint rval = glatter_glNewObjectBufferATI(size, pointer, usage);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glNewObjectBufferATI_defined
#endif
#ifndef glUpdateObjectBufferATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUpdateObjectBufferATI, (buffer, offset, size, pointer, preserve), (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve))
GLATTER_INLINE_OR_NOT void glatter_glUpdateObjectBufferATI_debug(GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUpdateObjectBufferATI, "(%u, %u, %d, %p, %s)", (unsigned int)buffer, (unsigned int)offset, (int)size, (void*)pointer, enum_to_string_GL(preserve))
    glatter_glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUpdateObjectBufferATI_defined
#endif
#ifndef glVariantArrayObjectATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantArrayObjectATI, (id, type, stride, buffer, offset), (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset))
GLATTER_INLINE_OR_NOT void glatter_glVariantArrayObjectATI_debug(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantArrayObjectATI, "(%u, %s, %d, %u, %u)", (unsigned int)id, enum_to_string_GL(type), (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glVariantArrayObjectATI(id, type, stride, buffer, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantArrayObjectATI_defined
#endif
#endif // defined(GL_ATI_vertex_array_object)
#if defined(GL_ATI_vertex_attrib_array_object)
#ifndef glGetVertexAttribArrayObjectfvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribArrayObjectfvATI, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribArrayObjectfvATI_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribArrayObjectfvATI, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribArrayObjectfvATI(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribArrayObjectfvATI_defined
#endif
#ifndef glGetVertexAttribArrayObjectivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribArrayObjectivATI, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribArrayObjectivATI_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribArrayObjectivATI, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribArrayObjectivATI(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribArrayObjectivATI_defined
#endif
#ifndef glVertexAttribArrayObjectATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribArrayObjectATI, (index, size, type, normalized, stride, buffer, offset), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribArrayObjectATI_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribArrayObjectATI, "(%u, %d, %s, %u, %d, %u, %u)", (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribArrayObjectATI_defined
#endif
#endif // defined(GL_ATI_vertex_attrib_array_object)
#if defined(GL_ATI_vertex_streams)
#ifndef glClientActiveVertexStreamATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClientActiveVertexStreamATI, (stream), (GLenum stream))
GLATTER_INLINE_OR_NOT void glatter_glClientActiveVertexStreamATI_debug(GLenum stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveVertexStreamATI, "(%s)", enum_to_string_GL(stream))
    glatter_glClientActiveVertexStreamATI(stream);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClientActiveVertexStreamATI_defined
#endif
#ifndef glNormalStream3bATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3bATI, (stream, nx, ny, nz), (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3bATI_debug(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3bATI, "(%s, %d, %d, %d)", enum_to_string_GL(stream), (signed char)nx, (signed char)ny, (signed char)nz)
    glatter_glNormalStream3bATI(stream, nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3bATI_defined
#endif
#ifndef glNormalStream3bvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3bvATI, (stream, coords), (GLenum stream, const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3bvATI_debug(GLenum stream, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3bvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3bvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3bvATI_defined
#endif
#ifndef glNormalStream3dATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3dATI, (stream, nx, ny, nz), (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3dATI_debug(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3dATI, "(%s, %f, %f, %f)", enum_to_string_GL(stream), (double)nx, (double)ny, (double)nz)
    glatter_glNormalStream3dATI(stream, nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3dATI_defined
#endif
#ifndef glNormalStream3dvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3dvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3dvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3dvATI_defined
#endif
#ifndef glNormalStream3fATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3fATI, (stream, nx, ny, nz), (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3fATI_debug(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3fATI, "(%s, %f, %f, %f)", enum_to_string_GL(stream), (float)nx, (float)ny, (float)nz)
    glatter_glNormalStream3fATI(stream, nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3fATI_defined
#endif
#ifndef glNormalStream3fvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3fvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3fvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3fvATI_defined
#endif
#ifndef glNormalStream3iATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3iATI, (stream, nx, ny, nz), (GLenum stream, GLint nx, GLint ny, GLint nz))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3iATI_debug(GLenum stream, GLint nx, GLint ny, GLint nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3iATI, "(%s, %d, %d, %d)", enum_to_string_GL(stream), (int)nx, (int)ny, (int)nz)
    glatter_glNormalStream3iATI(stream, nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3iATI_defined
#endif
#ifndef glNormalStream3ivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3ivATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3ivATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3ivATI_defined
#endif
#ifndef glNormalStream3sATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3sATI, (stream, nx, ny, nz), (GLenum stream, GLshort nx, GLshort ny, GLshort nz))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3sATI_debug(GLenum stream, GLshort nx, GLshort ny, GLshort nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3sATI, "(%s, %hi, %hi, %hi)", enum_to_string_GL(stream), (short)nx, (short)ny, (short)nz)
    glatter_glNormalStream3sATI(stream, nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3sATI_defined
#endif
#ifndef glNormalStream3svATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalStream3svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalStream3svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3svATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3svATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalStream3svATI_defined
#endif
#ifndef glVertexBlendEnvfATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexBlendEnvfATI, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glVertexBlendEnvfATI_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendEnvfATI, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glVertexBlendEnvfATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexBlendEnvfATI_defined
#endif
#ifndef glVertexBlendEnviATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexBlendEnviATI, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glVertexBlendEnviATI_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendEnviATI, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glVertexBlendEnviATI(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexBlendEnviATI_defined
#endif
#ifndef glVertexStream1dATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1dATI, (stream, x), (GLenum stream, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1dATI_debug(GLenum stream, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1dATI, "(%s, %f)", enum_to_string_GL(stream), (double)x)
    glatter_glVertexStream1dATI(stream, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1dATI_defined
#endif
#ifndef glVertexStream1dvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1dvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1dvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1dvATI_defined
#endif
#ifndef glVertexStream1fATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1fATI, (stream, x), (GLenum stream, GLfloat x))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1fATI_debug(GLenum stream, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1fATI, "(%s, %f)", enum_to_string_GL(stream), (float)x)
    glatter_glVertexStream1fATI(stream, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1fATI_defined
#endif
#ifndef glVertexStream1fvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1fvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1fvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1fvATI_defined
#endif
#ifndef glVertexStream1iATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1iATI, (stream, x), (GLenum stream, GLint x))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1iATI_debug(GLenum stream, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1iATI, "(%s, %d)", enum_to_string_GL(stream), (int)x)
    glatter_glVertexStream1iATI(stream, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1iATI_defined
#endif
#ifndef glVertexStream1ivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1ivATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1ivATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1ivATI_defined
#endif
#ifndef glVertexStream1sATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1sATI, (stream, x), (GLenum stream, GLshort x))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1sATI_debug(GLenum stream, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1sATI, "(%s, %hi)", enum_to_string_GL(stream), (short)x)
    glatter_glVertexStream1sATI(stream, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1sATI_defined
#endif
#ifndef glVertexStream1svATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream1svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream1svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1svATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1svATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream1svATI_defined
#endif
#ifndef glVertexStream2dATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2dATI, (stream, x, y), (GLenum stream, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2dATI_debug(GLenum stream, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2dATI, "(%s, %f, %f)", enum_to_string_GL(stream), (double)x, (double)y)
    glatter_glVertexStream2dATI(stream, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2dATI_defined
#endif
#ifndef glVertexStream2dvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2dvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2dvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2dvATI_defined
#endif
#ifndef glVertexStream2fATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2fATI, (stream, x, y), (GLenum stream, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2fATI_debug(GLenum stream, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2fATI, "(%s, %f, %f)", enum_to_string_GL(stream), (float)x, (float)y)
    glatter_glVertexStream2fATI(stream, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2fATI_defined
#endif
#ifndef glVertexStream2fvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2fvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2fvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2fvATI_defined
#endif
#ifndef glVertexStream2iATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2iATI, (stream, x, y), (GLenum stream, GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2iATI_debug(GLenum stream, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2iATI, "(%s, %d, %d)", enum_to_string_GL(stream), (int)x, (int)y)
    glatter_glVertexStream2iATI(stream, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2iATI_defined
#endif
#ifndef glVertexStream2ivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2ivATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2ivATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2ivATI_defined
#endif
#ifndef glVertexStream2sATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2sATI, (stream, x, y), (GLenum stream, GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2sATI_debug(GLenum stream, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2sATI, "(%s, %hi, %hi)", enum_to_string_GL(stream), (short)x, (short)y)
    glatter_glVertexStream2sATI(stream, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2sATI_defined
#endif
#ifndef glVertexStream2svATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream2svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream2svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2svATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2svATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream2svATI_defined
#endif
#ifndef glVertexStream3dATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3dATI, (stream, x, y, z), (GLenum stream, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3dATI_debug(GLenum stream, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3dATI, "(%s, %f, %f, %f)", enum_to_string_GL(stream), (double)x, (double)y, (double)z)
    glatter_glVertexStream3dATI(stream, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3dATI_defined
#endif
#ifndef glVertexStream3dvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3dvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3dvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3dvATI_defined
#endif
#ifndef glVertexStream3fATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3fATI, (stream, x, y, z), (GLenum stream, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3fATI_debug(GLenum stream, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3fATI, "(%s, %f, %f, %f)", enum_to_string_GL(stream), (float)x, (float)y, (float)z)
    glatter_glVertexStream3fATI(stream, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3fATI_defined
#endif
#ifndef glVertexStream3fvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3fvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3fvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3fvATI_defined
#endif
#ifndef glVertexStream3iATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3iATI, (stream, x, y, z), (GLenum stream, GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3iATI_debug(GLenum stream, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3iATI, "(%s, %d, %d, %d)", enum_to_string_GL(stream), (int)x, (int)y, (int)z)
    glatter_glVertexStream3iATI(stream, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3iATI_defined
#endif
#ifndef glVertexStream3ivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3ivATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3ivATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3ivATI_defined
#endif
#ifndef glVertexStream3sATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3sATI, (stream, x, y, z), (GLenum stream, GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3sATI_debug(GLenum stream, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3sATI, "(%s, %hi, %hi, %hi)", enum_to_string_GL(stream), (short)x, (short)y, (short)z)
    glatter_glVertexStream3sATI(stream, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3sATI_defined
#endif
#ifndef glVertexStream3svATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream3svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream3svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3svATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3svATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream3svATI_defined
#endif
#ifndef glVertexStream4dATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4dATI, (stream, x, y, z, w), (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4dATI_debug(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4dATI, "(%s, %f, %f, %f, %f)", enum_to_string_GL(stream), (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexStream4dATI(stream, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4dATI_defined
#endif
#ifndef glVertexStream4dvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4dvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4dvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4dvATI_defined
#endif
#ifndef glVertexStream4fATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4fATI, (stream, x, y, z, w), (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4fATI_debug(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4fATI, "(%s, %f, %f, %f, %f)", enum_to_string_GL(stream), (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexStream4fATI(stream, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4fATI_defined
#endif
#ifndef glVertexStream4fvATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4fvATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4fvATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4fvATI_defined
#endif
#ifndef glVertexStream4iATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4iATI, (stream, x, y, z, w), (GLenum stream, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4iATI_debug(GLenum stream, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4iATI, "(%s, %d, %d, %d, %d)", enum_to_string_GL(stream), (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexStream4iATI(stream, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4iATI_defined
#endif
#ifndef glVertexStream4ivATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4ivATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4ivATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4ivATI_defined
#endif
#ifndef glVertexStream4sATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4sATI, (stream, x, y, z, w), (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4sATI_debug(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4sATI, "(%s, %hi, %hi, %hi, %hi)", enum_to_string_GL(stream), (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexStream4sATI(stream, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4sATI_defined
#endif
#ifndef glVertexStream4svATI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexStream4svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertexStream4svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4svATI, "(%s, %p)", enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4svATI(stream, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexStream4svATI_defined
#endif
#endif // defined(GL_ATI_vertex_streams)
#if defined(GL_EXT_EGL_image_storage)
#ifndef glEGLImageTargetTexStorageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEGLImageTargetTexStorageEXT, (target, image, attrib_list), (GLenum target, GLeglImageOES image, const GLint* attrib_list))
GLATTER_INLINE_OR_NOT void glatter_glEGLImageTargetTexStorageEXT_debug(GLenum target, GLeglImageOES image, const GLint* attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEGLImageTargetTexStorageEXT, "(%s, %p, %p)", enum_to_string_GL(target), (void*)image, (void*)attrib_list)
    glatter_glEGLImageTargetTexStorageEXT(target, image, attrib_list);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEGLImageTargetTexStorageEXT_defined
#endif
#ifndef glEGLImageTargetTextureStorageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEGLImageTargetTextureStorageEXT, (texture, image, attrib_list), (GLuint texture, GLeglImageOES image, const GLint* attrib_list))
GLATTER_INLINE_OR_NOT void glatter_glEGLImageTargetTextureStorageEXT_debug(GLuint texture, GLeglImageOES image, const GLint* attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEGLImageTargetTextureStorageEXT, "(%u, %p, %p)", (unsigned int)texture, (void*)image, (void*)attrib_list)
    glatter_glEGLImageTargetTextureStorageEXT(texture, image, attrib_list);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEGLImageTargetTextureStorageEXT_defined
#endif
#endif // defined(GL_EXT_EGL_image_storage)
#if defined(GL_EXT_bindable_uniform)
#ifndef glGetUniformBufferSizeEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetUniformBufferSizeEXT, (program, location), (GLuint program, GLint location))
GLATTER_INLINE_OR_NOT GLint glatter_glGetUniformBufferSizeEXT_debug(GLuint program, GLint location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBufferSizeEXT, "(%u, %d)", (unsigned int)program, (int)location)
    GLint rval = glatter_glGetUniformBufferSizeEXT(program, location);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetUniformBufferSizeEXT_defined
#endif
#ifndef glGetUniformOffsetEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLintptr, APIENTRY, glGetUniformOffsetEXT, (program, location), (GLuint program, GLint location))
GLATTER_INLINE_OR_NOT GLintptr glatter_glGetUniformOffsetEXT_debug(GLuint program, GLint location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformOffsetEXT, "(%u, %d)", (unsigned int)program, (int)location)
    GLintptr rval = glatter_glGetUniformOffsetEXT(program, location);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetUniformOffsetEXT_defined
#endif
#ifndef glUniformBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformBufferEXT, (program, location, buffer), (GLuint program, GLint location, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glUniformBufferEXT_debug(GLuint program, GLint location, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBufferEXT, "(%u, %d, %u)", (unsigned int)program, (int)location, (unsigned int)buffer)
    glatter_glUniformBufferEXT(program, location, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformBufferEXT_defined
#endif
#endif // defined(GL_EXT_bindable_uniform)
#if defined(GL_EXT_blend_color)
#ifndef glBlendColorEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendColorEXT, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendColorEXT_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColorEXT, "(%f, %f, %f, %f)", (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColorEXT(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendColorEXT_defined
#endif
#endif // defined(GL_EXT_blend_color)
#if defined(GL_EXT_blend_equation_separate)
#ifndef glBlendEquationSeparateEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationSeparateEXT, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationSeparateEXT_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateEXT, "(%s, %s)", enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateEXT(modeRGB, modeAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationSeparateEXT_defined
#endif
#endif // defined(GL_EXT_blend_equation_separate)
#if defined(GL_EXT_blend_func_separate)
#ifndef glBlendFuncSeparateEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparateEXT, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparateEXT_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateEXT, "(%s, %s, %s, %s)", enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparateEXT_defined
#endif
#endif // defined(GL_EXT_blend_func_separate)
#if defined(GL_EXT_blend_minmax)
#ifndef glBlendEquationEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glBlendEquationEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationEXT_defined
#endif
#endif // defined(GL_EXT_blend_minmax)
#if defined(GL_EXT_color_subtable)
#ifndef glColorSubTableEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorSubTableEXT, (target, start, count, format, type, data), (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glColorSubTableEXT_debug(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorSubTableEXT, "(%s, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)start, (int)count, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glColorSubTableEXT(target, start, count, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorSubTableEXT_defined
#endif
#ifndef glCopyColorSubTableEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyColorSubTableEXT, (target, start, x, y, width), (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyColorSubTableEXT_debug(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorSubTableEXT, "(%s, %d, %d, %d, %d)", enum_to_string_GL(target), (int)start, (int)x, (int)y, (int)width)
    glatter_glCopyColorSubTableEXT(target, start, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyColorSubTableEXT_defined
#endif
#endif // defined(GL_EXT_color_subtable)
#if defined(GL_EXT_compiled_vertex_array)
#ifndef glLockArraysEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLockArraysEXT, (first, count), (GLint first, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glLockArraysEXT_debug(GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLockArraysEXT, "(%d, %d)", (int)first, (int)count)
    glatter_glLockArraysEXT(first, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLockArraysEXT_defined
#endif
#ifndef glUnlockArraysEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUnlockArraysEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glUnlockArraysEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnlockArraysEXT, "()")
    glatter_glUnlockArraysEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUnlockArraysEXT_defined
#endif
#endif // defined(GL_EXT_compiled_vertex_array)
#if defined(GL_EXT_convolution)
#ifndef glConvolutionFilter1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionFilter1DEXT, (target, internalformat, width, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionFilter1DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter1DEXT, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionFilter1DEXT_defined
#endif
#ifndef glConvolutionFilter2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionFilter2DEXT, (target, internalformat, width, height, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionFilter2DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter2DEXT, "(%s, %s, %d, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionFilter2DEXT_defined
#endif
#ifndef glConvolutionParameterfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterfEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterfEXT_debug(GLenum target, GLenum pname, GLfloat params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfEXT, "(%s, %s, %f)", enum_to_string_GL(target), enum_to_string_GL(pname), (float)params)
    glatter_glConvolutionParameterfEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterfEXT_defined
#endif
#ifndef glConvolutionParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterfvEXT_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterfvEXT_defined
#endif
#ifndef glConvolutionParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameteriEXT, (target, pname, params), (GLenum target, GLenum pname, GLint params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameteriEXT_debug(GLenum target, GLenum pname, GLint params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteriEXT, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)params)
    glatter_glConvolutionParameteriEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameteriEXT_defined
#endif
#ifndef glConvolutionParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterivEXT_defined
#endif
#ifndef glCopyConvolutionFilter1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyConvolutionFilter1DEXT, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyConvolutionFilter1DEXT_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter1DEXT, "(%s, %s, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyConvolutionFilter1DEXT_defined
#endif
#ifndef glCopyConvolutionFilter2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyConvolutionFilter2DEXT, (target, internalformat, x, y, width, height), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyConvolutionFilter2DEXT_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter2DEXT, "(%s, %s, %d, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyConvolutionFilter2DEXT_defined
#endif
#ifndef glGetConvolutionFilterEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionFilterEXT, (target, format, type, image), (GLenum target, GLenum format, GLenum type, void *image))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionFilterEXT_debug(GLenum target, GLenum format, GLenum type, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionFilterEXT, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glGetConvolutionFilterEXT(target, format, type, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionFilterEXT_defined
#endif
#ifndef glGetConvolutionParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionParameterfvEXT_defined
#endif
#ifndef glGetConvolutionParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionParameterivEXT_defined
#endif
#ifndef glGetSeparableFilterEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSeparableFilterEXT, (target, format, type, row, column, span), (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span))
GLATTER_INLINE_OR_NOT void glatter_glGetSeparableFilterEXT_debug(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSeparableFilterEXT, "(%s, %s, %s, %p, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column, (void*)span)
    glatter_glGetSeparableFilterEXT(target, format, type, row, column, span);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSeparableFilterEXT_defined
#endif
#ifndef glSeparableFilter2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSeparableFilter2DEXT, (target, internalformat, width, height, format, type, row, column), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column))
GLATTER_INLINE_OR_NOT void glatter_glSeparableFilter2DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSeparableFilter2DEXT, "(%s, %s, %d, %d, %s, %s, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column)
    glatter_glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSeparableFilter2DEXT_defined
#endif
#endif // defined(GL_EXT_convolution)
#if defined(GL_EXT_coordinate_frame)
#ifndef glBinormal3bEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3bEXT, (bx, by, bz), (GLbyte bx, GLbyte by, GLbyte bz))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3bEXT_debug(GLbyte bx, GLbyte by, GLbyte bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3bEXT, "(%d, %d, %d)", (signed char)bx, (signed char)by, (signed char)bz)
    glatter_glBinormal3bEXT(bx, by, bz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3bEXT_defined
#endif
#ifndef glBinormal3bvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3bvEXT, (v), (const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3bvEXT, "(%p)", (void*)v)
    glatter_glBinormal3bvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3bvEXT_defined
#endif
#ifndef glBinormal3dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3dEXT, (bx, by, bz), (GLdouble bx, GLdouble by, GLdouble bz))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3dEXT_debug(GLdouble bx, GLdouble by, GLdouble bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3dEXT, "(%f, %f, %f)", (double)bx, (double)by, (double)bz)
    glatter_glBinormal3dEXT(bx, by, bz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3dEXT_defined
#endif
#ifndef glBinormal3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3dvEXT, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3dvEXT, "(%p)", (void*)v)
    glatter_glBinormal3dvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3dvEXT_defined
#endif
#ifndef glBinormal3fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3fEXT, (bx, by, bz), (GLfloat bx, GLfloat by, GLfloat bz))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3fEXT_debug(GLfloat bx, GLfloat by, GLfloat bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3fEXT, "(%f, %f, %f)", (float)bx, (float)by, (float)bz)
    glatter_glBinormal3fEXT(bx, by, bz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3fEXT_defined
#endif
#ifndef glBinormal3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3fvEXT, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3fvEXT, "(%p)", (void*)v)
    glatter_glBinormal3fvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3fvEXT_defined
#endif
#ifndef glBinormal3iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3iEXT, (bx, by, bz), (GLint bx, GLint by, GLint bz))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3iEXT_debug(GLint bx, GLint by, GLint bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3iEXT, "(%d, %d, %d)", (int)bx, (int)by, (int)bz)
    glatter_glBinormal3iEXT(bx, by, bz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3iEXT_defined
#endif
#ifndef glBinormal3ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3ivEXT, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3ivEXT, "(%p)", (void*)v)
    glatter_glBinormal3ivEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3ivEXT_defined
#endif
#ifndef glBinormal3sEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3sEXT, (bx, by, bz), (GLshort bx, GLshort by, GLshort bz))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3sEXT_debug(GLshort bx, GLshort by, GLshort bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3sEXT, "(%hi, %hi, %hi)", (short)bx, (short)by, (short)bz)
    glatter_glBinormal3sEXT(bx, by, bz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3sEXT_defined
#endif
#ifndef glBinormal3svEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormal3svEXT, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glBinormal3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3svEXT, "(%p)", (void*)v)
    glatter_glBinormal3svEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormal3svEXT_defined
#endif
#ifndef glBinormalPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBinormalPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glBinormalPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormalPointerEXT, "(%s, %d, %p)", enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glBinormalPointerEXT(type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBinormalPointerEXT_defined
#endif
#ifndef glTangent3bEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3bEXT, (tx, ty, tz), (GLbyte tx, GLbyte ty, GLbyte tz))
GLATTER_INLINE_OR_NOT void glatter_glTangent3bEXT_debug(GLbyte tx, GLbyte ty, GLbyte tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3bEXT, "(%d, %d, %d)", (signed char)tx, (signed char)ty, (signed char)tz)
    glatter_glTangent3bEXT(tx, ty, tz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3bEXT_defined
#endif
#ifndef glTangent3bvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3bvEXT, (v), (const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glTangent3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3bvEXT, "(%p)", (void*)v)
    glatter_glTangent3bvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3bvEXT_defined
#endif
#ifndef glTangent3dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3dEXT, (tx, ty, tz), (GLdouble tx, GLdouble ty, GLdouble tz))
GLATTER_INLINE_OR_NOT void glatter_glTangent3dEXT_debug(GLdouble tx, GLdouble ty, GLdouble tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3dEXT, "(%f, %f, %f)", (double)tx, (double)ty, (double)tz)
    glatter_glTangent3dEXT(tx, ty, tz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3dEXT_defined
#endif
#ifndef glTangent3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3dvEXT, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glTangent3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3dvEXT, "(%p)", (void*)v)
    glatter_glTangent3dvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3dvEXT_defined
#endif
#ifndef glTangent3fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3fEXT, (tx, ty, tz), (GLfloat tx, GLfloat ty, GLfloat tz))
GLATTER_INLINE_OR_NOT void glatter_glTangent3fEXT_debug(GLfloat tx, GLfloat ty, GLfloat tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3fEXT, "(%f, %f, %f)", (float)tx, (float)ty, (float)tz)
    glatter_glTangent3fEXT(tx, ty, tz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3fEXT_defined
#endif
#ifndef glTangent3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3fvEXT, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTangent3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3fvEXT, "(%p)", (void*)v)
    glatter_glTangent3fvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3fvEXT_defined
#endif
#ifndef glTangent3iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3iEXT, (tx, ty, tz), (GLint tx, GLint ty, GLint tz))
GLATTER_INLINE_OR_NOT void glatter_glTangent3iEXT_debug(GLint tx, GLint ty, GLint tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3iEXT, "(%d, %d, %d)", (int)tx, (int)ty, (int)tz)
    glatter_glTangent3iEXT(tx, ty, tz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3iEXT_defined
#endif
#ifndef glTangent3ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3ivEXT, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glTangent3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3ivEXT, "(%p)", (void*)v)
    glatter_glTangent3ivEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3ivEXT_defined
#endif
#ifndef glTangent3sEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3sEXT, (tx, ty, tz), (GLshort tx, GLshort ty, GLshort tz))
GLATTER_INLINE_OR_NOT void glatter_glTangent3sEXT_debug(GLshort tx, GLshort ty, GLshort tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3sEXT, "(%hi, %hi, %hi)", (short)tx, (short)ty, (short)tz)
    glatter_glTangent3sEXT(tx, ty, tz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3sEXT_defined
#endif
#ifndef glTangent3svEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangent3svEXT, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glTangent3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3svEXT, "(%p)", (void*)v)
    glatter_glTangent3svEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangent3svEXT_defined
#endif
#ifndef glTangentPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTangentPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glTangentPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangentPointerEXT, "(%s, %d, %p)", enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glTangentPointerEXT(type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTangentPointerEXT_defined
#endif
#endif // defined(GL_EXT_coordinate_frame)
#if defined(GL_EXT_copy_texture)
#ifndef glCopyTexImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexImage1DEXT, (target, level, internalformat, x, y, width, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexImage1DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage1DEXT, "(%s, %d, %s, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexImage1DEXT_defined
#endif
#ifndef glCopyTexImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexImage2DEXT, (target, level, internalformat, x, y, width, height, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexImage2DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage2DEXT, "(%s, %d, %s, %d, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexImage2DEXT_defined
#endif
#ifndef glCopyTexSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexSubImage1DEXT, (target, level, xoffset, x, y, width), (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexSubImage1DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage1DEXT, "(%s, %d, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexSubImage1DEXT_defined
#endif
#ifndef glCopyTexSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexSubImage2DEXT, (target, level, xoffset, yoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexSubImage2DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage2DEXT, "(%s, %d, %d, %d, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexSubImage2DEXT_defined
#endif
#ifndef glCopyTexSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexSubImage3DEXT, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexSubImage3DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3DEXT, "(%s, %d, %d, %d, %d, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexSubImage3DEXT_defined
#endif
#endif // defined(GL_EXT_copy_texture)
#if defined(GL_EXT_cull_vertex)
#ifndef glCullParameterdvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCullParameterdvEXT, (pname, params), (GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glCullParameterdvEXT_debug(GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullParameterdvEXT, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glCullParameterdvEXT(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCullParameterdvEXT_defined
#endif
#ifndef glCullParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCullParameterfvEXT, (pname, params), (GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glCullParameterfvEXT_debug(GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullParameterfvEXT, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glCullParameterfvEXT(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCullParameterfvEXT_defined
#endif
#endif // defined(GL_EXT_cull_vertex)
#if defined(GL_EXT_debug_label)
#ifndef glGetObjectLabelEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectLabelEXT, (type, object, bufSize, length, label), (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectLabelEXT_debug(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabelEXT, "(%s, %u, %d, %p, %p)", enum_to_string_GL(type), (unsigned int)object, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabelEXT(type, object, bufSize, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectLabelEXT_defined
#endif
#ifndef glLabelObjectEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLabelObjectEXT, (type, object, length, label), (GLenum type, GLuint object, GLsizei length, const GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glLabelObjectEXT_debug(GLenum type, GLuint object, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLabelObjectEXT, "(%s, %u, %d, %p)", enum_to_string_GL(type), (unsigned int)object, (int)length, (void*)label)
    glatter_glLabelObjectEXT(type, object, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLabelObjectEXT_defined
#endif
#endif // defined(GL_EXT_debug_label)
#if defined(GL_EXT_debug_marker)
#ifndef glInsertEventMarkerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInsertEventMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
GLATTER_INLINE_OR_NOT void glatter_glInsertEventMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertEventMarkerEXT, "(%d, %p)", (int)length, (void*)marker)
    glatter_glInsertEventMarkerEXT(length, marker);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInsertEventMarkerEXT_defined
#endif
#ifndef glPopGroupMarkerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPopGroupMarkerEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glPopGroupMarkerEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopGroupMarkerEXT, "()")
    glatter_glPopGroupMarkerEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPopGroupMarkerEXT_defined
#endif
#ifndef glPushGroupMarkerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPushGroupMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
GLATTER_INLINE_OR_NOT void glatter_glPushGroupMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushGroupMarkerEXT, "(%d, %p)", (int)length, (void*)marker)
    glatter_glPushGroupMarkerEXT(length, marker);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPushGroupMarkerEXT_defined
#endif
#endif // defined(GL_EXT_debug_marker)
#if defined(GL_EXT_depth_bounds_test)
#ifndef glDepthBoundsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthBoundsEXT, (zmin, zmax), (GLclampd zmin, GLclampd zmax))
GLATTER_INLINE_OR_NOT void glatter_glDepthBoundsEXT_debug(GLclampd zmin, GLclampd zmax, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthBoundsEXT, "(%f, %f)", (double)zmin, (double)zmax)
    glatter_glDepthBoundsEXT(zmin, zmax);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthBoundsEXT_defined
#endif
#endif // defined(GL_EXT_depth_bounds_test)
#if defined(GL_EXT_direct_state_access)
#ifndef glBindMultiTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindMultiTextureEXT, (texunit, target, texture), (GLenum texunit, GLenum target, GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glBindMultiTextureEXT_debug(GLenum texunit, GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindMultiTextureEXT, "(%s, %s, %u)", enum_to_string_GL(texunit), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindMultiTextureEXT(texunit, target, texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindMultiTextureEXT_defined
#endif
#ifndef glCheckNamedFramebufferStatusEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glCheckNamedFramebufferStatusEXT, (framebuffer, target), (GLuint framebuffer, GLenum target))
GLATTER_INLINE_OR_NOT GLenum glatter_glCheckNamedFramebufferStatusEXT_debug(GLuint framebuffer, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckNamedFramebufferStatusEXT, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(target))
    GLenum rval = glatter_glCheckNamedFramebufferStatusEXT(framebuffer, target);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCheckNamedFramebufferStatusEXT_defined
#endif
#ifndef glClearNamedBufferDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedBufferDataEXT, (buffer, internalformat, format, type, data), (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedBufferDataEXT_debug(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferDataEXT, "(%u, %s, %s, %s, %p)", (unsigned int)buffer, enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedBufferDataEXT_defined
#endif
#ifndef glClearNamedBufferSubDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedBufferSubDataEXT, (buffer, internalformat, offset, size, format, type, data), (GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedBufferSubDataEXT_debug(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferSubDataEXT, "(%u, %s, %s, %s, %s, %s, %p)", (unsigned int)buffer, enum_to_string_GL(internalformat), GET_PRS(offset), GET_PRS(size), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedBufferSubDataEXT_defined
#endif
#ifndef glClientAttribDefaultEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClientAttribDefaultEXT, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glClientAttribDefaultEXT_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientAttribDefaultEXT, "(%u)", (unsigned int)mask)
    glatter_glClientAttribDefaultEXT(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClientAttribDefaultEXT_defined
#endif
#ifndef glCompressedMultiTexImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexImage1DEXT, (texunit, target, level, internalformat, width, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage1DEXT, "(%s, %s, %d, %s, %d, %d, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexImage1DEXT_defined
#endif
#ifndef glCompressedMultiTexImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexImage2DEXT, (texunit, target, level, internalformat, width, height, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage2DEXT, "(%s, %s, %d, %s, %d, %d, %d, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexImage2DEXT_defined
#endif
#ifndef glCompressedMultiTexImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexImage3DEXT, (texunit, target, level, internalformat, width, height, depth, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage3DEXT, "(%s, %s, %d, %s, %d, %d, %d, %d, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexImage3DEXT_defined
#endif
#ifndef glCompressedMultiTexSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexSubImage1DEXT, (texunit, target, level, xoffset, width, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage1DEXT, "(%s, %s, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexSubImage1DEXT_defined
#endif
#ifndef glCompressedMultiTexSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage2DEXT, "(%s, %s, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexSubImage2DEXT_defined
#endif
#ifndef glCompressedMultiTexSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage3DEXT, "(%s, %s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedMultiTexSubImage3DEXT_defined
#endif
#ifndef glCompressedTextureImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureImage1DEXT, (texture, target, level, internalformat, width, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage1DEXT, "(%u, %s, %d, %s, %d, %d, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureImage1DEXT_defined
#endif
#ifndef glCompressedTextureImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureImage2DEXT, (texture, target, level, internalformat, width, height, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage2DEXT, "(%u, %s, %d, %s, %d, %d, %d, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureImage2DEXT_defined
#endif
#ifndef glCompressedTextureImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureImage3DEXT, (texture, target, level, internalformat, width, height, depth, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage3DEXT, "(%u, %s, %d, %s, %d, %d, %d, %d, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureImage3DEXT_defined
#endif
#ifndef glCompressedTextureSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage1DEXT, (texture, target, level, xoffset, width, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage1DEXT, "(%u, %s, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage1DEXT_defined
#endif
#ifndef glCompressedTextureSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage2DEXT, "(%u, %s, %d, %d, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage2DEXT_defined
#endif
#ifndef glCompressedTextureSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage3DEXT, "(%u, %s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage3DEXT_defined
#endif
#ifndef glCopyMultiTexImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyMultiTexImage1DEXT, (texunit, target, level, internalformat, x, y, width, border), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexImage1DEXT, "(%s, %s, %d, %s, %d, %d, %d, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyMultiTexImage1DEXT_defined
#endif
#ifndef glCopyMultiTexImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyMultiTexImage2DEXT, (texunit, target, level, internalformat, x, y, width, height, border), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexImage2DEXT, "(%s, %s, %d, %s, %d, %d, %d, %d, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyMultiTexImage2DEXT_defined
#endif
#ifndef glCopyMultiTexSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyMultiTexSubImage1DEXT, (texunit, target, level, xoffset, x, y, width), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage1DEXT, "(%s, %s, %d, %d, %d, %d, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyMultiTexSubImage1DEXT_defined
#endif
#ifndef glCopyMultiTexSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, x, y, width, height), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage2DEXT, "(%s, %s, %d, %d, %d, %d, %d, %d, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyMultiTexSubImage2DEXT_defined
#endif
#ifndef glCopyMultiTexSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage3DEXT, "(%s, %s, %d, %d, %d, %d, %d, %d, %d, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyMultiTexSubImage3DEXT_defined
#endif
#ifndef glCopyTextureImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureImage1DEXT, (texture, target, level, internalformat, x, y, width, border), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureImage1DEXT, "(%u, %s, %d, %s, %d, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureImage1DEXT_defined
#endif
#ifndef glCopyTextureImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureImage2DEXT, (texture, target, level, internalformat, x, y, width, height, border), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureImage2DEXT, "(%u, %s, %d, %s, %d, %d, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureImage2DEXT_defined
#endif
#ifndef glCopyTextureSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage1DEXT, (texture, target, level, xoffset, x, y, width), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage1DEXT, "(%u, %s, %d, %d, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage1DEXT_defined
#endif
#ifndef glCopyTextureSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, x, y, width, height), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage2DEXT, "(%u, %s, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage2DEXT_defined
#endif
#ifndef glCopyTextureSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage3DEXT, "(%u, %s, %d, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage3DEXT_defined
#endif
#ifndef glDisableClientStateIndexedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableClientStateIndexedEXT, (array, index), (GLenum array, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableClientStateIndexedEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableClientStateIndexedEXT, "(%s, %u)", enum_to_string_GL(array), (unsigned int)index)
    glatter_glDisableClientStateIndexedEXT(array, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableClientStateIndexedEXT_defined
#endif
#ifndef glDisableClientStateiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableClientStateiEXT, (array, index), (GLenum array, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableClientStateiEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableClientStateiEXT, "(%s, %u)", enum_to_string_GL(array), (unsigned int)index)
    glatter_glDisableClientStateiEXT(array, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableClientStateiEXT_defined
#endif
#ifndef glDisableIndexedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableIndexedEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisableIndexedEXT(target, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableIndexedEXT_defined
#endif
#ifndef glDisableVertexArrayAttribEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexArrayAttribEXT, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexArrayAttribEXT_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayAttribEXT, "(%u, %u)", (unsigned int)vaobj, (unsigned int)index)
    glatter_glDisableVertexArrayAttribEXT(vaobj, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexArrayAttribEXT_defined
#endif
#ifndef glDisableVertexArrayEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexArrayEXT, (vaobj, array), (GLuint vaobj, GLenum array))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexArrayEXT_debug(GLuint vaobj, GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayEXT, "(%u, %s)", (unsigned int)vaobj, enum_to_string_GL(array))
    glatter_glDisableVertexArrayEXT(vaobj, array);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexArrayEXT_defined
#endif
#ifndef glEnableClientStateIndexedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableClientStateIndexedEXT, (array, index), (GLenum array, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableClientStateIndexedEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableClientStateIndexedEXT, "(%s, %u)", enum_to_string_GL(array), (unsigned int)index)
    glatter_glEnableClientStateIndexedEXT(array, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableClientStateIndexedEXT_defined
#endif
#ifndef glEnableClientStateiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableClientStateiEXT, (array, index), (GLenum array, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableClientStateiEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableClientStateiEXT, "(%s, %u)", enum_to_string_GL(array), (unsigned int)index)
    glatter_glEnableClientStateiEXT(array, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableClientStateiEXT_defined
#endif
#ifndef glEnableIndexedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableIndexedEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnableIndexedEXT(target, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableIndexedEXT_defined
#endif
#ifndef glEnableVertexArrayAttribEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexArrayAttribEXT, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexArrayAttribEXT_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayAttribEXT, "(%u, %u)", (unsigned int)vaobj, (unsigned int)index)
    glatter_glEnableVertexArrayAttribEXT(vaobj, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexArrayAttribEXT_defined
#endif
#ifndef glEnableVertexArrayEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexArrayEXT, (vaobj, array), (GLuint vaobj, GLenum array))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexArrayEXT_debug(GLuint vaobj, GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayEXT, "(%u, %s)", (unsigned int)vaobj, enum_to_string_GL(array))
    glatter_glEnableVertexArrayEXT(vaobj, array);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexArrayEXT_defined
#endif
#ifndef glFlushMappedNamedBufferRangeEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushMappedNamedBufferRangeEXT, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_INLINE_OR_NOT void glatter_glFlushMappedNamedBufferRangeEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedNamedBufferRangeEXT, "(%u, %s, %s)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(length))
    glatter_glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushMappedNamedBufferRangeEXT_defined
#endif
#ifndef glFramebufferDrawBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferDrawBufferEXT, (framebuffer, mode), (GLuint framebuffer, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferDrawBufferEXT_debug(GLuint framebuffer, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferDrawBufferEXT, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(mode))
    glatter_glFramebufferDrawBufferEXT(framebuffer, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferDrawBufferEXT_defined
#endif
#ifndef glFramebufferDrawBuffersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferDrawBuffersEXT, (framebuffer, n, bufs), (GLuint framebuffer, GLsizei n, const GLenum *bufs))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferDrawBuffersEXT_debug(GLuint framebuffer, GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferDrawBuffersEXT, "(%u, %d, %p)", (unsigned int)framebuffer, (int)n, (void*)bufs)
    glatter_glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferDrawBuffersEXT_defined
#endif
#ifndef glFramebufferReadBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferReadBufferEXT, (framebuffer, mode), (GLuint framebuffer, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferReadBufferEXT_debug(GLuint framebuffer, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferReadBufferEXT, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(mode))
    glatter_glFramebufferReadBufferEXT(framebuffer, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferReadBufferEXT_defined
#endif
#ifndef glGenerateMultiTexMipmapEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenerateMultiTexMipmapEXT, (texunit, target), (GLenum texunit, GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glGenerateMultiTexMipmapEXT_debug(GLenum texunit, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMultiTexMipmapEXT, "(%s, %s)", enum_to_string_GL(texunit), enum_to_string_GL(target))
    glatter_glGenerateMultiTexMipmapEXT(texunit, target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenerateMultiTexMipmapEXT_defined
#endif
#ifndef glGenerateTextureMipmapEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenerateTextureMipmapEXT, (texture, target), (GLuint texture, GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glGenerateTextureMipmapEXT_debug(GLuint texture, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateTextureMipmapEXT, "(%u, %s)", (unsigned int)texture, enum_to_string_GL(target))
    glatter_glGenerateTextureMipmapEXT(texture, target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenerateTextureMipmapEXT_defined
#endif
#ifndef glGetBooleanIndexedvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBooleanIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_INLINE_OR_NOT void glatter_glGetBooleanIndexedvEXT_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleanIndexedvEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleanIndexedvEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBooleanIndexedvEXT_defined
#endif
#ifndef glGetCompressedMultiTexImageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedMultiTexImageEXT, (texunit, target, lod, img), (GLenum texunit, GLenum target, GLint lod, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedMultiTexImageEXT_debug(GLenum texunit, GLenum target, GLint lod, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedMultiTexImageEXT, "(%s, %s, %d, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)lod, (void*)img)
    glatter_glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedMultiTexImageEXT_defined
#endif
#ifndef glGetCompressedTextureImageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedTextureImageEXT, (texture, target, lod, img), (GLuint texture, GLenum target, GLint lod, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedTextureImageEXT_debug(GLuint texture, GLenum target, GLint lod, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureImageEXT, "(%u, %s, %d, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)lod, (void*)img)
    glatter_glGetCompressedTextureImageEXT(texture, target, lod, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedTextureImageEXT_defined
#endif
#ifndef glGetDoubleIndexedvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetDoubleIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLdouble *data))
GLATTER_INLINE_OR_NOT void glatter_glGetDoubleIndexedvEXT_debug(GLenum target, GLuint index, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoubleIndexedvEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetDoubleIndexedvEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetDoubleIndexedvEXT_defined
#endif
#ifndef glGetDoublei_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetDoublei_vEXT, (pname, index, params), (GLenum pname, GLuint index, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetDoublei_vEXT_debug(GLenum pname, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublei_vEXT, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetDoublei_vEXT(pname, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetDoublei_vEXT_defined
#endif
#ifndef glGetFloatIndexedvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFloatIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_INLINE_OR_NOT void glatter_glGetFloatIndexedvEXT_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloatIndexedvEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloatIndexedvEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFloatIndexedvEXT_defined
#endif
#ifndef glGetFloati_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFloati_vEXT, (pname, index, params), (GLenum pname, GLuint index, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFloati_vEXT_debug(GLenum pname, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_vEXT, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetFloati_vEXT(pname, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFloati_vEXT_defined
#endif
#ifndef glGetFramebufferParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferParameterivEXT, (framebuffer, pname, params), (GLuint framebuffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferParameterivEXT_debug(GLuint framebuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameterivEXT, "(%u, %s, %p)", (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameterivEXT(framebuffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferParameterivEXT_defined
#endif
#ifndef glGetIntegerIndexedvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetIntegerIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_INLINE_OR_NOT void glatter_glGetIntegerIndexedvEXT_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerIndexedvEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegerIndexedvEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetIntegerIndexedvEXT_defined
#endif
#ifndef glGetMultiTexEnvfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexEnvfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexEnvfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexEnvfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexEnvfvEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexEnvfvEXT_defined
#endif
#ifndef glGetMultiTexEnvivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexEnvivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexEnvivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexEnvivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexEnvivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexEnvivEXT_defined
#endif
#ifndef glGetMultiTexGendvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexGendvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexGendvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGendvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGendvEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexGendvEXT_defined
#endif
#ifndef glGetMultiTexGenfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexGenfvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexGenfvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGenfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGenfvEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexGenfvEXT_defined
#endif
#ifndef glGetMultiTexGenivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexGenivEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexGenivEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGenivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGenivEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexGenivEXT_defined
#endif
#ifndef glGetMultiTexImageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexImageEXT, (texunit, target, level, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexImageEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexImageEXT, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexImageEXT_defined
#endif
#ifndef glGetMultiTexLevelParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexLevelParameterfvEXT, (texunit, target, level, pname, params), (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexLevelParameterfvEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexLevelParameterfvEXT, "(%s, %s, %d, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexLevelParameterfvEXT_defined
#endif
#ifndef glGetMultiTexLevelParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexLevelParameterivEXT, (texunit, target, level, pname, params), (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexLevelParameterivEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexLevelParameterivEXT, "(%s, %s, %d, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexLevelParameterivEXT_defined
#endif
#ifndef glGetMultiTexParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexParameterIivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexParameterIivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterIivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterIivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexParameterIivEXT_defined
#endif
#ifndef glGetMultiTexParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexParameterIuivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexParameterIuivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterIuivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexParameterIuivEXT_defined
#endif
#ifndef glGetMultiTexParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexParameterfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexParameterfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterfvEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexParameterfvEXT_defined
#endif
#ifndef glGetMultiTexParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultiTexParameterivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMultiTexParameterivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultiTexParameterivEXT_defined
#endif
#ifndef glGetNamedBufferParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferParameterivEXT, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferParameterivEXT_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameterivEXT, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameterivEXT(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferParameterivEXT_defined
#endif
#ifndef glGetNamedBufferPointervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferPointervEXT, (buffer, pname, params), (GLuint buffer, GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferPointervEXT_debug(GLuint buffer, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferPointervEXT, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferPointervEXT(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferPointervEXT_defined
#endif
#ifndef glGetNamedBufferSubDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferSubDataEXT, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferSubDataEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferSubDataEXT, "(%u, %s, %s, %p)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glGetNamedBufferSubDataEXT(buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferSubDataEXT_defined
#endif
#ifndef glGetNamedFramebufferAttachmentParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedFramebufferAttachmentParameterivEXT, (framebuffer, attachment, pname, params), (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedFramebufferAttachmentParameterivEXT_debug(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferAttachmentParameterivEXT, "(%u, %s, %s, %p)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedFramebufferAttachmentParameterivEXT_defined
#endif
#ifndef glGetNamedFramebufferParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedFramebufferParameterivEXT, (framebuffer, pname, params), (GLuint framebuffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedFramebufferParameterivEXT_debug(GLuint framebuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameterivEXT, "(%u, %s, %p)", (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedFramebufferParameterivEXT_defined
#endif
#ifndef glGetNamedProgramLocalParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramLocalParameterIivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramLocalParameterIivEXT_debug(GLuint program, GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterIivEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramLocalParameterIivEXT_defined
#endif
#ifndef glGetNamedProgramLocalParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramLocalParameterIuivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramLocalParameterIuivEXT_debug(GLuint program, GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterIuivEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramLocalParameterIuivEXT_defined
#endif
#ifndef glGetNamedProgramLocalParameterdvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramLocalParameterdvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramLocalParameterdvEXT_debug(GLuint program, GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterdvEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramLocalParameterdvEXT_defined
#endif
#ifndef glGetNamedProgramLocalParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramLocalParameterfvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramLocalParameterfvEXT_debug(GLuint program, GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterfvEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramLocalParameterfvEXT_defined
#endif
#ifndef glGetNamedProgramStringEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramStringEXT, (program, target, pname, string), (GLuint program, GLenum target, GLenum pname, void *string))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramStringEXT_debug(GLuint program, GLenum target, GLenum pname, void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramStringEXT, "(%u, %s, %s, %p)", (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)string)
    glatter_glGetNamedProgramStringEXT(program, target, pname, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramStringEXT_defined
#endif
#ifndef glGetNamedProgramivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedProgramivEXT, (program, target, pname, params), (GLuint program, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedProgramivEXT_debug(GLuint program, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramivEXT, "(%u, %s, %s, %p)", (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedProgramivEXT(program, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedProgramivEXT_defined
#endif
#ifndef glGetNamedRenderbufferParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedRenderbufferParameterivEXT, (renderbuffer, pname, params), (GLuint renderbuffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedRenderbufferParameterivEXT_debug(GLuint renderbuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedRenderbufferParameterivEXT, "(%u, %s, %p)", (unsigned int)renderbuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedRenderbufferParameterivEXT_defined
#endif
#ifndef glGetPointerIndexedvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPointerIndexedvEXT, (target, index, data), (GLenum target, GLuint index, void **data))
GLATTER_INLINE_OR_NOT void glatter_glGetPointerIndexedvEXT_debug(GLenum target, GLuint index, void **data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointerIndexedvEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetPointerIndexedvEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPointerIndexedvEXT_defined
#endif
#ifndef glGetPointeri_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPointeri_vEXT, (pname, index, params), (GLenum pname, GLuint index, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetPointeri_vEXT_debug(GLenum pname, GLuint index, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointeri_vEXT, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetPointeri_vEXT(pname, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPointeri_vEXT_defined
#endif
#ifndef glGetTextureImageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureImageEXT, (texture, target, level, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureImageEXT_debug(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureImageEXT, "(%u, %s, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetTextureImageEXT(texture, target, level, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureImageEXT_defined
#endif
#ifndef glGetTextureLevelParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureLevelParameterfvEXT, (texture, target, level, pname, params), (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureLevelParameterfvEXT_debug(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterfvEXT, "(%u, %s, %d, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureLevelParameterfvEXT_defined
#endif
#ifndef glGetTextureLevelParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureLevelParameterivEXT, (texture, target, level, pname, params), (GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureLevelParameterivEXT_debug(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterivEXT, "(%u, %s, %d, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureLevelParameterivEXT_defined
#endif
#ifndef glGetTextureParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterIivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterIivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterIivEXT_defined
#endif
#ifndef glGetTextureParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterIuivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterIuivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIuivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIuivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterIuivEXT_defined
#endif
#ifndef glGetTextureParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterfvEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterfvEXT_debug(GLuint texture, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterfvEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterfvEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterfvEXT_defined
#endif
#ifndef glGetTextureParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterivEXT_defined
#endif
#ifndef glGetVertexArrayIntegeri_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayIntegeri_vEXT, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayIntegeri_vEXT_debug(GLuint vaobj, GLuint index, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIntegeri_vEXT, "(%u, %u, %s, %p)", (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayIntegeri_vEXT_defined
#endif
#ifndef glGetVertexArrayIntegervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayIntegervEXT, (vaobj, pname, param), (GLuint vaobj, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayIntegervEXT_debug(GLuint vaobj, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIntegervEXT, "(%u, %s, %p)", (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIntegervEXT(vaobj, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayIntegervEXT_defined
#endif
#ifndef glGetVertexArrayPointeri_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayPointeri_vEXT, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, void **param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayPointeri_vEXT_debug(GLuint vaobj, GLuint index, GLenum pname, void **param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayPointeri_vEXT, "(%u, %u, %s, %p)", (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayPointeri_vEXT_defined
#endif
#ifndef glGetVertexArrayPointervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayPointervEXT, (vaobj, pname, param), (GLuint vaobj, GLenum pname, void **param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayPointervEXT_debug(GLuint vaobj, GLenum pname, void **param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayPointervEXT, "(%u, %s, %p)", (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayPointervEXT(vaobj, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayPointervEXT_defined
#endif
#ifndef glIsEnabledIndexedEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsEnabledIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsEnabledIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledIndexedEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledIndexedEXT(target, index);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsEnabledIndexedEXT_defined
#endif
#ifndef glMapNamedBufferEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapNamedBufferEXT, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_INLINE_OR_NOT void * glatter_glMapNamedBufferEXT_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferEXT, "(%u, %s)", (unsigned int)buffer, enum_to_string_GL(access))
    void * rval = glatter_glMapNamedBufferEXT(buffer, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapNamedBufferEXT_defined
#endif
#ifndef glMapNamedBufferRangeEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapNamedBufferRangeEXT, (buffer, offset, length, access), (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_INLINE_OR_NOT void * glatter_glMapNamedBufferRangeEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferRangeEXT, "(%u, %s, %s, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(length), (unsigned int)access)
    void * rval = glatter_glMapNamedBufferRangeEXT(buffer, offset, length, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapNamedBufferRangeEXT_defined
#endif
#ifndef glMatrixFrustumEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixFrustumEXT, (mode, left, right, bottom, top, zNear, zFar), (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_INLINE_OR_NOT void glatter_glMatrixFrustumEXT_debug(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixFrustumEXT, "(%s, %f, %f, %f, %f, %f, %f)", enum_to_string_GL(mode), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixFrustumEXT_defined
#endif
#ifndef glMatrixLoadIdentityEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoadIdentityEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoadIdentityEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadIdentityEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glMatrixLoadIdentityEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoadIdentityEXT_defined
#endif
#ifndef glMatrixLoadTransposedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoadTransposedEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoadTransposedEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTransposedEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadTransposedEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoadTransposedEXT_defined
#endif
#ifndef glMatrixLoadTransposefEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoadTransposefEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoadTransposefEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTransposefEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadTransposefEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoadTransposefEXT_defined
#endif
#ifndef glMatrixLoaddEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoaddEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoaddEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoaddEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoaddEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoaddEXT_defined
#endif
#ifndef glMatrixLoadfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoadfEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoadfEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadfEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadfEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoadfEXT_defined
#endif
#ifndef glMatrixMultTransposedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMultTransposedEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMultTransposedEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTransposedEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultTransposedEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMultTransposedEXT_defined
#endif
#ifndef glMatrixMultTransposefEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMultTransposefEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMultTransposefEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTransposefEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultTransposefEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMultTransposefEXT_defined
#endif
#ifndef glMatrixMultdEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMultdEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMultdEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultdEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultdEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMultdEXT_defined
#endif
#ifndef glMatrixMultfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMultfEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMultfEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultfEXT, "(%s, %p)", enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultfEXT(mode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMultfEXT_defined
#endif
#ifndef glMatrixOrthoEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixOrthoEXT, (mode, left, right, bottom, top, zNear, zFar), (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_INLINE_OR_NOT void glatter_glMatrixOrthoEXT_debug(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixOrthoEXT, "(%s, %f, %f, %f, %f, %f, %f)", enum_to_string_GL(mode), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixOrthoEXT_defined
#endif
#ifndef glMatrixPopEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixPopEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glMatrixPopEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixPopEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glMatrixPopEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixPopEXT_defined
#endif
#ifndef glMatrixPushEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixPushEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glMatrixPushEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixPushEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glMatrixPushEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixPushEXT_defined
#endif
#ifndef glMatrixRotatedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixRotatedEXT, (mode, angle, x, y, z), (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixRotatedEXT_debug(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixRotatedEXT, "(%s, %f, %f, %f, %f)", enum_to_string_GL(mode), (double)angle, (double)x, (double)y, (double)z)
    glatter_glMatrixRotatedEXT(mode, angle, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixRotatedEXT_defined
#endif
#ifndef glMatrixRotatefEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixRotatefEXT, (mode, angle, x, y, z), (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixRotatefEXT_debug(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixRotatefEXT, "(%s, %f, %f, %f, %f)", enum_to_string_GL(mode), (float)angle, (float)x, (float)y, (float)z)
    glatter_glMatrixRotatefEXT(mode, angle, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixRotatefEXT_defined
#endif
#ifndef glMatrixScaledEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixScaledEXT, (mode, x, y, z), (GLenum mode, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixScaledEXT_debug(GLenum mode, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixScaledEXT, "(%s, %f, %f, %f)", enum_to_string_GL(mode), (double)x, (double)y, (double)z)
    glatter_glMatrixScaledEXT(mode, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixScaledEXT_defined
#endif
#ifndef glMatrixScalefEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixScalefEXT, (mode, x, y, z), (GLenum mode, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixScalefEXT_debug(GLenum mode, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixScalefEXT, "(%s, %f, %f, %f)", enum_to_string_GL(mode), (float)x, (float)y, (float)z)
    glatter_glMatrixScalefEXT(mode, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixScalefEXT_defined
#endif
#ifndef glMatrixTranslatedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixTranslatedEXT, (mode, x, y, z), (GLenum mode, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixTranslatedEXT_debug(GLenum mode, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixTranslatedEXT, "(%s, %f, %f, %f)", enum_to_string_GL(mode), (double)x, (double)y, (double)z)
    glatter_glMatrixTranslatedEXT(mode, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixTranslatedEXT_defined
#endif
#ifndef glMatrixTranslatefEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixTranslatefEXT, (mode, x, y, z), (GLenum mode, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glMatrixTranslatefEXT_debug(GLenum mode, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixTranslatefEXT, "(%s, %f, %f, %f)", enum_to_string_GL(mode), (float)x, (float)y, (float)z)
    glatter_glMatrixTranslatefEXT(mode, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixTranslatefEXT_defined
#endif
#ifndef glMultiTexBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexBufferEXT, (texunit, target, internalformat, buffer), (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexBufferEXT_debug(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexBufferEXT, "(%s, %s, %s, %u)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glMultiTexBufferEXT(texunit, target, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexBufferEXT_defined
#endif
#ifndef glMultiTexCoordPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordPointerEXT, (texunit, size, type, stride, pointer), (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordPointerEXT_debug(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordPointerEXT, "(%s, %d, %s, %d, %p)", enum_to_string_GL(texunit), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordPointerEXT_defined
#endif
#ifndef glMultiTexEnvfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexEnvfEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexEnvfEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvfEXT, "(%s, %s, %s, %f)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexEnvfEXT(texunit, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexEnvfEXT_defined
#endif
#ifndef glMultiTexEnvfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexEnvfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexEnvfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexEnvfvEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexEnvfvEXT_defined
#endif
#ifndef glMultiTexEnviEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexEnviEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexEnviEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnviEXT, "(%s, %s, %s, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexEnviEXT(texunit, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexEnviEXT_defined
#endif
#ifndef glMultiTexEnvivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexEnvivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexEnvivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexEnvivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexEnvivEXT_defined
#endif
#ifndef glMultiTexGendEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGendEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLdouble param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGendEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLdouble param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGendEXT, "(%s, %s, %s, %f)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (double)param)
    glatter_glMultiTexGendEXT(texunit, coord, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGendEXT_defined
#endif
#ifndef glMultiTexGendvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGendvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGendvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGendvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGendvEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGendvEXT_defined
#endif
#ifndef glMultiTexGenfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGenfEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGenfEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenfEXT, "(%s, %s, %s, %f)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexGenfEXT(texunit, coord, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGenfEXT_defined
#endif
#ifndef glMultiTexGenfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGenfvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGenfvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGenfvEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGenfvEXT_defined
#endif
#ifndef glMultiTexGeniEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGeniEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGeniEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGeniEXT, "(%s, %s, %s, %d)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexGeniEXT(texunit, coord, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGeniEXT_defined
#endif
#ifndef glMultiTexGenivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexGenivEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexGenivEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGenivEXT(texunit, coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexGenivEXT_defined
#endif
#ifndef glMultiTexImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexImage1DEXT, (texunit, target, level, internalformat, width, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage1DEXT, "(%s, %s, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexImage1DEXT_defined
#endif
#ifndef glMultiTexImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexImage2DEXT, (texunit, target, level, internalformat, width, height, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage2DEXT, "(%s, %s, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexImage2DEXT_defined
#endif
#ifndef glMultiTexImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexImage3DEXT, (texunit, target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage3DEXT, "(%s, %s, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexImage3DEXT_defined
#endif
#ifndef glMultiTexParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameterIivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameterIivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterIivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterIivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameterIivEXT_defined
#endif
#ifndef glMultiTexParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameterIuivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameterIuivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterIuivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterIuivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameterIuivEXT_defined
#endif
#ifndef glMultiTexParameterfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameterfEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameterfEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterfEXT, "(%s, %s, %s, %f)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexParameterfEXT(texunit, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameterfEXT_defined
#endif
#ifndef glMultiTexParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameterfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameterfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterfvEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterfvEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameterfvEXT_defined
#endif
#ifndef glMultiTexParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameteriEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameteriEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameteriEXT, "(%s, %s, %s, %d)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexParameteriEXT(texunit, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameteriEXT_defined
#endif
#ifndef glMultiTexParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexParameterivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexParameterivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterivEXT(texunit, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexParameterivEXT_defined
#endif
#ifndef glMultiTexRenderbufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexRenderbufferEXT, (texunit, target, renderbuffer), (GLenum texunit, GLenum target, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexRenderbufferEXT_debug(GLenum texunit, GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexRenderbufferEXT, "(%s, %s, %u)", enum_to_string_GL(texunit), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexRenderbufferEXT_defined
#endif
#ifndef glMultiTexSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexSubImage1DEXT, (texunit, target, level, xoffset, width, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage1DEXT, "(%s, %s, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexSubImage1DEXT_defined
#endif
#ifndef glMultiTexSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage2DEXT, "(%s, %s, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexSubImage2DEXT_defined
#endif
#ifndef glMultiTexSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage3DEXT, "(%s, %s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexSubImage3DEXT_defined
#endif
#ifndef glNamedBufferDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferDataEXT, (buffer, size, data, usage), (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferDataEXT_debug(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferDataEXT, "(%u, %s, %p, %s)", (unsigned int)buffer, GET_PRS(size), (void*)data, enum_to_string_GL(usage))
    glatter_glNamedBufferDataEXT(buffer, size, data, usage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferDataEXT_defined
#endif
#ifndef glNamedBufferStorageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferStorageEXT, (buffer, size, data, flags), (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferStorageEXT_debug(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorageEXT, "(%u, %s, %p, %u)", (unsigned int)buffer, GET_PRS(size), (void*)data, (unsigned int)flags)
    glatter_glNamedBufferStorageEXT(buffer, size, data, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferStorageEXT_defined
#endif
#ifndef glNamedBufferSubDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferSubDataEXT, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferSubDataEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferSubDataEXT, "(%u, %s, %s, %p)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glNamedBufferSubDataEXT(buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferSubDataEXT_defined
#endif
#ifndef glNamedCopyBufferSubDataEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedCopyBufferSubDataEXT, (readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glNamedCopyBufferSubDataEXT_debug(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedCopyBufferSubDataEXT, "(%u, %u, %s, %s, %s)", (unsigned int)readBuffer, (unsigned int)writeBuffer, GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedCopyBufferSubDataEXT_defined
#endif
#ifndef glNamedFramebufferParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferParameteriEXT, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferParameteriEXT_debug(GLuint framebuffer, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferParameteriEXT, "(%u, %s, %d)", (unsigned int)framebuffer, enum_to_string_GL(pname), (int)param)
    glatter_glNamedFramebufferParameteriEXT(framebuffer, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferParameteriEXT_defined
#endif
#ifndef glNamedFramebufferRenderbufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferRenderbufferEXT, (framebuffer, attachment, renderbuffertarget, renderbuffer), (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferRenderbufferEXT_debug(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferRenderbufferEXT, "(%u, %s, %s, %u)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferRenderbufferEXT_defined
#endif
#ifndef glNamedFramebufferTexture1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTexture1DEXT, (framebuffer, attachment, textarget, texture, level), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTexture1DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture1DEXT, "(%u, %s, %s, %u, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTexture1DEXT_defined
#endif
#ifndef glNamedFramebufferTexture2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTexture2DEXT, (framebuffer, attachment, textarget, texture, level), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTexture2DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture2DEXT, "(%u, %s, %s, %u, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTexture2DEXT_defined
#endif
#ifndef glNamedFramebufferTexture3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTexture3DEXT, (framebuffer, attachment, textarget, texture, level, zoffset), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTexture3DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture3DEXT, "(%u, %s, %s, %u, %d, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTexture3DEXT_defined
#endif
#ifndef glNamedFramebufferTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTextureEXT, (framebuffer, attachment, texture, level), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTextureEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureEXT, "(%u, %s, %u, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTextureEXT_defined
#endif
#ifndef glNamedFramebufferTextureFaceEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTextureFaceEXT, (framebuffer, attachment, texture, level, face), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTextureFaceEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureFaceEXT, "(%u, %s, %u, %d, %s)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTextureFaceEXT_defined
#endif
#ifndef glNamedFramebufferTextureLayerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTextureLayerEXT, (framebuffer, attachment, texture, level, layer), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTextureLayerEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureLayerEXT, "(%u, %s, %u, %d, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTextureLayerEXT_defined
#endif
#ifndef glNamedProgramLocalParameter4dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameter4dEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameter4dEXT_debug(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4dEXT, "(%u, %s, %u, %f, %f, %f, %f)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameter4dEXT_defined
#endif
#ifndef glNamedProgramLocalParameter4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameter4dvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameter4dvEXT_debug(GLuint program, GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4dvEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameter4dvEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameter4dvEXT_defined
#endif
#ifndef glNamedProgramLocalParameter4fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameter4fEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameter4fEXT_debug(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4fEXT, "(%u, %s, %u, %f, %f, %f, %f)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameter4fEXT_defined
#endif
#ifndef glNamedProgramLocalParameter4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameter4fvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameter4fvEXT_debug(GLuint program, GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4fvEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameter4fvEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameter4fvEXT_defined
#endif
#ifndef glNamedProgramLocalParameterI4iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameterI4iEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameterI4iEXT_debug(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4iEXT, "(%u, %s, %u, %d, %d, %d, %d)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameterI4iEXT_defined
#endif
#ifndef glNamedProgramLocalParameterI4ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameterI4ivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameterI4ivEXT_debug(GLuint program, GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4ivEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameterI4ivEXT_defined
#endif
#ifndef glNamedProgramLocalParameterI4uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameterI4uiEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameterI4uiEXT_debug(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4uiEXT, "(%u, %s, %u, %u, %u, %u, %u)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameterI4uiEXT_defined
#endif
#ifndef glNamedProgramLocalParameterI4uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameterI4uivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameterI4uivEXT_debug(GLuint program, GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4uivEXT, "(%u, %s, %u, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameterI4uivEXT_defined
#endif
#ifndef glNamedProgramLocalParameters4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParameters4fvEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParameters4fvEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameters4fvEXT, "(%u, %s, %u, %d, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParameters4fvEXT_defined
#endif
#ifndef glNamedProgramLocalParametersI4ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParametersI4ivEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParametersI4ivEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParametersI4ivEXT, "(%u, %s, %u, %d, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParametersI4ivEXT_defined
#endif
#ifndef glNamedProgramLocalParametersI4uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramLocalParametersI4uivEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramLocalParametersI4uivEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParametersI4uivEXT, "(%u, %s, %u, %d, %p)", (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramLocalParametersI4uivEXT_defined
#endif
#ifndef glNamedProgramStringEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedProgramStringEXT, (program, target, format, len, string), (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string))
GLATTER_INLINE_OR_NOT void glatter_glNamedProgramStringEXT_debug(GLuint program, GLenum target, GLenum format, GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramStringEXT, "(%u, %s, %s, %d, %p)", (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(format), (int)len, (void*)string)
    glatter_glNamedProgramStringEXT(program, target, format, len, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedProgramStringEXT_defined
#endif
#ifndef glNamedRenderbufferStorageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorageEXT, (renderbuffer, internalformat, width, height), (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorageEXT_debug(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageEXT, "(%u, %s, %d, %d)", (unsigned int)renderbuffer, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorageEXT_defined
#endif
#ifndef glNamedRenderbufferStorageMultisampleCoverageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorageMultisampleCoverageEXT, (renderbuffer, coverageSamples, colorSamples, internalformat, width, height), (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorageMultisampleCoverageEXT_debug(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisampleCoverageEXT, "(%u, %d, %d, %s, %d, %d)", (unsigned int)renderbuffer, (int)coverageSamples, (int)colorSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorageMultisampleCoverageEXT_defined
#endif
#ifndef glNamedRenderbufferStorageMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorageMultisampleEXT, (renderbuffer, samples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorageMultisampleEXT_debug(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisampleEXT, "(%u, %d, %s, %d, %d)", (unsigned int)renderbuffer, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorageMultisampleEXT_defined
#endif
#ifndef glProgramUniform1dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1dEXT, (program, location, x), (GLuint program, GLint location, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1dEXT_debug(GLuint program, GLint location, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dEXT, "(%u, %d, %f)", (unsigned int)program, (int)location, (double)x)
    glatter_glProgramUniform1dEXT(program, location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1dEXT_defined
#endif
#ifndef glProgramUniform1dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1dvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1dvEXT_defined
#endif
#ifndef glProgramUniform1fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1fEXT, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1fEXT_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fEXT, "(%u, %d, %f)", (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1fEXT(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1fEXT_defined
#endif
#ifndef glProgramUniform1fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1fvEXT_defined
#endif
#ifndef glProgramUniform1iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1iEXT, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1iEXT_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iEXT, "(%u, %d, %d)", (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1iEXT(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1iEXT_defined
#endif
#ifndef glProgramUniform1ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ivEXT_defined
#endif
#ifndef glProgramUniform1uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1uiEXT, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1uiEXT_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiEXT, "(%u, %d, %u)", (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1uiEXT(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1uiEXT_defined
#endif
#ifndef glProgramUniform1uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1uivEXT_defined
#endif
#ifndef glProgramUniform2dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2dEXT, (program, location, x, y), (GLuint program, GLint location, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dEXT, "(%u, %d, %f, %f)", (unsigned int)program, (int)location, (double)x, (double)y)
    glatter_glProgramUniform2dEXT(program, location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2dEXT_defined
#endif
#ifndef glProgramUniform2dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2dvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2dvEXT_defined
#endif
#ifndef glProgramUniform2fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2fEXT, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fEXT, "(%u, %d, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2fEXT(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2fEXT_defined
#endif
#ifndef glProgramUniform2fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2fvEXT_defined
#endif
#ifndef glProgramUniform2iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2iEXT, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iEXT, "(%u, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2iEXT(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2iEXT_defined
#endif
#ifndef glProgramUniform2ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ivEXT_defined
#endif
#ifndef glProgramUniform2uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2uiEXT, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiEXT, "(%u, %d, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2uiEXT(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2uiEXT_defined
#endif
#ifndef glProgramUniform2uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2uivEXT_defined
#endif
#ifndef glProgramUniform3dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3dEXT, (program, location, x, y, z), (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dEXT, "(%u, %d, %f, %f, %f)", (unsigned int)program, (int)location, (double)x, (double)y, (double)z)
    glatter_glProgramUniform3dEXT(program, location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3dEXT_defined
#endif
#ifndef glProgramUniform3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3dvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3dvEXT_defined
#endif
#ifndef glProgramUniform3fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3fEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fEXT, "(%u, %d, %f, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3fEXT(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3fEXT_defined
#endif
#ifndef glProgramUniform3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3fvEXT_defined
#endif
#ifndef glProgramUniform3iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3iEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iEXT, "(%u, %d, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3iEXT(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3iEXT_defined
#endif
#ifndef glProgramUniform3ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ivEXT_defined
#endif
#ifndef glProgramUniform3uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3uiEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiEXT, "(%u, %d, %u, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3uiEXT(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3uiEXT_defined
#endif
#ifndef glProgramUniform3uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3uivEXT_defined
#endif
#ifndef glProgramUniform4dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4dEXT, (program, location, x, y, z, w), (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dEXT, "(%u, %d, %f, %f, %f, %f)", (unsigned int)program, (int)location, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramUniform4dEXT(program, location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4dEXT_defined
#endif
#ifndef glProgramUniform4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4dvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4dvEXT_defined
#endif
#ifndef glProgramUniform4fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4fEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fEXT, "(%u, %d, %f, %f, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4fEXT_defined
#endif
#ifndef glProgramUniform4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fvEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fvEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4fvEXT_defined
#endif
#ifndef glProgramUniform4iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4iEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iEXT, "(%u, %d, %d, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4iEXT_defined
#endif
#ifndef glProgramUniform4ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ivEXT_defined
#endif
#ifndef glProgramUniform4uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4uiEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiEXT, "(%u, %d, %u, %u, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4uiEXT_defined
#endif
#ifndef glProgramUniform4uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uivEXT, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uivEXT(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4uivEXT_defined
#endif
#ifndef glProgramUniformMatrix2dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2dvEXT_defined
#endif
#ifndef glProgramUniformMatrix2fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2fvEXT_defined
#endif
#ifndef glProgramUniformMatrix2x3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x3dvEXT_defined
#endif
#ifndef glProgramUniformMatrix2x3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x3fvEXT_defined
#endif
#ifndef glProgramUniformMatrix2x4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x4dvEXT_defined
#endif
#ifndef glProgramUniformMatrix2x4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x4fvEXT_defined
#endif
#ifndef glProgramUniformMatrix3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3dvEXT_defined
#endif
#ifndef glProgramUniformMatrix3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3fvEXT_defined
#endif
#ifndef glProgramUniformMatrix3x2dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x2dvEXT_defined
#endif
#ifndef glProgramUniformMatrix3x2fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x2fvEXT_defined
#endif
#ifndef glProgramUniformMatrix3x4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x4dvEXT_defined
#endif
#ifndef glProgramUniformMatrix3x4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x4fvEXT_defined
#endif
#ifndef glProgramUniformMatrix4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4dvEXT_defined
#endif
#ifndef glProgramUniformMatrix4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4fvEXT_defined
#endif
#ifndef glProgramUniformMatrix4x2dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x2dvEXT_defined
#endif
#ifndef glProgramUniformMatrix4x2fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x2fvEXT_defined
#endif
#ifndef glProgramUniformMatrix4x3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3dvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x3dvEXT_defined
#endif
#ifndef glProgramUniformMatrix4x3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fvEXT, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x3fvEXT_defined
#endif
#ifndef glPushClientAttribDefaultEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPushClientAttribDefaultEXT, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glPushClientAttribDefaultEXT_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushClientAttribDefaultEXT, "(%u)", (unsigned int)mask)
    glatter_glPushClientAttribDefaultEXT(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPushClientAttribDefaultEXT_defined
#endif
#ifndef glTextureBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBufferEXT, (texture, target, internalformat, buffer), (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTextureBufferEXT_debug(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferEXT, "(%u, %s, %s, %u)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTextureBufferEXT(texture, target, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBufferEXT_defined
#endif
#ifndef glTextureBufferRangeEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBufferRangeEXT, (texture, target, internalformat, buffer, offset, size), (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glTextureBufferRangeEXT_debug(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferRangeEXT, "(%u, %s, %s, %u, %s, %s)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBufferRangeEXT_defined
#endif
#ifndef glTextureImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage1DEXT, (texture, target, level, internalformat, width, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage1DEXT, "(%u, %s, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage1DEXT_defined
#endif
#ifndef glTextureImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage2DEXT, (texture, target, level, internalformat, width, height, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DEXT, "(%u, %s, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage2DEXT_defined
#endif
#ifndef glTextureImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage3DEXT, (texture, target, level, internalformat, width, height, depth, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DEXT, "(%u, %s, %d, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage3DEXT_defined
#endif
#ifndef glTexturePageCommitmentEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexturePageCommitmentEXT, (texture, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glTexturePageCommitmentEXT_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexturePageCommitmentEXT, "(%u, %d, %d, %d, %d, %d, %d, %d, %u)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexturePageCommitmentEXT_defined
#endif
#ifndef glTextureParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterIivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterIivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterIivEXT_defined
#endif
#ifndef glTextureParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterIuivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterIuivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIuivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIuivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterIuivEXT_defined
#endif
#ifndef glTextureParameterfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterfEXT, (texture, target, pname, param), (GLuint texture, GLenum target, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterfEXT_debug(GLuint texture, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfEXT, "(%u, %s, %s, %f)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTextureParameterfEXT(texture, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterfEXT_defined
#endif
#ifndef glTextureParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterfvEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterfvEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfvEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterfvEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterfvEXT_defined
#endif
#ifndef glTextureParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameteriEXT, (texture, target, pname, param), (GLuint texture, GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameteriEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteriEXT, "(%u, %s, %s, %d)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTextureParameteriEXT(texture, target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameteriEXT_defined
#endif
#ifndef glTextureParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterivEXT, "(%u, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterivEXT(texture, target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterivEXT_defined
#endif
#ifndef glTextureRenderbufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureRenderbufferEXT, (texture, target, renderbuffer), (GLuint texture, GLenum target, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glTextureRenderbufferEXT_debug(GLuint texture, GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureRenderbufferEXT, "(%u, %s, %u)", (unsigned int)texture, enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glTextureRenderbufferEXT(texture, target, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureRenderbufferEXT_defined
#endif
#ifndef glTextureStorage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage1DEXT, (texture, target, levels, internalformat, width), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage1DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1DEXT, "(%u, %s, %d, %s, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1DEXT(texture, target, levels, internalformat, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage1DEXT_defined
#endif
#ifndef glTextureStorage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage2DEXT, (texture, target, levels, internalformat, width, height), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage2DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DEXT, "(%u, %s, %d, %s, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage2DEXT_defined
#endif
#ifndef glTextureStorage2DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage2DMultisampleEXT, (texture, target, samples, internalformat, width, height, fixedsamplelocations), (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage2DMultisampleEXT_debug(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DMultisampleEXT, "(%u, %s, %d, %s, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage2DMultisampleEXT_defined
#endif
#ifndef glTextureStorage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage3DEXT, (texture, target, levels, internalformat, width, height, depth), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage3DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DEXT, "(%u, %s, %d, %s, %d, %d, %d)", (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage3DEXT_defined
#endif
#ifndef glTextureStorage3DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage3DMultisampleEXT, (texture, target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage3DMultisampleEXT_debug(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DMultisampleEXT, "(%u, %s, %d, %s, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage3DMultisampleEXT_defined
#endif
#ifndef glTextureSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage1DEXT, (texture, target, level, xoffset, width, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage1DEXT, "(%u, %s, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage1DEXT_defined
#endif
#ifndef glTextureSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, width, height, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage2DEXT, "(%u, %s, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage2DEXT_defined
#endif
#ifndef glTextureSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage3DEXT, "(%u, %s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage3DEXT_defined
#endif
#ifndef glUnmapNamedBufferEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glUnmapNamedBufferEXT, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glUnmapNamedBufferEXT_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapNamedBufferEXT, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glUnmapNamedBufferEXT(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glUnmapNamedBufferEXT_defined
#endif
#ifndef glVertexArrayBindVertexBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayBindVertexBufferEXT, (vaobj, bindingindex, buffer, offset, stride), (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayBindVertexBufferEXT_debug(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayBindVertexBufferEXT, "(%u, %u, %u, %s, %d)", (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)buffer, GET_PRS(offset), (int)stride)
    glatter_glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayBindVertexBufferEXT_defined
#endif
#ifndef glVertexArrayColorOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayColorOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayColorOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayColorOffsetEXT, "(%u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayColorOffsetEXT_defined
#endif
#ifndef glVertexArrayEdgeFlagOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayEdgeFlagOffsetEXT, (vaobj, buffer, stride, offset), (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayEdgeFlagOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayEdgeFlagOffsetEXT, "(%u, %u, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (int)stride, GET_PRS(offset))
    glatter_glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayEdgeFlagOffsetEXT_defined
#endif
#ifndef glVertexArrayFogCoordOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayFogCoordOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayFogCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayFogCoordOffsetEXT, "(%u, %u, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayFogCoordOffsetEXT_defined
#endif
#ifndef glVertexArrayIndexOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayIndexOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayIndexOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayIndexOffsetEXT, "(%u, %u, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayIndexOffsetEXT_defined
#endif
#ifndef glVertexArrayMultiTexCoordOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayMultiTexCoordOffsetEXT, (vaobj, buffer, texunit, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayMultiTexCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayMultiTexCoordOffsetEXT, "(%u, %u, %s, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(texunit), (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayMultiTexCoordOffsetEXT_defined
#endif
#ifndef glVertexArrayNormalOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayNormalOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayNormalOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayNormalOffsetEXT, "(%u, %u, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayNormalOffsetEXT_defined
#endif
#ifndef glVertexArraySecondaryColorOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArraySecondaryColorOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArraySecondaryColorOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArraySecondaryColorOffsetEXT, "(%u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArraySecondaryColorOffsetEXT_defined
#endif
#ifndef glVertexArrayTexCoordOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayTexCoordOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayTexCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayTexCoordOffsetEXT, "(%u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayTexCoordOffsetEXT_defined
#endif
#ifndef glVertexArrayVertexAttribBindingEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribBindingEXT, (vaobj, attribindex, bindingindex), (GLuint vaobj, GLuint attribindex, GLuint bindingindex))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribBindingEXT_debug(GLuint vaobj, GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribBindingEXT, "(%u, %u, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribBindingEXT_defined
#endif
#ifndef glVertexArrayVertexAttribDivisorEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribDivisorEXT, (vaobj, index, divisor), (GLuint vaobj, GLuint index, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribDivisorEXT_debug(GLuint vaobj, GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribDivisorEXT, "(%u, %u, %u)", (unsigned int)vaobj, (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribDivisorEXT_defined
#endif
#ifndef glVertexArrayVertexAttribFormatEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribFormatEXT, (vaobj, attribindex, size, type, normalized, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribFormatEXT, "(%u, %u, %d, %s, %u, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribFormatEXT_defined
#endif
#ifndef glVertexArrayVertexAttribIFormatEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribIFormatEXT, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribIFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribIFormatEXT, "(%u, %u, %d, %s, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribIFormatEXT_defined
#endif
#ifndef glVertexArrayVertexAttribIOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribIOffsetEXT, (vaobj, buffer, index, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribIOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribIOffsetEXT, "(%u, %u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribIOffsetEXT_defined
#endif
#ifndef glVertexArrayVertexAttribLFormatEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribLFormatEXT, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribLFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribLFormatEXT, "(%u, %u, %d, %s, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribLFormatEXT_defined
#endif
#ifndef glVertexArrayVertexAttribLOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribLOffsetEXT, (vaobj, buffer, index, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribLOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribLOffsetEXT, "(%u, %u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribLOffsetEXT_defined
#endif
#ifndef glVertexArrayVertexAttribOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexAttribOffsetEXT, (vaobj, buffer, index, size, type, normalized, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexAttribOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribOffsetEXT, "(%u, %u, %u, %d, %s, %u, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, GET_PRS(offset))
    glatter_glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexAttribOffsetEXT_defined
#endif
#ifndef glVertexArrayVertexBindingDivisorEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexBindingDivisorEXT, (vaobj, bindingindex, divisor), (GLuint vaobj, GLuint bindingindex, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexBindingDivisorEXT_debug(GLuint vaobj, GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBindingDivisorEXT, "(%u, %u, %u)", (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexBindingDivisorEXT_defined
#endif
#ifndef glVertexArrayVertexOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexOffsetEXT, "(%u, %u, %d, %s, %d, %s)", (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, GET_PRS(offset))
    glatter_glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexOffsetEXT_defined
#endif
#endif // defined(GL_EXT_direct_state_access)
#if defined(GL_EXT_draw_buffers2)
#ifndef glColorMaskIndexedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorMaskIndexedEXT, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_INLINE_OR_NOT void glatter_glColorMaskIndexedEXT_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaskIndexedEXT, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaskIndexedEXT(index, r, g, b, a);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorMaskIndexedEXT_defined
#endif
#endif // defined(GL_EXT_draw_buffers2)
#if defined(GL_EXT_draw_instanced)
#ifndef glDrawArraysInstancedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysInstancedEXT, (mode, start, count, primcount), (GLenum mode, GLint start, GLsizei count, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysInstancedEXT_debug(GLenum mode, GLint start, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedEXT, "(%s, %d, %d, %d)", enum_to_string_GL(mode), (int)start, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedEXT(mode, start, count, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysInstancedEXT_defined
#endif
#ifndef glDrawElementsInstancedEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstancedEXT, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstancedEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedEXT, "(%s, %d, %s, %p, %d)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstancedEXT_defined
#endif
#endif // defined(GL_EXT_draw_instanced)
#if defined(GL_EXT_draw_range_elements)
#ifndef glDrawRangeElementsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawRangeElementsEXT, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
GLATTER_INLINE_OR_NOT void glatter_glDrawRangeElementsEXT_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsEXT, "(%s, %u, %u, %d, %s, %p)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElementsEXT(mode, start, end, count, type, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawRangeElementsEXT_defined
#endif
#endif // defined(GL_EXT_draw_range_elements)
#if defined(GL_EXT_external_buffer)
#ifndef glBufferStorageExternalEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferStorageExternalEXT, (target, offset, size, clientBuffer, flags), (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glBufferStorageExternalEXT_debug(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorageExternalEXT, "(%s, %s, %s, %p, %u)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (void*)clientBuffer, (unsigned int)flags)
    glatter_glBufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferStorageExternalEXT_defined
#endif
#ifndef glNamedBufferStorageExternalEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferStorageExternalEXT, (buffer, offset, size, clientBuffer, flags), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferStorageExternalEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorageExternalEXT, "(%u, %s, %s, %p, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)clientBuffer, (unsigned int)flags)
    glatter_glNamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferStorageExternalEXT_defined
#endif
#endif // defined(GL_EXT_external_buffer)
#if defined(GL_EXT_fog_coord)
#ifndef glFogCoordPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointerEXT, "(%s, %d, %p)", enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glFogCoordPointerEXT(type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordPointerEXT_defined
#endif
#ifndef glFogCoorddEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoorddEXT, (coord), (GLdouble coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoorddEXT_debug(GLdouble coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddEXT, "(%f)", (double)coord)
    glatter_glFogCoorddEXT(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoorddEXT_defined
#endif
#ifndef glFogCoorddvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoorddvEXT, (coord), (const GLdouble *coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoorddvEXT_debug(const GLdouble *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddvEXT, "(%p)", (void*)coord)
    glatter_glFogCoorddvEXT(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoorddvEXT_defined
#endif
#ifndef glFogCoordfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordfEXT, (coord), (GLfloat coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordfEXT_debug(GLfloat coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfEXT, "(%f)", (float)coord)
    glatter_glFogCoordfEXT(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordfEXT_defined
#endif
#ifndef glFogCoordfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordfvEXT, (coord), (const GLfloat *coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordfvEXT_debug(const GLfloat *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfvEXT, "(%p)", (void*)coord)
    glatter_glFogCoordfvEXT(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordfvEXT_defined
#endif
#endif // defined(GL_EXT_fog_coord)
#if defined(GL_EXT_framebuffer_blit)
#ifndef glBlitFramebufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlitFramebufferEXT, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glBlitFramebufferEXT_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferEXT, "(%d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlitFramebufferEXT_defined
#endif
#endif // defined(GL_EXT_framebuffer_blit)
#if defined(GL_EXT_framebuffer_blit_layers)
#ifndef glBlitFramebufferLayerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlitFramebufferLayerEXT, (srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glBlitFramebufferLayerEXT_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferLayerEXT, "(%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)srcLayer, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (int)dstLayer, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferLayerEXT(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlitFramebufferLayerEXT_defined
#endif
#ifndef glBlitFramebufferLayersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlitFramebufferLayersEXT, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glBlitFramebufferLayersEXT_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferLayersEXT, "(%d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferLayersEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlitFramebufferLayersEXT_defined
#endif
#endif // defined(GL_EXT_framebuffer_blit_layers)
#if defined(GL_EXT_framebuffer_multisample)
#ifndef glRenderbufferStorageMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorageMultisampleEXT, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorageMultisampleEXT_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleEXT, "(%s, %d, %s, %d, %d)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorageMultisampleEXT_defined
#endif
#endif // defined(GL_EXT_framebuffer_multisample)
#if defined(GL_EXT_framebuffer_object)
#ifndef glBindFramebufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFramebufferEXT, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_INLINE_OR_NOT void glatter_glBindFramebufferEXT_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebufferEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebufferEXT(target, framebuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFramebufferEXT_defined
#endif
#ifndef glBindRenderbufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindRenderbufferEXT, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glBindRenderbufferEXT_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbufferEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbufferEXT(target, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindRenderbufferEXT_defined
#endif
#ifndef glCheckFramebufferStatusEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glCheckFramebufferStatusEXT, (target), (GLenum target))
GLATTER_INLINE_OR_NOT GLenum glatter_glCheckFramebufferStatusEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatusEXT, "(%s)", enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatusEXT(target);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCheckFramebufferStatusEXT_defined
#endif
#ifndef glDeleteFramebuffersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteFramebuffersEXT, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteFramebuffersEXT_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffersEXT, "(%d, %p)", (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffersEXT(n, framebuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteFramebuffersEXT_defined
#endif
#ifndef glDeleteRenderbuffersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteRenderbuffersEXT, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteRenderbuffersEXT_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffersEXT, "(%d, %p)", (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffersEXT(n, renderbuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteRenderbuffersEXT_defined
#endif
#ifndef glFramebufferRenderbufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferRenderbufferEXT, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferRenderbufferEXT_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbufferEXT, "(%s, %s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferRenderbufferEXT_defined
#endif
#ifndef glFramebufferTexture1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture1DEXT, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture1DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture1DEXT, "(%s, %s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture1DEXT_defined
#endif
#ifndef glFramebufferTexture2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture2DEXT, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture2DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2DEXT, "(%s, %s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture2DEXT_defined
#endif
#ifndef glFramebufferTexture3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture3DEXT, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture3DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3DEXT, "(%s, %s, %s, %u, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture3DEXT_defined
#endif
#ifndef glGenFramebuffersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenFramebuffersEXT, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_INLINE_OR_NOT void glatter_glGenFramebuffersEXT_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffersEXT, "(%d, %p)", (int)n, (void*)framebuffers)
    glatter_glGenFramebuffersEXT(n, framebuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenFramebuffersEXT_defined
#endif
#ifndef glGenRenderbuffersEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenRenderbuffersEXT, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_INLINE_OR_NOT void glatter_glGenRenderbuffersEXT_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffersEXT, "(%d, %p)", (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffersEXT(n, renderbuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenRenderbuffersEXT_defined
#endif
#ifndef glGenerateMipmapEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenerateMipmapEXT, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glGenerateMipmapEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmapEXT, "(%s)", enum_to_string_GL(target))
    glatter_glGenerateMipmapEXT(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenerateMipmapEXT_defined
#endif
#ifndef glGetFramebufferAttachmentParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferAttachmentParameterivEXT, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferAttachmentParameterivEXT_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameterivEXT, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferAttachmentParameterivEXT_defined
#endif
#ifndef glGetRenderbufferParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetRenderbufferParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetRenderbufferParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetRenderbufferParameterivEXT_defined
#endif
#ifndef glIsFramebufferEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsFramebufferEXT, (framebuffer), (GLuint framebuffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsFramebufferEXT_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebufferEXT, "(%u)", (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebufferEXT(framebuffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsFramebufferEXT_defined
#endif
#ifndef glIsRenderbufferEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsRenderbufferEXT, (renderbuffer), (GLuint renderbuffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsRenderbufferEXT_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbufferEXT, "(%u)", (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbufferEXT(renderbuffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsRenderbufferEXT_defined
#endif
#ifndef glRenderbufferStorageEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorageEXT, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorageEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageEXT, "(%s, %s, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageEXT(target, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorageEXT_defined
#endif
#endif // defined(GL_EXT_framebuffer_object)
#if defined(GL_EXT_geometry_shader4)
#ifndef glProgramParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameteriEXT, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameteriEXT_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteriEXT, "(%u, %s, %d)", (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteriEXT(program, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameteriEXT_defined
#endif
#endif // defined(GL_EXT_geometry_shader4)
#if defined(GL_EXT_gpu_program_parameters)
#ifndef glProgramEnvParameters4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameters4fvEXT, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameters4fvEXT_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameters4fvEXT, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParameters4fvEXT(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameters4fvEXT_defined
#endif
#ifndef glProgramLocalParameters4fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameters4fvEXT, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameters4fvEXT_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameters4fvEXT, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParameters4fvEXT(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameters4fvEXT_defined
#endif
#endif // defined(GL_EXT_gpu_program_parameters)
#if defined(GL_EXT_gpu_shader4)
#ifndef glBindFragDataLocationEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFragDataLocationEXT, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glBindFragDataLocationEXT_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationEXT, "(%u, %u, %p)", (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocationEXT(program, color, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFragDataLocationEXT_defined
#endif
#ifndef glGetFragDataLocationEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetFragDataLocationEXT, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetFragDataLocationEXT_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocationEXT, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocationEXT(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetFragDataLocationEXT_defined
#endif
#ifndef glGetUniformuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformuivEXT, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformuivEXT_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuivEXT, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuivEXT(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformuivEXT_defined
#endif
#ifndef glGetVertexAttribIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribIivEXT, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribIivEXT_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIivEXT, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIivEXT(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribIivEXT_defined
#endif
#ifndef glGetVertexAttribIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribIuivEXT, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribIuivEXT_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuivEXT, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuivEXT(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribIuivEXT_defined
#endif
#ifndef glUniform1uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1uiEXT, (location, v0), (GLint location, GLuint v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1uiEXT_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiEXT, "(%d, %u)", (int)location, (unsigned int)v0)
    glatter_glUniform1uiEXT(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1uiEXT_defined
#endif
#ifndef glUniform1uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uivEXT, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1uivEXT(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1uivEXT_defined
#endif
#ifndef glUniform2uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2uiEXT, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2uiEXT_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiEXT, "(%d, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2uiEXT(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2uiEXT_defined
#endif
#ifndef glUniform2uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uivEXT, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2uivEXT(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2uivEXT_defined
#endif
#ifndef glUniform3uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3uiEXT, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3uiEXT_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiEXT, "(%d, %u, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3uiEXT(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3uiEXT_defined
#endif
#ifndef glUniform3uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uivEXT, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3uivEXT(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3uivEXT_defined
#endif
#ifndef glUniform4uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4uiEXT, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4uiEXT_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiEXT, "(%d, %u, %u, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4uiEXT(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4uiEXT_defined
#endif
#ifndef glUniform4uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uivEXT, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4uivEXT(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4uivEXT_defined
#endif
#ifndef glVertexAttribI1iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1iEXT, (index, x), (GLuint index, GLint x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1iEXT_debug(GLuint index, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1iEXT, "(%u, %d)", (unsigned int)index, (int)x)
    glatter_glVertexAttribI1iEXT(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1iEXT_defined
#endif
#ifndef glVertexAttribI1ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1ivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1ivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1ivEXT_defined
#endif
#ifndef glVertexAttribI1uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1uiEXT, (index, x), (GLuint index, GLuint x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1uiEXT_debug(GLuint index, GLuint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uiEXT, "(%u, %u)", (unsigned int)index, (unsigned int)x)
    glatter_glVertexAttribI1uiEXT(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1uiEXT_defined
#endif
#ifndef glVertexAttribI1uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1uivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1uivEXT_defined
#endif
#ifndef glVertexAttribI2iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2iEXT, (index, x, y), (GLuint index, GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2iEXT_debug(GLuint index, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2iEXT, "(%u, %d, %d)", (unsigned int)index, (int)x, (int)y)
    glatter_glVertexAttribI2iEXT(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2iEXT_defined
#endif
#ifndef glVertexAttribI2ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2ivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2ivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2ivEXT_defined
#endif
#ifndef glVertexAttribI2uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2uiEXT, (index, x, y), (GLuint index, GLuint x, GLuint y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2uiEXT_debug(GLuint index, GLuint x, GLuint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uiEXT, "(%u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y)
    glatter_glVertexAttribI2uiEXT(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2uiEXT_defined
#endif
#ifndef glVertexAttribI2uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2uivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2uivEXT_defined
#endif
#ifndef glVertexAttribI3iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3iEXT, (index, x, y, z), (GLuint index, GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3iEXT_debug(GLuint index, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3iEXT, "(%u, %d, %d, %d)", (unsigned int)index, (int)x, (int)y, (int)z)
    glatter_glVertexAttribI3iEXT(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3iEXT_defined
#endif
#ifndef glVertexAttribI3ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3ivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3ivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3ivEXT_defined
#endif
#ifndef glVertexAttribI3uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3uiEXT, (index, x, y, z), (GLuint index, GLuint x, GLuint y, GLuint z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3uiEXT_debug(GLuint index, GLuint x, GLuint y, GLuint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uiEXT, "(%u, %u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z)
    glatter_glVertexAttribI3uiEXT(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3uiEXT_defined
#endif
#ifndef glVertexAttribI3uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3uivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3uivEXT_defined
#endif
#ifndef glVertexAttribI4bvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4bvEXT, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4bvEXT_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4bvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4bvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4bvEXT_defined
#endif
#ifndef glVertexAttribI4iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4iEXT, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4iEXT_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iEXT, "(%u, %d, %d, %d, %d)", (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4iEXT(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4iEXT_defined
#endif
#ifndef glVertexAttribI4ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4ivEXT_defined
#endif
#ifndef glVertexAttribI4svEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4svEXT, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4svEXT_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4svEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4svEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4svEXT_defined
#endif
#ifndef glVertexAttribI4ubvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4ubvEXT, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4ubvEXT_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ubvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ubvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4ubvEXT_defined
#endif
#ifndef glVertexAttribI4uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4uiEXT, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4uiEXT_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiEXT, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4uiEXT(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4uiEXT_defined
#endif
#ifndef glVertexAttribI4uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uivEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uivEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4uivEXT_defined
#endif
#ifndef glVertexAttribI4usvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4usvEXT, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4usvEXT_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4usvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4usvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4usvEXT_defined
#endif
#ifndef glVertexAttribIPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribIPointerEXT, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribIPointerEXT_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointerEXT, "(%u, %d, %s, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointerEXT(index, size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribIPointerEXT_defined
#endif
#endif // defined(GL_EXT_gpu_shader4)
#if defined(GL_EXT_histogram)
#ifndef glGetHistogramEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramEXT, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramEXT_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramEXT, "(%s, %u, %s, %s, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetHistogramEXT(target, reset, format, type, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramEXT_defined
#endif
#ifndef glGetHistogramParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramParameterfvEXT_defined
#endif
#ifndef glGetHistogramParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramParameterivEXT_defined
#endif
#ifndef glGetMinmaxEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmaxEXT, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmaxEXT_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxEXT, "(%s, %u, %s, %s, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetMinmaxEXT(target, reset, format, type, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmaxEXT_defined
#endif
#ifndef glGetMinmaxParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmaxParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmaxParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmaxParameterfvEXT_defined
#endif
#ifndef glGetMinmaxParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMinmaxParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMinmaxParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMinmaxParameterivEXT_defined
#endif
#ifndef glHistogramEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glHistogramEXT, (target, width, internalformat, sink), (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink))
GLATTER_INLINE_OR_NOT void glatter_glHistogramEXT_debug(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHistogramEXT, "(%s, %d, %s, %u)", enum_to_string_GL(target), (int)width, enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glHistogramEXT(target, width, internalformat, sink);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glHistogramEXT_defined
#endif
#ifndef glMinmaxEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMinmaxEXT, (target, internalformat, sink), (GLenum target, GLenum internalformat, GLboolean sink))
GLATTER_INLINE_OR_NOT void glatter_glMinmaxEXT_debug(GLenum target, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinmaxEXT, "(%s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glMinmaxEXT(target, internalformat, sink);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMinmaxEXT_defined
#endif
#ifndef glResetHistogramEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResetHistogramEXT, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glResetHistogramEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetHistogramEXT, "(%s)", enum_to_string_GL(target))
    glatter_glResetHistogramEXT(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResetHistogramEXT_defined
#endif
#ifndef glResetMinmaxEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResetMinmaxEXT, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glResetMinmaxEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetMinmaxEXT, "(%s)", enum_to_string_GL(target))
    glatter_glResetMinmaxEXT(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResetMinmaxEXT_defined
#endif
#endif // defined(GL_EXT_histogram)
#if defined(GL_EXT_index_func)
#ifndef glIndexFuncEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexFuncEXT, (func, ref), (GLenum func, GLclampf ref))
GLATTER_INLINE_OR_NOT void glatter_glIndexFuncEXT_debug(GLenum func, GLclampf ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexFuncEXT, "(%s, %f)", enum_to_string_GL(func), (float)ref)
    glatter_glIndexFuncEXT(func, ref);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexFuncEXT_defined
#endif
#endif // defined(GL_EXT_index_func)
#if defined(GL_EXT_index_material)
#ifndef glIndexMaterialEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexMaterialEXT, (face, mode), (GLenum face, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glIndexMaterialEXT_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexMaterialEXT, "(%s, %s)", enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glIndexMaterialEXT(face, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexMaterialEXT_defined
#endif
#endif // defined(GL_EXT_index_material)
#if defined(GL_EXT_light_texture)
#ifndef glApplyTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glApplyTextureEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glApplyTextureEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyTextureEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glApplyTextureEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glApplyTextureEXT_defined
#endif
#ifndef glTextureLightEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureLightEXT, (pname), (GLenum pname))
GLATTER_INLINE_OR_NOT void glatter_glTextureLightEXT_debug(GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureLightEXT, "(%s)", enum_to_string_GL(pname))
    glatter_glTextureLightEXT(pname);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureLightEXT_defined
#endif
#ifndef glTextureMaterialEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureMaterialEXT, (face, mode), (GLenum face, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glTextureMaterialEXT_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureMaterialEXT, "(%s, %s)", enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glTextureMaterialEXT(face, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureMaterialEXT_defined
#endif
#endif // defined(GL_EXT_light_texture)
#if defined(GL_EXT_memory_object)
#ifndef glBufferStorageMemEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferStorageMemEXT, (target, size, memory, offset), (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glBufferStorageMemEXT_debug(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorageMemEXT, "(%s, %s, %u, %s)", enum_to_string_GL(target), GET_PRS(size), (unsigned int)memory, GET_PRS(offset))
    glatter_glBufferStorageMemEXT(target, size, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferStorageMemEXT_defined
#endif
#ifndef glCreateMemoryObjectsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateMemoryObjectsEXT, (n, memoryObjects), (GLsizei n, GLuint *memoryObjects))
GLATTER_INLINE_OR_NOT void glatter_glCreateMemoryObjectsEXT_debug(GLsizei n, GLuint *memoryObjects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateMemoryObjectsEXT, "(%d, %p)", (int)n, (void*)memoryObjects)
    glatter_glCreateMemoryObjectsEXT(n, memoryObjects);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateMemoryObjectsEXT_defined
#endif
#ifndef glDeleteMemoryObjectsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteMemoryObjectsEXT, (n, memoryObjects), (GLsizei n, const GLuint *memoryObjects))
GLATTER_INLINE_OR_NOT void glatter_glDeleteMemoryObjectsEXT_debug(GLsizei n, const GLuint *memoryObjects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteMemoryObjectsEXT, "(%d, %p)", (int)n, (void*)memoryObjects)
    glatter_glDeleteMemoryObjectsEXT(n, memoryObjects);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteMemoryObjectsEXT_defined
#endif
#ifndef glGetMemoryObjectParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMemoryObjectParameterivEXT, (memoryObject, pname, params), (GLuint memoryObject, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMemoryObjectParameterivEXT_debug(GLuint memoryObject, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMemoryObjectParameterivEXT, "(%u, %s, %p)", (unsigned int)memoryObject, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMemoryObjectParameterivEXT(memoryObject, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMemoryObjectParameterivEXT_defined
#endif
#ifndef glGetUnsignedBytei_vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUnsignedBytei_vEXT, (target, index, data), (GLenum target, GLuint index, GLubyte *data))
GLATTER_INLINE_OR_NOT void glatter_glGetUnsignedBytei_vEXT_debug(GLenum target, GLuint index, GLubyte *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUnsignedBytei_vEXT, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetUnsignedBytei_vEXT(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUnsignedBytei_vEXT_defined
#endif
#ifndef glGetUnsignedBytevEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUnsignedBytevEXT, (pname, data), (GLenum pname, GLubyte *data))
GLATTER_INLINE_OR_NOT void glatter_glGetUnsignedBytevEXT_debug(GLenum pname, GLubyte *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUnsignedBytevEXT, "(%s, %p)", enum_to_string_GL(pname), (void*)data)
    glatter_glGetUnsignedBytevEXT(pname, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUnsignedBytevEXT_defined
#endif
#ifndef glIsMemoryObjectEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsMemoryObjectEXT, (memoryObject), (GLuint memoryObject))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsMemoryObjectEXT_debug(GLuint memoryObject, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsMemoryObjectEXT, "(%u)", (unsigned int)memoryObject)
    GLboolean rval = glatter_glIsMemoryObjectEXT(memoryObject);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsMemoryObjectEXT_defined
#endif
#ifndef glMemoryObjectParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMemoryObjectParameterivEXT, (memoryObject, pname, params), (GLuint memoryObject, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMemoryObjectParameterivEXT_debug(GLuint memoryObject, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryObjectParameterivEXT, "(%u, %s, %p)", (unsigned int)memoryObject, enum_to_string_GL(pname), (void*)params)
    glatter_glMemoryObjectParameterivEXT(memoryObject, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMemoryObjectParameterivEXT_defined
#endif
#ifndef glNamedBufferStorageMemEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferStorageMemEXT, (buffer, size, memory, offset), (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferStorageMemEXT_debug(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorageMemEXT, "(%u, %s, %u, %s)", (unsigned int)buffer, GET_PRS(size), (unsigned int)memory, GET_PRS(offset))
    glatter_glNamedBufferStorageMemEXT(buffer, size, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferStorageMemEXT_defined
#endif
#ifndef glTexStorageMem1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageMem1DEXT, (target, levels, internalFormat, width, memory, offset), (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageMem1DEXT_debug(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageMem1DEXT, "(%s, %d, %s, %d, %u, %s)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalFormat), (int)width, (unsigned int)memory, GET_PRS(offset))
    glatter_glTexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageMem1DEXT_defined
#endif
#ifndef glTexStorageMem2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageMem2DEXT, (target, levels, internalFormat, width, height, memory, offset), (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageMem2DEXT_debug(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageMem2DEXT, "(%s, %d, %s, %d, %d, %u, %s)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalFormat), (int)width, (int)height, (unsigned int)memory, GET_PRS(offset))
    glatter_glTexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageMem2DEXT_defined
#endif
#ifndef glTexStorageMem2DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageMem2DMultisampleEXT, (target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset), (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageMem2DMultisampleEXT_debug(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageMem2DMultisampleEXT, "(%s, %d, %s, %d, %d, %u, %u, %s)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalFormat), (int)width, (int)height, (unsigned char)fixedSampleLocations, (unsigned int)memory, GET_PRS(offset))
    glatter_glTexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageMem2DMultisampleEXT_defined
#endif
#ifndef glTexStorageMem3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageMem3DEXT, (target, levels, internalFormat, width, height, depth, memory, offset), (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageMem3DEXT_debug(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageMem3DEXT, "(%s, %d, %s, %d, %d, %d, %u, %s)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (unsigned int)memory, GET_PRS(offset))
    glatter_glTexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageMem3DEXT_defined
#endif
#ifndef glTexStorageMem3DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorageMem3DMultisampleEXT, (target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset), (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexStorageMem3DMultisampleEXT_debug(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageMem3DMultisampleEXT, "(%s, %d, %s, %d, %d, %d, %u, %u, %s)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations, (unsigned int)memory, GET_PRS(offset))
    glatter_glTexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorageMem3DMultisampleEXT_defined
#endif
#ifndef glTextureStorageMem1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageMem1DEXT, (texture, levels, internalFormat, width, memory, offset), (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageMem1DEXT_debug(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageMem1DEXT, "(%u, %d, %s, %d, %u, %s)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalFormat), (int)width, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageMem1DEXT_defined
#endif
#ifndef glTextureStorageMem2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageMem2DEXT, (texture, levels, internalFormat, width, height, memory, offset), (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageMem2DEXT_debug(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageMem2DEXT, "(%u, %d, %s, %d, %d, %u, %s)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalFormat), (int)width, (int)height, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageMem2DEXT_defined
#endif
#ifndef glTextureStorageMem2DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageMem2DMultisampleEXT, (texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset), (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageMem2DMultisampleEXT_debug(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageMem2DMultisampleEXT, "(%u, %d, %s, %d, %d, %u, %u, %s)", (unsigned int)texture, (int)samples, enum_to_string_GL(internalFormat), (int)width, (int)height, (unsigned char)fixedSampleLocations, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageMem2DMultisampleEXT_defined
#endif
#ifndef glTextureStorageMem3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageMem3DEXT, (texture, levels, internalFormat, width, height, depth, memory, offset), (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageMem3DEXT_debug(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageMem3DEXT, "(%u, %d, %s, %d, %d, %d, %u, %s)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageMem3DEXT_defined
#endif
#ifndef glTextureStorageMem3DMultisampleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorageMem3DMultisampleEXT, (texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset), (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorageMem3DMultisampleEXT_debug(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageMem3DMultisampleEXT, "(%u, %d, %s, %d, %d, %d, %u, %u, %s)", (unsigned int)texture, (int)samples, enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorageMem3DMultisampleEXT_defined
#endif
#endif // defined(GL_EXT_memory_object)
#if defined(GL_EXT_memory_object_fd)
#ifndef glImportMemoryFdEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportMemoryFdEXT, (memory, size, handleType, fd), (GLuint memory, GLuint64 size, GLenum handleType, GLint fd))
GLATTER_INLINE_OR_NOT void glatter_glImportMemoryFdEXT_debug(GLuint memory, GLuint64 size, GLenum handleType, GLint fd, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportMemoryFdEXT, "(%u, %s, %s, %d)", (unsigned int)memory, GET_PRS(size), enum_to_string_GL(handleType), (int)fd)
    glatter_glImportMemoryFdEXT(memory, size, handleType, fd);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportMemoryFdEXT_defined
#endif
#endif // defined(GL_EXT_memory_object_fd)
#if defined(GL_EXT_memory_object_win32)
#ifndef glImportMemoryWin32HandleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportMemoryWin32HandleEXT, (memory, size, handleType, handle), (GLuint memory, GLuint64 size, GLenum handleType, void *handle))
GLATTER_INLINE_OR_NOT void glatter_glImportMemoryWin32HandleEXT_debug(GLuint memory, GLuint64 size, GLenum handleType, void *handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportMemoryWin32HandleEXT, "(%u, %s, %s, %p)", (unsigned int)memory, GET_PRS(size), enum_to_string_GL(handleType), (void*)handle)
    glatter_glImportMemoryWin32HandleEXT(memory, size, handleType, handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportMemoryWin32HandleEXT_defined
#endif
#ifndef glImportMemoryWin32NameEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportMemoryWin32NameEXT, (memory, size, handleType, name), (GLuint memory, GLuint64 size, GLenum handleType, const void *name))
GLATTER_INLINE_OR_NOT void glatter_glImportMemoryWin32NameEXT_debug(GLuint memory, GLuint64 size, GLenum handleType, const void *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportMemoryWin32NameEXT, "(%u, %s, %s, %p)", (unsigned int)memory, GET_PRS(size), enum_to_string_GL(handleType), (void*)name)
    glatter_glImportMemoryWin32NameEXT(memory, size, handleType, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportMemoryWin32NameEXT_defined
#endif
#endif // defined(GL_EXT_memory_object_win32)
#if defined(GL_EXT_multi_draw_arrays)
#ifndef glMultiDrawArraysEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysEXT, (mode, first, count, primcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysEXT_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysEXT, "(%s, %p, %p, %d)", enum_to_string_GL(mode), (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawArraysEXT(mode, first, count, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysEXT_defined
#endif
#ifndef glMultiDrawElementsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsEXT, (mode, count, type, indices, primcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsEXT_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsEXT, "(%s, %p, %s, %p, %d)", enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glMultiDrawElementsEXT(mode, count, type, indices, primcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsEXT_defined
#endif
#endif // defined(GL_EXT_multi_draw_arrays)
#if defined(GL_EXT_multisample)
#ifndef glSampleMaskEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleMaskEXT, (value, invert), (GLclampf value, GLboolean invert))
GLATTER_INLINE_OR_NOT void glatter_glSampleMaskEXT_debug(GLclampf value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskEXT, "(%f, %u)", (float)value, (unsigned char)invert)
    glatter_glSampleMaskEXT(value, invert);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleMaskEXT_defined
#endif
#ifndef glSamplePatternEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplePatternEXT, (pattern), (GLenum pattern))
GLATTER_INLINE_OR_NOT void glatter_glSamplePatternEXT_debug(GLenum pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplePatternEXT, "(%s)", enum_to_string_GL(pattern))
    glatter_glSamplePatternEXT(pattern);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplePatternEXT_defined
#endif
#endif // defined(GL_EXT_multisample)
#if defined(GL_EXT_paletted_texture)
#ifndef glColorTableEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableEXT, (target, internalFormat, width, format, type, table), (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_INLINE_OR_NOT void glatter_glColorTableEXT_debug(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableEXT, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTableEXT(target, internalFormat, width, format, type, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableEXT_defined
#endif
#ifndef glGetColorTableEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableEXT, (target, format, type, data), (GLenum target, GLenum format, GLenum type, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableEXT_debug(GLenum target, GLenum format, GLenum type, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableEXT, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glGetColorTableEXT(target, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableEXT_defined
#endif
#ifndef glGetColorTableParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameterfvEXT_defined
#endif
#ifndef glGetColorTableParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameterivEXT_defined
#endif
#endif // defined(GL_EXT_paletted_texture)
#if defined(GL_EXT_pixel_transform)
#ifndef glGetPixelTransformParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPixelTransformParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetPixelTransformParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTransformParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTransformParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPixelTransformParameterfvEXT_defined
#endif
#ifndef glGetPixelTransformParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPixelTransformParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetPixelTransformParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTransformParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTransformParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPixelTransformParameterivEXT_defined
#endif
#ifndef glPixelTransformParameterfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTransformParameterfEXT, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPixelTransformParameterfEXT_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterfEXT, "(%s, %s, %f)", enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glPixelTransformParameterfEXT(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTransformParameterfEXT_defined
#endif
#ifndef glPixelTransformParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTransformParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPixelTransformParameterfvEXT_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterfvEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTransformParameterfvEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTransformParameterfvEXT_defined
#endif
#ifndef glPixelTransformParameteriEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTransformParameteriEXT, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glPixelTransformParameteriEXT_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameteriEXT, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glPixelTransformParameteriEXT(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTransformParameteriEXT_defined
#endif
#ifndef glPixelTransformParameterivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTransformParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glPixelTransformParameterivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTransformParameterivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTransformParameterivEXT_defined
#endif
#endif // defined(GL_EXT_pixel_transform)
#if defined(GL_EXT_point_parameters)
#ifndef glPointParameterfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfEXT, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfEXT_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfEXT, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfEXT(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfEXT_defined
#endif
#ifndef glPointParameterfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfvEXT, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfvEXT_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvEXT, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvEXT(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfvEXT_defined
#endif
#endif // defined(GL_EXT_point_parameters)
#if defined(GL_EXT_polygon_offset)
#ifndef glPolygonOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPolygonOffsetEXT, (factor, bias), (GLfloat factor, GLfloat bias))
GLATTER_INLINE_OR_NOT void glatter_glPolygonOffsetEXT_debug(GLfloat factor, GLfloat bias, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetEXT, "(%f, %f)", (float)factor, (float)bias)
    glatter_glPolygonOffsetEXT(factor, bias);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPolygonOffsetEXT_defined
#endif
#endif // defined(GL_EXT_polygon_offset)
#if defined(GL_EXT_polygon_offset_clamp)
#ifndef glPolygonOffsetClampEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPolygonOffsetClampEXT, (factor, units, clamp), (GLfloat factor, GLfloat units, GLfloat clamp))
GLATTER_INLINE_OR_NOT void glatter_glPolygonOffsetClampEXT_debug(GLfloat factor, GLfloat units, GLfloat clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetClampEXT, "(%f, %f, %f)", (float)factor, (float)units, (float)clamp)
    glatter_glPolygonOffsetClampEXT(factor, units, clamp);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPolygonOffsetClampEXT_defined
#endif
#endif // defined(GL_EXT_polygon_offset_clamp)
#if defined(GL_EXT_provoking_vertex)
#ifndef glProvokingVertexEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProvokingVertexEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glProvokingVertexEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProvokingVertexEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glProvokingVertexEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProvokingVertexEXT_defined
#endif
#endif // defined(GL_EXT_provoking_vertex)
#if defined(GL_EXT_raster_multisample)
#ifndef glRasterSamplesEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterSamplesEXT, (samples, fixedsamplelocations), (GLuint samples, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glRasterSamplesEXT_debug(GLuint samples, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterSamplesEXT, "(%u, %u)", (unsigned int)samples, (unsigned char)fixedsamplelocations)
    glatter_glRasterSamplesEXT(samples, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterSamplesEXT_defined
#endif
#endif // defined(GL_EXT_raster_multisample)
#if defined(GL_EXT_secondary_color)
#ifndef glSecondaryColor3bEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3bEXT, (red, green, blue), (GLbyte red, GLbyte green, GLbyte blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3bEXT_debug(GLbyte red, GLbyte green, GLbyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bEXT, "(%d, %d, %d)", (signed char)red, (signed char)green, (signed char)blue)
    glatter_glSecondaryColor3bEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3bEXT_defined
#endif
#ifndef glSecondaryColor3bvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3bvEXT, (v), (const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bvEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3bvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3bvEXT_defined
#endif
#ifndef glSecondaryColor3dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3dEXT, (red, green, blue), (GLdouble red, GLdouble green, GLdouble blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3dEXT_debug(GLdouble red, GLdouble green, GLdouble blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dEXT, "(%f, %f, %f)", (double)red, (double)green, (double)blue)
    glatter_glSecondaryColor3dEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3dEXT_defined
#endif
#ifndef glSecondaryColor3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3dvEXT, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dvEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3dvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3dvEXT_defined
#endif
#ifndef glSecondaryColor3fEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3fEXT, (red, green, blue), (GLfloat red, GLfloat green, GLfloat blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3fEXT_debug(GLfloat red, GLfloat green, GLfloat blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fEXT, "(%f, %f, %f)", (float)red, (float)green, (float)blue)
    glatter_glSecondaryColor3fEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3fEXT_defined
#endif
#ifndef glSecondaryColor3fvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3fvEXT, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fvEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3fvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3fvEXT_defined
#endif
#ifndef glSecondaryColor3iEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3iEXT, (red, green, blue), (GLint red, GLint green, GLint blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3iEXT_debug(GLint red, GLint green, GLint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3iEXT, "(%d, %d, %d)", (int)red, (int)green, (int)blue)
    glatter_glSecondaryColor3iEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3iEXT_defined
#endif
#ifndef glSecondaryColor3ivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ivEXT, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ivEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3ivEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ivEXT_defined
#endif
#ifndef glSecondaryColor3sEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3sEXT, (red, green, blue), (GLshort red, GLshort green, GLshort blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3sEXT_debug(GLshort red, GLshort green, GLshort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3sEXT, "(%hi, %hi, %hi)", (short)red, (short)green, (short)blue)
    glatter_glSecondaryColor3sEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3sEXT_defined
#endif
#ifndef glSecondaryColor3svEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3svEXT, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3svEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3svEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3svEXT_defined
#endif
#ifndef glSecondaryColor3ubEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ubEXT, (red, green, blue), (GLubyte red, GLubyte green, GLubyte blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ubEXT_debug(GLubyte red, GLubyte green, GLubyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubEXT, "(%u, %u, %u)", (unsigned char)red, (unsigned char)green, (unsigned char)blue)
    glatter_glSecondaryColor3ubEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ubEXT_defined
#endif
#ifndef glSecondaryColor3ubvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ubvEXT, (v), (const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ubvEXT_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubvEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3ubvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ubvEXT_defined
#endif
#ifndef glSecondaryColor3uiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3uiEXT, (red, green, blue), (GLuint red, GLuint green, GLuint blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3uiEXT_debug(GLuint red, GLuint green, GLuint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uiEXT, "(%u, %u, %u)", (unsigned int)red, (unsigned int)green, (unsigned int)blue)
    glatter_glSecondaryColor3uiEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3uiEXT_defined
#endif
#ifndef glSecondaryColor3uivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3uivEXT, (v), (const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3uivEXT_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uivEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3uivEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3uivEXT_defined
#endif
#ifndef glSecondaryColor3usEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3usEXT, (red, green, blue), (GLushort red, GLushort green, GLushort blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3usEXT_debug(GLushort red, GLushort green, GLushort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usEXT, "(%hu, %hu, %hu)", (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3usEXT(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3usEXT_defined
#endif
#ifndef glSecondaryColor3usvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3usvEXT, (v), (const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3usvEXT_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usvEXT, "(%p)", (void*)v)
    glatter_glSecondaryColor3usvEXT(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3usvEXT_defined
#endif
#ifndef glSecondaryColorPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorPointerEXT, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorPointerEXT_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointerEXT, "(%d, %s, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glSecondaryColorPointerEXT(size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorPointerEXT_defined
#endif
#endif // defined(GL_EXT_secondary_color)
#if defined(GL_EXT_semaphore)
#ifndef glDeleteSemaphoresEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteSemaphoresEXT, (n, semaphores), (GLsizei n, const GLuint *semaphores))
GLATTER_INLINE_OR_NOT void glatter_glDeleteSemaphoresEXT_debug(GLsizei n, const GLuint *semaphores, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSemaphoresEXT, "(%d, %p)", (int)n, (void*)semaphores)
    glatter_glDeleteSemaphoresEXT(n, semaphores);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteSemaphoresEXT_defined
#endif
#ifndef glGenSemaphoresEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenSemaphoresEXT, (n, semaphores), (GLsizei n, GLuint *semaphores))
GLATTER_INLINE_OR_NOT void glatter_glGenSemaphoresEXT_debug(GLsizei n, GLuint *semaphores, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSemaphoresEXT, "(%d, %p)", (int)n, (void*)semaphores)
    glatter_glGenSemaphoresEXT(n, semaphores);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenSemaphoresEXT_defined
#endif
#ifndef glGetSemaphoreParameterui64vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSemaphoreParameterui64vEXT, (semaphore, pname, params), (GLuint semaphore, GLenum pname, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSemaphoreParameterui64vEXT_debug(GLuint semaphore, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSemaphoreParameterui64vEXT, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSemaphoreParameterui64vEXT(semaphore, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSemaphoreParameterui64vEXT_defined
#endif
#ifndef glIsSemaphoreEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsSemaphoreEXT, (semaphore), (GLuint semaphore))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsSemaphoreEXT_debug(GLuint semaphore, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSemaphoreEXT, "(%u)", (unsigned int)semaphore)
    GLboolean rval = glatter_glIsSemaphoreEXT(semaphore);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsSemaphoreEXT_defined
#endif
#ifndef glSemaphoreParameterui64vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSemaphoreParameterui64vEXT, (semaphore, pname, params), (GLuint semaphore, GLenum pname, const GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glSemaphoreParameterui64vEXT_debug(GLuint semaphore, GLenum pname, const GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSemaphoreParameterui64vEXT, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(pname), (void*)params)
    glatter_glSemaphoreParameterui64vEXT(semaphore, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSemaphoreParameterui64vEXT_defined
#endif
#ifndef glSignalSemaphoreEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSignalSemaphoreEXT, (semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts), (GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts))
GLATTER_INLINE_OR_NOT void glatter_glSignalSemaphoreEXT_debug(GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSignalSemaphoreEXT, "(%u, %u, %p, %u, %p, %p)", (unsigned int)semaphore, (unsigned int)numBufferBarriers, (void*)buffers, (unsigned int)numTextureBarriers, (void*)textures, (void*)dstLayouts)
    glatter_glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSignalSemaphoreEXT_defined
#endif
#ifndef glWaitSemaphoreEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWaitSemaphoreEXT, (semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts), (GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts))
GLATTER_INLINE_OR_NOT void glatter_glWaitSemaphoreEXT_debug(GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSemaphoreEXT, "(%u, %u, %p, %u, %p, %p)", (unsigned int)semaphore, (unsigned int)numBufferBarriers, (void*)buffers, (unsigned int)numTextureBarriers, (void*)textures, (void*)srcLayouts)
    glatter_glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWaitSemaphoreEXT_defined
#endif
#endif // defined(GL_EXT_semaphore)
#if defined(GL_EXT_semaphore_fd)
#ifndef glImportSemaphoreFdEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportSemaphoreFdEXT, (semaphore, handleType, fd), (GLuint semaphore, GLenum handleType, GLint fd))
GLATTER_INLINE_OR_NOT void glatter_glImportSemaphoreFdEXT_debug(GLuint semaphore, GLenum handleType, GLint fd, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportSemaphoreFdEXT, "(%u, %s, %d)", (unsigned int)semaphore, enum_to_string_GL(handleType), (int)fd)
    glatter_glImportSemaphoreFdEXT(semaphore, handleType, fd);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportSemaphoreFdEXT_defined
#endif
#endif // defined(GL_EXT_semaphore_fd)
#if defined(GL_EXT_semaphore_win32)
#ifndef glImportSemaphoreWin32HandleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportSemaphoreWin32HandleEXT, (semaphore, handleType, handle), (GLuint semaphore, GLenum handleType, void *handle))
GLATTER_INLINE_OR_NOT void glatter_glImportSemaphoreWin32HandleEXT_debug(GLuint semaphore, GLenum handleType, void *handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportSemaphoreWin32HandleEXT, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(handleType), (void*)handle)
    glatter_glImportSemaphoreWin32HandleEXT(semaphore, handleType, handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportSemaphoreWin32HandleEXT_defined
#endif
#ifndef glImportSemaphoreWin32NameEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImportSemaphoreWin32NameEXT, (semaphore, handleType, name), (GLuint semaphore, GLenum handleType, const void *name))
GLATTER_INLINE_OR_NOT void glatter_glImportSemaphoreWin32NameEXT_debug(GLuint semaphore, GLenum handleType, const void *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportSemaphoreWin32NameEXT, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(handleType), (void*)name)
    glatter_glImportSemaphoreWin32NameEXT(semaphore, handleType, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImportSemaphoreWin32NameEXT_defined
#endif
#endif // defined(GL_EXT_semaphore_win32)
#if defined(GL_EXT_separate_shader_objects)
#ifndef glActiveProgramEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveProgramEXT, (program), (GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glActiveProgramEXT_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveProgramEXT, "(%u)", (unsigned int)program)
    glatter_glActiveProgramEXT(program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveProgramEXT_defined
#endif
#ifndef glCreateShaderProgramEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glCreateShaderProgramEXT, (type, string), (GLenum type, const GLchar *string))
GLATTER_INLINE_OR_NOT GLuint glatter_glCreateShaderProgramEXT_debug(GLenum type, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramEXT, "(%s, %p)", enum_to_string_GL(type), (void*)string)
    GLuint rval = glatter_glCreateShaderProgramEXT(type, string);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateShaderProgramEXT_defined
#endif
#ifndef glUseShaderProgramEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUseShaderProgramEXT, (type, program), (GLenum type, GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glUseShaderProgramEXT_debug(GLenum type, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseShaderProgramEXT, "(%s, %u)", enum_to_string_GL(type), (unsigned int)program)
    glatter_glUseShaderProgramEXT(type, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUseShaderProgramEXT_defined
#endif
#endif // defined(GL_EXT_separate_shader_objects)
#if defined(GL_EXT_shader_framebuffer_fetch_non_coherent)
#ifndef glFramebufferFetchBarrierEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferFetchBarrierEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferFetchBarrierEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferFetchBarrierEXT, "()")
    glatter_glFramebufferFetchBarrierEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferFetchBarrierEXT_defined
#endif
#endif // defined(GL_EXT_shader_framebuffer_fetch_non_coherent)
#if defined(GL_EXT_shader_image_load_store)
#ifndef glBindImageTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindImageTextureEXT, (index, texture, level, layered, layer, access, format), (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format))
GLATTER_INLINE_OR_NOT void glatter_glBindImageTextureEXT_debug(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTextureEXT, "(%u, %u, %d, %u, %d, %s, %d)", (unsigned int)index, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), (int)format)
    glatter_glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindImageTextureEXT_defined
#endif
#ifndef glMemoryBarrierEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMemoryBarrierEXT, (barriers), (GLbitfield barriers))
GLATTER_INLINE_OR_NOT void glatter_glMemoryBarrierEXT_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierEXT, "(%u)", (unsigned int)barriers)
    glatter_glMemoryBarrierEXT(barriers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMemoryBarrierEXT_defined
#endif
#endif // defined(GL_EXT_shader_image_load_store)
#if defined(GL_EXT_stencil_clear_tag)
#ifndef glStencilClearTagEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilClearTagEXT, (stencilTagBits, stencilClearTag), (GLsizei stencilTagBits, GLuint stencilClearTag))
GLATTER_INLINE_OR_NOT void glatter_glStencilClearTagEXT_debug(GLsizei stencilTagBits, GLuint stencilClearTag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilClearTagEXT, "(%d, %u)", (int)stencilTagBits, (unsigned int)stencilClearTag)
    glatter_glStencilClearTagEXT(stencilTagBits, stencilClearTag);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilClearTagEXT_defined
#endif
#endif // defined(GL_EXT_stencil_clear_tag)
#if defined(GL_EXT_stencil_two_side)
#ifndef glActiveStencilFaceEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveStencilFaceEXT, (face), (GLenum face))
GLATTER_INLINE_OR_NOT void glatter_glActiveStencilFaceEXT_debug(GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveStencilFaceEXT, "(%s)", enum_to_string_GL(face))
    glatter_glActiveStencilFaceEXT(face);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveStencilFaceEXT_defined
#endif
#endif // defined(GL_EXT_stencil_two_side)
#if defined(GL_EXT_subtexture)
#ifndef glTexSubImage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexSubImage1DEXT, (target, level, xoffset, width, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexSubImage1DEXT_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage1DEXT, "(%s, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexSubImage1DEXT_defined
#endif
#ifndef glTexSubImage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexSubImage2DEXT, (target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexSubImage2DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage2DEXT, "(%s, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexSubImage2DEXT_defined
#endif
#endif // defined(GL_EXT_subtexture)
#if defined(GL_EXT_texture3D)
#ifndef glTexImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage3DEXT, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexImage3DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DEXT, "(%s, %d, %s, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage3DEXT_defined
#endif
#ifndef glTexSubImage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexSubImage3DEXT, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexSubImage3DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3DEXT, "(%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexSubImage3DEXT_defined
#endif
#endif // defined(GL_EXT_texture3D)
#if defined(GL_EXT_texture_array)
#ifndef glFramebufferTextureLayerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureLayerEXT, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureLayerEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayerEXT, "(%s, %s, %u, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureLayerEXT_defined
#endif
#endif // defined(GL_EXT_texture_array)
#if defined(GL_EXT_texture_buffer_object)
#ifndef glTexBufferEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBufferEXT, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTexBufferEXT_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferEXT, "(%s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferEXT(target, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBufferEXT_defined
#endif
#endif // defined(GL_EXT_texture_buffer_object)
#if defined(GL_EXT_texture_integer)
#ifndef glClearColorIiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearColorIiEXT, (red, green, blue, alpha), (GLint red, GLint green, GLint blue, GLint alpha))
GLATTER_INLINE_OR_NOT void glatter_glClearColorIiEXT_debug(GLint red, GLint green, GLint blue, GLint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorIiEXT, "(%d, %d, %d, %d)", (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glClearColorIiEXT(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearColorIiEXT_defined
#endif
#ifndef glClearColorIuiEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearColorIuiEXT, (red, green, blue, alpha), (GLuint red, GLuint green, GLuint blue, GLuint alpha))
GLATTER_INLINE_OR_NOT void glatter_glClearColorIuiEXT_debug(GLuint red, GLuint green, GLuint blue, GLuint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorIuiEXT, "(%u, %u, %u, %u)", (unsigned int)red, (unsigned int)green, (unsigned int)blue, (unsigned int)alpha)
    glatter_glClearColorIuiEXT(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearColorIuiEXT_defined
#endif
#ifndef glGetTexParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterIivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterIivEXT_defined
#endif
#ifndef glGetTexParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterIuivEXT_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterIuivEXT_defined
#endif
#ifndef glTexParameterIivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterIivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterIivEXT_defined
#endif
#ifndef glTexParameterIuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterIuivEXT_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuivEXT, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuivEXT(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterIuivEXT_defined
#endif
#endif // defined(GL_EXT_texture_integer)
#if defined(GL_EXT_texture_object)
#ifndef glAreTexturesResidentEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glAreTexturesResidentEXT, (n, textures, residences), (GLsizei n, const GLuint *textures, GLboolean *residences))
GLATTER_INLINE_OR_NOT GLboolean glatter_glAreTexturesResidentEXT_debug(GLsizei n, const GLuint *textures, GLboolean *residences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAreTexturesResidentEXT, "(%d, %p, %p)", (int)n, (void*)textures, (void*)residences)
    GLboolean rval = glatter_glAreTexturesResidentEXT(n, textures, residences);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glAreTexturesResidentEXT_defined
#endif
#ifndef glBindTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindTextureEXT, (target, texture), (GLenum target, GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glBindTextureEXT_debug(GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureEXT, "(%s, %u)", enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindTextureEXT(target, texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindTextureEXT_defined
#endif
#ifndef glDeleteTexturesEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteTexturesEXT, (n, textures), (GLsizei n, const GLuint *textures))
GLATTER_INLINE_OR_NOT void glatter_glDeleteTexturesEXT_debug(GLsizei n, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTexturesEXT, "(%d, %p)", (int)n, (void*)textures)
    glatter_glDeleteTexturesEXT(n, textures);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteTexturesEXT_defined
#endif
#ifndef glGenTexturesEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenTexturesEXT, (n, textures), (GLsizei n, GLuint *textures))
GLATTER_INLINE_OR_NOT void glatter_glGenTexturesEXT_debug(GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTexturesEXT, "(%d, %p)", (int)n, (void*)textures)
    glatter_glGenTexturesEXT(n, textures);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenTexturesEXT_defined
#endif
#ifndef glIsTextureEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsTextureEXT, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsTextureEXT_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureEXT, "(%u)", (unsigned int)texture)
    GLboolean rval = glatter_glIsTextureEXT(texture);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsTextureEXT_defined
#endif
#ifndef glPrioritizeTexturesEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrioritizeTexturesEXT, (n, textures, priorities), (GLsizei n, const GLuint *textures, const GLclampf *priorities))
GLATTER_INLINE_OR_NOT void glatter_glPrioritizeTexturesEXT_debug(GLsizei n, const GLuint *textures, const GLclampf *priorities, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrioritizeTexturesEXT, "(%d, %p, %p)", (int)n, (void*)textures, (void*)priorities)
    glatter_glPrioritizeTexturesEXT(n, textures, priorities);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrioritizeTexturesEXT_defined
#endif
#endif // defined(GL_EXT_texture_object)
#if defined(GL_EXT_texture_perturb_normal)
#ifndef glTextureNormalEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureNormalEXT, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glTextureNormalEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureNormalEXT, "(%s)", enum_to_string_GL(mode))
    glatter_glTextureNormalEXT(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureNormalEXT_defined
#endif
#endif // defined(GL_EXT_texture_perturb_normal)
#if defined(GL_EXT_texture_storage)
#ifndef glTexStorage1DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage1DEXT, (target, levels, internalformat, width), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage1DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage1DEXT, "(%s, %d, %s, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTexStorage1DEXT(target, levels, internalformat, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage1DEXT_defined
#endif
#ifndef glTexStorage2DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage2DEXT, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage2DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DEXT, "(%s, %d, %s, %d, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2DEXT(target, levels, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage2DEXT_defined
#endif
#ifndef glTexStorage3DEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage3DEXT, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage3DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DEXT, "(%s, %d, %s, %d, %d, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage3DEXT_defined
#endif
#endif // defined(GL_EXT_texture_storage)
#if defined(GL_EXT_timer_query)
#ifndef glGetQueryObjecti64vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjecti64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjecti64vEXT_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64vEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64vEXT(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjecti64vEXT_defined
#endif
#ifndef glGetQueryObjectui64vEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectui64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectui64vEXT_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64vEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64vEXT(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectui64vEXT_defined
#endif
#endif // defined(GL_EXT_timer_query)
#if defined(GL_EXT_transform_feedback)
#ifndef glBeginTransformFeedbackEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginTransformFeedbackEXT, (primitiveMode), (GLenum primitiveMode))
GLATTER_INLINE_OR_NOT void glatter_glBeginTransformFeedbackEXT_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedbackEXT, "(%s)", enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedbackEXT(primitiveMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginTransformFeedbackEXT_defined
#endif
#ifndef glBindBufferBaseEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferBaseEXT, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferBaseEXT_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBaseEXT, "(%s, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBaseEXT(target, index, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferBaseEXT_defined
#endif
#ifndef glBindBufferOffsetEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferOffsetEXT, (target, index, buffer, offset), (GLenum target, GLuint index, GLuint buffer, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferOffsetEXT_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferOffsetEXT, "(%s, %u, %u, %s)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, GET_PRS(offset))
    glatter_glBindBufferOffsetEXT(target, index, buffer, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferOffsetEXT_defined
#endif
#ifndef glBindBufferRangeEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferRangeEXT, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferRangeEXT_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRangeEXT, "(%s, %u, %u, %s, %s)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glBindBufferRangeEXT(target, index, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferRangeEXT_defined
#endif
#ifndef glEndTransformFeedbackEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndTransformFeedbackEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndTransformFeedbackEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedbackEXT, "()")
    glatter_glEndTransformFeedbackEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndTransformFeedbackEXT_defined
#endif
#ifndef glGetTransformFeedbackVaryingEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbackVaryingEXT, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbackVaryingEXT_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVaryingEXT, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbackVaryingEXT_defined
#endif
#ifndef glTransformFeedbackVaryingsEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackVaryingsEXT, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackVaryingsEXT_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryingsEXT, "(%u, %d, %p, %s)", (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackVaryingsEXT_defined
#endif
#endif // defined(GL_EXT_transform_feedback)
#if defined(GL_EXT_vertex_array)
#ifndef glArrayElementEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glArrayElementEXT, (i), (GLint i))
GLATTER_INLINE_OR_NOT void glatter_glArrayElementEXT_debug(GLint i, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glArrayElementEXT, "(%d)", (int)i)
    glatter_glArrayElementEXT(i);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glArrayElementEXT_defined
#endif
#ifndef glColorPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glColorPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointerEXT, "(%d, %s, %d, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glColorPointerEXT(size, type, stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorPointerEXT_defined
#endif
#ifndef glDrawArraysEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysEXT, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysEXT_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysEXT, "(%s, %d, %d)", enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawArraysEXT(mode, first, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysEXT_defined
#endif
#ifndef glEdgeFlagPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEdgeFlagPointerEXT, (stride, count, pointer), (GLsizei stride, GLsizei count, const GLboolean *pointer))
GLATTER_INLINE_OR_NOT void glatter_glEdgeFlagPointerEXT_debug(GLsizei stride, GLsizei count, const GLboolean *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagPointerEXT, "(%d, %d, %p)", (int)stride, (int)count, (void*)pointer)
    glatter_glEdgeFlagPointerEXT(stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEdgeFlagPointerEXT_defined
#endif
#ifndef glGetPointervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPointervEXT, (pname, params), (GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetPointervEXT_debug(GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointervEXT, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointervEXT(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPointervEXT_defined
#endif
#ifndef glIndexPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexPointerEXT, (type, stride, count, pointer), (GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glIndexPointerEXT_debug(GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexPointerEXT, "(%s, %d, %d, %p)", enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glIndexPointerEXT(type, stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexPointerEXT_defined
#endif
#ifndef glNormalPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalPointerEXT, (type, stride, count, pointer), (GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glNormalPointerEXT_debug(GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointerEXT, "(%s, %d, %d, %p)", enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glNormalPointerEXT(type, stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalPointerEXT_defined
#endif
#ifndef glTexCoordPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointerEXT, "(%d, %s, %d, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glTexCoordPointerEXT(size, type, stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordPointerEXT_defined
#endif
#ifndef glVertexPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointerEXT, "(%d, %s, %d, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glVertexPointerEXT(size, type, stride, count, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexPointerEXT_defined
#endif
#endif // defined(GL_EXT_vertex_array)
#if defined(GL_EXT_vertex_attrib_64bit)
#ifndef glGetVertexAttribLdvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribLdvEXT, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribLdvEXT_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLdvEXT, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLdvEXT(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribLdvEXT_defined
#endif
#ifndef glVertexAttribL1dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1dEXT, (index, x), (GLuint index, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1dEXT_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dEXT, "(%u, %f)", (unsigned int)index, (double)x)
    glatter_glVertexAttribL1dEXT(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1dEXT_defined
#endif
#ifndef glVertexAttribL1dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1dvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1dvEXT_defined
#endif
#ifndef glVertexAttribL2dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2dEXT, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2dEXT_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dEXT, "(%u, %f, %f)", (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttribL2dEXT(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2dEXT_defined
#endif
#ifndef glVertexAttribL2dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2dvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2dvEXT_defined
#endif
#ifndef glVertexAttribL3dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3dEXT, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3dEXT_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dEXT, "(%u, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttribL3dEXT(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3dEXT_defined
#endif
#ifndef glVertexAttribL3dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3dvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3dvEXT_defined
#endif
#ifndef glVertexAttribL4dEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4dEXT, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4dEXT_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dEXT, "(%u, %f, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttribL4dEXT(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4dEXT_defined
#endif
#ifndef glVertexAttribL4dvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dvEXT, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4dvEXT(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4dvEXT_defined
#endif
#ifndef glVertexAttribLPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribLPointerEXT, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribLPointerEXT_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLPointerEXT, "(%u, %d, %s, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribLPointerEXT(index, size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribLPointerEXT_defined
#endif
#endif // defined(GL_EXT_vertex_attrib_64bit)
#if defined(GL_EXT_vertex_shader)
#ifndef glBeginVertexShaderEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginVertexShaderEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glBeginVertexShaderEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginVertexShaderEXT, "()")
    glatter_glBeginVertexShaderEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginVertexShaderEXT_defined
#endif
#ifndef glBindLightParameterEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glBindLightParameterEXT, (light, value), (GLenum light, GLenum value))
GLATTER_INLINE_OR_NOT GLuint glatter_glBindLightParameterEXT_debug(GLenum light, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindLightParameterEXT, "(%s, %s)", enum_to_string_GL(light), enum_to_string_GL(value))
    GLuint rval = glatter_glBindLightParameterEXT(light, value);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glBindLightParameterEXT_defined
#endif
#ifndef glBindMaterialParameterEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glBindMaterialParameterEXT, (face, value), (GLenum face, GLenum value))
GLATTER_INLINE_OR_NOT GLuint glatter_glBindMaterialParameterEXT_debug(GLenum face, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindMaterialParameterEXT, "(%s, %s)", enum_to_string_GL(face), enum_to_string_GL(value))
    GLuint rval = glatter_glBindMaterialParameterEXT(face, value);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glBindMaterialParameterEXT_defined
#endif
#ifndef glBindParameterEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glBindParameterEXT, (value), (GLenum value))
GLATTER_INLINE_OR_NOT GLuint glatter_glBindParameterEXT_debug(GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindParameterEXT, "(%s)", enum_to_string_GL(value))
    GLuint rval = glatter_glBindParameterEXT(value);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glBindParameterEXT_defined
#endif
#ifndef glBindTexGenParameterEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glBindTexGenParameterEXT, (unit, coord, value), (GLenum unit, GLenum coord, GLenum value))
GLATTER_INLINE_OR_NOT GLuint glatter_glBindTexGenParameterEXT_debug(GLenum unit, GLenum coord, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTexGenParameterEXT, "(%s, %s, %s)", enum_to_string_GL(unit), enum_to_string_GL(coord), enum_to_string_GL(value))
    GLuint rval = glatter_glBindTexGenParameterEXT(unit, coord, value);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glBindTexGenParameterEXT_defined
#endif
#ifndef glBindTextureUnitParameterEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glBindTextureUnitParameterEXT, (unit, value), (GLenum unit, GLenum value))
GLATTER_INLINE_OR_NOT GLuint glatter_glBindTextureUnitParameterEXT_debug(GLenum unit, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureUnitParameterEXT, "(%s, %s)", enum_to_string_GL(unit), enum_to_string_GL(value))
    GLuint rval = glatter_glBindTextureUnitParameterEXT(unit, value);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glBindTextureUnitParameterEXT_defined
#endif
#ifndef glBindVertexShaderEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVertexShaderEXT, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBindVertexShaderEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexShaderEXT, "(%u)", (unsigned int)id)
    glatter_glBindVertexShaderEXT(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVertexShaderEXT_defined
#endif
#ifndef glDeleteVertexShaderEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteVertexShaderEXT, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glDeleteVertexShaderEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexShaderEXT, "(%u)", (unsigned int)id)
    glatter_glDeleteVertexShaderEXT(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteVertexShaderEXT_defined
#endif
#ifndef glDisableVariantClientStateEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVariantClientStateEXT, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glDisableVariantClientStateEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVariantClientStateEXT, "(%u)", (unsigned int)id)
    glatter_glDisableVariantClientStateEXT(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVariantClientStateEXT_defined
#endif
#ifndef glEnableVariantClientStateEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVariantClientStateEXT, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glEnableVariantClientStateEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVariantClientStateEXT, "(%u)", (unsigned int)id)
    glatter_glEnableVariantClientStateEXT(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVariantClientStateEXT_defined
#endif
#ifndef glEndVertexShaderEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndVertexShaderEXT, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndVertexShaderEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndVertexShaderEXT, "()")
    glatter_glEndVertexShaderEXT();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndVertexShaderEXT_defined
#endif
#ifndef glExtractComponentEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glExtractComponentEXT, (res, src, num), (GLuint res, GLuint src, GLuint num))
GLATTER_INLINE_OR_NOT void glatter_glExtractComponentEXT_debug(GLuint res, GLuint src, GLuint num, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtractComponentEXT, "(%u, %u, %u)", (unsigned int)res, (unsigned int)src, (unsigned int)num)
    glatter_glExtractComponentEXT(res, src, num);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glExtractComponentEXT_defined
#endif
#ifndef glGenSymbolsEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGenSymbolsEXT, (datatype, storagetype, range, components), (GLenum datatype, GLenum storagetype, GLenum range, GLuint components))
GLATTER_INLINE_OR_NOT GLuint glatter_glGenSymbolsEXT_debug(GLenum datatype, GLenum storagetype, GLenum range, GLuint components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSymbolsEXT, "(%s, %s, %s, %u)", enum_to_string_GL(datatype), enum_to_string_GL(storagetype), enum_to_string_GL(range), (unsigned int)components)
    GLuint rval = glatter_glGenSymbolsEXT(datatype, storagetype, range, components);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGenSymbolsEXT_defined
#endif
#ifndef glGenVertexShadersEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGenVertexShadersEXT, (range), (GLuint range))
GLATTER_INLINE_OR_NOT GLuint glatter_glGenVertexShadersEXT_debug(GLuint range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexShadersEXT, "(%u)", (unsigned int)range)
    GLuint rval = glatter_glGenVertexShadersEXT(range);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGenVertexShadersEXT_defined
#endif
#ifndef glGetInvariantBooleanvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInvariantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_INLINE_OR_NOT void glatter_glGetInvariantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantBooleanvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantBooleanvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInvariantBooleanvEXT_defined
#endif
#ifndef glGetInvariantFloatvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInvariantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_INLINE_OR_NOT void glatter_glGetInvariantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantFloatvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantFloatvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInvariantFloatvEXT_defined
#endif
#ifndef glGetInvariantIntegervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInvariantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_INLINE_OR_NOT void glatter_glGetInvariantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantIntegervEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantIntegervEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInvariantIntegervEXT_defined
#endif
#ifndef glGetLocalConstantBooleanvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetLocalConstantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_INLINE_OR_NOT void glatter_glGetLocalConstantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantBooleanvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantBooleanvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetLocalConstantBooleanvEXT_defined
#endif
#ifndef glGetLocalConstantFloatvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetLocalConstantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_INLINE_OR_NOT void glatter_glGetLocalConstantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantFloatvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantFloatvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetLocalConstantFloatvEXT_defined
#endif
#ifndef glGetLocalConstantIntegervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetLocalConstantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_INLINE_OR_NOT void glatter_glGetLocalConstantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantIntegervEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantIntegervEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetLocalConstantIntegervEXT_defined
#endif
#ifndef glGetVariantBooleanvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantBooleanvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantBooleanvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantBooleanvEXT_defined
#endif
#ifndef glGetVariantFloatvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantFloatvEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantFloatvEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantFloatvEXT_defined
#endif
#ifndef glGetVariantIntegervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantIntegervEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantIntegervEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantIntegervEXT_defined
#endif
#ifndef glGetVariantPointervEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVariantPointervEXT, (id, value, data), (GLuint id, GLenum value, void **data))
GLATTER_INLINE_OR_NOT void glatter_glGetVariantPointervEXT_debug(GLuint id, GLenum value, void **data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantPointervEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantPointervEXT(id, value, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVariantPointervEXT_defined
#endif
#ifndef glInsertComponentEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInsertComponentEXT, (res, src, num), (GLuint res, GLuint src, GLuint num))
GLATTER_INLINE_OR_NOT void glatter_glInsertComponentEXT_debug(GLuint res, GLuint src, GLuint num, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertComponentEXT, "(%u, %u, %u)", (unsigned int)res, (unsigned int)src, (unsigned int)num)
    glatter_glInsertComponentEXT(res, src, num);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInsertComponentEXT_defined
#endif
#ifndef glIsVariantEnabledEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsVariantEnabledEXT, (id, cap), (GLuint id, GLenum cap))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsVariantEnabledEXT_debug(GLuint id, GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVariantEnabledEXT, "(%u, %s)", (unsigned int)id, enum_to_string_GL(cap))
    GLboolean rval = glatter_glIsVariantEnabledEXT(id, cap);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsVariantEnabledEXT_defined
#endif
#ifndef glSetInvariantEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetInvariantEXT, (id, type, addr), (GLuint id, GLenum type, const void *addr))
GLATTER_INLINE_OR_NOT void glatter_glSetInvariantEXT_debug(GLuint id, GLenum type, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetInvariantEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(type), (void*)addr)
    glatter_glSetInvariantEXT(id, type, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetInvariantEXT_defined
#endif
#ifndef glSetLocalConstantEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetLocalConstantEXT, (id, type, addr), (GLuint id, GLenum type, const void *addr))
GLATTER_INLINE_OR_NOT void glatter_glSetLocalConstantEXT_debug(GLuint id, GLenum type, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetLocalConstantEXT, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(type), (void*)addr)
    glatter_glSetLocalConstantEXT(id, type, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetLocalConstantEXT_defined
#endif
#ifndef glShaderOp1EXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderOp1EXT, (op, res, arg1), (GLenum op, GLuint res, GLuint arg1))
GLATTER_INLINE_OR_NOT void glatter_glShaderOp1EXT_debug(GLenum op, GLuint res, GLuint arg1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp1EXT, "(%s, %u, %u)", enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1)
    glatter_glShaderOp1EXT(op, res, arg1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderOp1EXT_defined
#endif
#ifndef glShaderOp2EXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderOp2EXT, (op, res, arg1, arg2), (GLenum op, GLuint res, GLuint arg1, GLuint arg2))
GLATTER_INLINE_OR_NOT void glatter_glShaderOp2EXT_debug(GLenum op, GLuint res, GLuint arg1, GLuint arg2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp2EXT, "(%s, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1, (unsigned int)arg2)
    glatter_glShaderOp2EXT(op, res, arg1, arg2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderOp2EXT_defined
#endif
#ifndef glShaderOp3EXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderOp3EXT, (op, res, arg1, arg2, arg3), (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3))
GLATTER_INLINE_OR_NOT void glatter_glShaderOp3EXT_debug(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp3EXT, "(%s, %u, %u, %u, %u)", enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1, (unsigned int)arg2, (unsigned int)arg3)
    glatter_glShaderOp3EXT(op, res, arg1, arg2, arg3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderOp3EXT_defined
#endif
#ifndef glSwizzleEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSwizzleEXT, (res, in, outX, outY, outZ, outW), (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW))
GLATTER_INLINE_OR_NOT void glatter_glSwizzleEXT_debug(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSwizzleEXT, "(%u, %u, %s, %s, %s, %s)", (unsigned int)res, (unsigned int)in, enum_to_string_GL(outX), enum_to_string_GL(outY), enum_to_string_GL(outZ), enum_to_string_GL(outW))
    glatter_glSwizzleEXT(res, in, outX, outY, outZ, outW);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSwizzleEXT_defined
#endif
#ifndef glVariantPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantPointerEXT, (id, type, stride, addr), (GLuint id, GLenum type, GLuint stride, const void *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantPointerEXT_debug(GLuint id, GLenum type, GLuint stride, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantPointerEXT, "(%u, %s, %u, %p)", (unsigned int)id, enum_to_string_GL(type), (unsigned int)stride, (void*)addr)
    glatter_glVariantPointerEXT(id, type, stride, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantPointerEXT_defined
#endif
#ifndef glVariantbvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantbvEXT, (id, addr), (GLuint id, const GLbyte *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantbvEXT_debug(GLuint id, const GLbyte *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantbvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantbvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantbvEXT_defined
#endif
#ifndef glVariantdvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantdvEXT, (id, addr), (GLuint id, const GLdouble *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantdvEXT_debug(GLuint id, const GLdouble *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantdvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantdvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantdvEXT_defined
#endif
#ifndef glVariantfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantfvEXT, (id, addr), (GLuint id, const GLfloat *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantfvEXT_debug(GLuint id, const GLfloat *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantfvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantfvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantfvEXT_defined
#endif
#ifndef glVariantivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantivEXT, (id, addr), (GLuint id, const GLint *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantivEXT_debug(GLuint id, const GLint *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantivEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantivEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantivEXT_defined
#endif
#ifndef glVariantsvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantsvEXT, (id, addr), (GLuint id, const GLshort *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantsvEXT_debug(GLuint id, const GLshort *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantsvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantsvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantsvEXT_defined
#endif
#ifndef glVariantubvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantubvEXT, (id, addr), (GLuint id, const GLubyte *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantubvEXT_debug(GLuint id, const GLubyte *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantubvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantubvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantubvEXT_defined
#endif
#ifndef glVariantuivEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantuivEXT, (id, addr), (GLuint id, const GLuint *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantuivEXT_debug(GLuint id, const GLuint *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantuivEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantuivEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantuivEXT_defined
#endif
#ifndef glVariantusvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVariantusvEXT, (id, addr), (GLuint id, const GLushort *addr))
GLATTER_INLINE_OR_NOT void glatter_glVariantusvEXT_debug(GLuint id, const GLushort *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantusvEXT, "(%u, %p)", (unsigned int)id, (void*)addr)
    glatter_glVariantusvEXT(id, addr);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVariantusvEXT_defined
#endif
#ifndef glWriteMaskEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWriteMaskEXT, (res, in, outX, outY, outZ, outW), (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW))
GLATTER_INLINE_OR_NOT void glatter_glWriteMaskEXT_debug(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWriteMaskEXT, "(%u, %u, %s, %s, %s, %s)", (unsigned int)res, (unsigned int)in, enum_to_string_GL(outX), enum_to_string_GL(outY), enum_to_string_GL(outZ), enum_to_string_GL(outW))
    glatter_glWriteMaskEXT(res, in, outX, outY, outZ, outW);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWriteMaskEXT_defined
#endif
#endif // defined(GL_EXT_vertex_shader)
#if defined(GL_EXT_vertex_weighting)
#ifndef glVertexWeightPointerEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexWeightPointerEXT, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexWeightPointerEXT_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightPointerEXT, "(%d, %s, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexWeightPointerEXT(size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexWeightPointerEXT_defined
#endif
#ifndef glVertexWeightfEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexWeightfEXT, (weight), (GLfloat weight))
GLATTER_INLINE_OR_NOT void glatter_glVertexWeightfEXT_debug(GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightfEXT, "(%f)", (float)weight)
    glatter_glVertexWeightfEXT(weight);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexWeightfEXT_defined
#endif
#ifndef glVertexWeightfvEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexWeightfvEXT, (weight), (const GLfloat *weight))
GLATTER_INLINE_OR_NOT void glatter_glVertexWeightfvEXT_debug(const GLfloat *weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightfvEXT, "(%p)", (void*)weight)
    glatter_glVertexWeightfvEXT(weight);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexWeightfvEXT_defined
#endif
#endif // defined(GL_EXT_vertex_weighting)
#if defined(GL_EXT_win32_keyed_mutex)
#ifndef glAcquireKeyedMutexWin32EXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glAcquireKeyedMutexWin32EXT, (memory, key, timeout), (GLuint memory, GLuint64 key, GLuint timeout))
GLATTER_INLINE_OR_NOT GLboolean glatter_glAcquireKeyedMutexWin32EXT_debug(GLuint memory, GLuint64 key, GLuint timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAcquireKeyedMutexWin32EXT, "(%u, %s, %u)", (unsigned int)memory, GET_PRS(key), (unsigned int)timeout)
    GLboolean rval = glatter_glAcquireKeyedMutexWin32EXT(memory, key, timeout);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glAcquireKeyedMutexWin32EXT_defined
#endif
#ifndef glReleaseKeyedMutexWin32EXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glReleaseKeyedMutexWin32EXT, (memory, key), (GLuint memory, GLuint64 key))
GLATTER_INLINE_OR_NOT GLboolean glatter_glReleaseKeyedMutexWin32EXT_debug(GLuint memory, GLuint64 key, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReleaseKeyedMutexWin32EXT, "(%u, %s)", (unsigned int)memory, GET_PRS(key))
    GLboolean rval = glatter_glReleaseKeyedMutexWin32EXT(memory, key);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glReleaseKeyedMutexWin32EXT_defined
#endif
#endif // defined(GL_EXT_win32_keyed_mutex)
#if defined(GL_EXT_window_rectangles)
#ifndef glWindowRectanglesEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowRectanglesEXT, (mode, count, box), (GLenum mode, GLsizei count, const GLint *box))
GLATTER_INLINE_OR_NOT void glatter_glWindowRectanglesEXT_debug(GLenum mode, GLsizei count, const GLint *box, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowRectanglesEXT, "(%s, %d, %p)", enum_to_string_GL(mode), (int)count, (void*)box)
    glatter_glWindowRectanglesEXT(mode, count, box);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowRectanglesEXT_defined
#endif
#endif // defined(GL_EXT_window_rectangles)
#if defined(GL_EXT_x11_sync_object)
#ifndef glImportSyncEXT_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLsync, APIENTRY, glImportSyncEXT, (external_sync_type, external_sync, flags), (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags))
GLATTER_INLINE_OR_NOT GLsync glatter_glImportSyncEXT_debug(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportSyncEXT, "(%s, %s, %u)", enum_to_string_GL(external_sync_type), GET_PRS(external_sync), (unsigned int)flags)
    GLsync rval = glatter_glImportSyncEXT(external_sync_type, external_sync, flags);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glImportSyncEXT_defined
#endif
#endif // defined(GL_EXT_x11_sync_object)
#if defined(GL_GREMEDY_frame_terminator)
#ifndef glFrameTerminatorGREMEDY_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFrameTerminatorGREMEDY, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glFrameTerminatorGREMEDY_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrameTerminatorGREMEDY, "()")
    glatter_glFrameTerminatorGREMEDY();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFrameTerminatorGREMEDY_defined
#endif
#endif // defined(GL_GREMEDY_frame_terminator)
#if defined(GL_GREMEDY_string_marker)
#ifndef glStringMarkerGREMEDY_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStringMarkerGREMEDY, (len, string), (GLsizei len, const void *string))
GLATTER_INLINE_OR_NOT void glatter_glStringMarkerGREMEDY_debug(GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStringMarkerGREMEDY, "(%d, %p)", (int)len, (void*)string)
    glatter_glStringMarkerGREMEDY(len, string);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStringMarkerGREMEDY_defined
#endif
#endif // defined(GL_GREMEDY_string_marker)
#if defined(GL_HP_image_transform)
#ifndef glGetImageTransformParameterfvHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetImageTransformParameterfvHP, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetImageTransformParameterfvHP_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageTransformParameterfvHP, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetImageTransformParameterfvHP(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetImageTransformParameterfvHP_defined
#endif
#ifndef glGetImageTransformParameterivHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetImageTransformParameterivHP, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetImageTransformParameterivHP_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageTransformParameterivHP, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetImageTransformParameterivHP(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetImageTransformParameterivHP_defined
#endif
#ifndef glImageTransformParameterfHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImageTransformParameterfHP, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glImageTransformParameterfHP_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterfHP, "(%s, %s, %f)", enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glImageTransformParameterfHP(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImageTransformParameterfHP_defined
#endif
#ifndef glImageTransformParameterfvHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImageTransformParameterfvHP, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glImageTransformParameterfvHP_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterfvHP, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glImageTransformParameterfvHP(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImageTransformParameterfvHP_defined
#endif
#ifndef glImageTransformParameteriHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImageTransformParameteriHP, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glImageTransformParameteriHP_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameteriHP, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glImageTransformParameteriHP(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImageTransformParameteriHP_defined
#endif
#ifndef glImageTransformParameterivHP_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glImageTransformParameterivHP, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glImageTransformParameterivHP_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterivHP, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glImageTransformParameterivHP(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glImageTransformParameterivHP_defined
#endif
#endif // defined(GL_HP_image_transform)
#if defined(GL_IBM_multimode_draw_arrays)
#ifndef glMultiModeDrawArraysIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiModeDrawArraysIBM, (mode, first, count, primcount, modestride), (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride))
GLATTER_INLINE_OR_NOT void glatter_glMultiModeDrawArraysIBM_debug(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiModeDrawArraysIBM, "(%p, %p, %p, %d, %d)", (void*)mode, (void*)first, (void*)count, (int)primcount, (int)modestride)
    glatter_glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiModeDrawArraysIBM_defined
#endif
#ifndef glMultiModeDrawElementsIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiModeDrawElementsIBM, (mode, count, type, indices, primcount, modestride), (const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride))
GLATTER_INLINE_OR_NOT void glatter_glMultiModeDrawElementsIBM_debug(const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiModeDrawElementsIBM, "(%p, %p, %s, %p, %d, %d)", (void*)mode, (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount, (int)modestride)
    glatter_glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiModeDrawElementsIBM_defined
#endif
#endif // defined(GL_IBM_multimode_draw_arrays)
#if defined(GL_IBM_static_data)
#ifndef glFlushStaticDataIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushStaticDataIBM, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glFlushStaticDataIBM_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushStaticDataIBM, "(%s)", enum_to_string_GL(target))
    glatter_glFlushStaticDataIBM(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushStaticDataIBM_defined
#endif
#endif // defined(GL_IBM_static_data)
#if defined(GL_IBM_vertex_array_lists)
#ifndef glColorPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glColorPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointerListIBM, "(%d, %s, %d, %p, %d)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glColorPointerListIBM(size, type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorPointerListIBM_defined
#endif
#ifndef glEdgeFlagPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEdgeFlagPointerListIBM, (stride, pointer, ptrstride), (GLint stride, const GLboolean **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glEdgeFlagPointerListIBM_debug(GLint stride, const GLboolean **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagPointerListIBM, "(%d, %p, %d)", (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEdgeFlagPointerListIBM_defined
#endif
#ifndef glFogCoordPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointerListIBM, "(%s, %d, %p, %d)", enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordPointerListIBM_defined
#endif
#ifndef glIndexPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glIndexPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexPointerListIBM, "(%s, %d, %p, %d)", enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glIndexPointerListIBM(type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexPointerListIBM_defined
#endif
#ifndef glNormalPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glNormalPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointerListIBM, "(%s, %d, %p, %d)", enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glNormalPointerListIBM(type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalPointerListIBM_defined
#endif
#ifndef glSecondaryColorPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointerListIBM, "(%d, %s, %d, %p, %d)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorPointerListIBM_defined
#endif
#ifndef glTexCoordPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointerListIBM, "(%d, %s, %d, %p, %d)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordPointerListIBM_defined
#endif
#ifndef glVertexPointerListIBM_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_INLINE_OR_NOT void glatter_glVertexPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointerListIBM, "(%d, %s, %d, %p, %d)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexPointerListIBM_defined
#endif
#endif // defined(GL_IBM_vertex_array_lists)
#if defined(GL_INGR_blend_func_separate)
#ifndef glBlendFuncSeparateINGR_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparateINGR, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparateINGR_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateINGR, "(%s, %s, %s, %s)", enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparateINGR_defined
#endif
#endif // defined(GL_INGR_blend_func_separate)
#if defined(GL_INTEL_framebuffer_CMAA)
#ifndef glApplyFramebufferAttachmentCMAAINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glApplyFramebufferAttachmentCMAAINTEL, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glApplyFramebufferAttachmentCMAAINTEL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyFramebufferAttachmentCMAAINTEL, "()")
    glatter_glApplyFramebufferAttachmentCMAAINTEL();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glApplyFramebufferAttachmentCMAAINTEL_defined
#endif
#endif // defined(GL_INTEL_framebuffer_CMAA)
#if defined(GL_INTEL_map_texture)
#ifndef glMapTexture2DINTEL_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapTexture2DINTEL, (texture, level, access, stride, layout), (GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout))
GLATTER_INLINE_OR_NOT void * glatter_glMapTexture2DINTEL_debug(GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapTexture2DINTEL, "(%u, %d, %u, %p, %p)", (unsigned int)texture, (int)level, (unsigned int)access, (void*)stride, (void*)layout)
    void * rval = glatter_glMapTexture2DINTEL(texture, level, access, stride, layout);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapTexture2DINTEL_defined
#endif
#ifndef glSyncTextureINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSyncTextureINTEL, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glSyncTextureINTEL_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSyncTextureINTEL, "(%u)", (unsigned int)texture)
    glatter_glSyncTextureINTEL(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSyncTextureINTEL_defined
#endif
#ifndef glUnmapTexture2DINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUnmapTexture2DINTEL, (texture, level), (GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glUnmapTexture2DINTEL_debug(GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapTexture2DINTEL, "(%u, %d)", (unsigned int)texture, (int)level)
    glatter_glUnmapTexture2DINTEL(texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUnmapTexture2DINTEL_defined
#endif
#endif // defined(GL_INTEL_map_texture)
#if defined(GL_INTEL_parallel_arrays)
#ifndef glColorPointervINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glColorPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointervINTEL, "(%d, %s, %p)", (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glColorPointervINTEL(size, type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorPointervINTEL_defined
#endif
#ifndef glNormalPointervINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalPointervINTEL, (type, pointer), (GLenum type, const void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glNormalPointervINTEL_debug(GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointervINTEL, "(%s, %p)", enum_to_string_GL(type), (void*)pointer)
    glatter_glNormalPointervINTEL(type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalPointervINTEL_defined
#endif
#ifndef glTexCoordPointervINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointervINTEL, "(%d, %s, %p)", (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glTexCoordPointervINTEL(size, type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordPointervINTEL_defined
#endif
#ifndef glVertexPointervINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointervINTEL, "(%d, %s, %p)", (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glVertexPointervINTEL(size, type, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexPointervINTEL_defined
#endif
#endif // defined(GL_INTEL_parallel_arrays)
#if defined(GL_INTEL_performance_query)
#ifndef glBeginPerfQueryINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_INLINE_OR_NOT void glatter_glBeginPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfQueryINTEL, "(%u)", (unsigned int)queryHandle)
    glatter_glBeginPerfQueryINTEL(queryHandle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginPerfQueryINTEL_defined
#endif
#ifndef glCreatePerfQueryINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreatePerfQueryINTEL, (queryId, queryHandle), (GLuint queryId, GLuint *queryHandle))
GLATTER_INLINE_OR_NOT void glatter_glCreatePerfQueryINTEL_debug(GLuint queryId, GLuint *queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreatePerfQueryINTEL, "(%u, %p)", (unsigned int)queryId, (void*)queryHandle)
    glatter_glCreatePerfQueryINTEL(queryId, queryHandle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreatePerfQueryINTEL_defined
#endif
#ifndef glDeletePerfQueryINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeletePerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_INLINE_OR_NOT void glatter_glDeletePerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfQueryINTEL, "(%u)", (unsigned int)queryHandle)
    glatter_glDeletePerfQueryINTEL(queryHandle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeletePerfQueryINTEL_defined
#endif
#ifndef glEndPerfQueryINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_INLINE_OR_NOT void glatter_glEndPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfQueryINTEL, "(%u)", (unsigned int)queryHandle)
    glatter_glEndPerfQueryINTEL(queryHandle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndPerfQueryINTEL_defined
#endif
#ifndef glGetFirstPerfQueryIdINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFirstPerfQueryIdINTEL, (queryId), (GLuint *queryId))
GLATTER_INLINE_OR_NOT void glatter_glGetFirstPerfQueryIdINTEL_debug(GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFirstPerfQueryIdINTEL, "(%p)", (void*)queryId)
    glatter_glGetFirstPerfQueryIdINTEL(queryId);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFirstPerfQueryIdINTEL_defined
#endif
#ifndef glGetNextPerfQueryIdINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNextPerfQueryIdINTEL, (queryId, nextQueryId), (GLuint queryId, GLuint *nextQueryId))
GLATTER_INLINE_OR_NOT void glatter_glGetNextPerfQueryIdINTEL_debug(GLuint queryId, GLuint *nextQueryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNextPerfQueryIdINTEL, "(%u, %p)", (unsigned int)queryId, (void*)nextQueryId)
    glatter_glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNextPerfQueryIdINTEL_defined
#endif
#ifndef glGetPerfCounterInfoINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfCounterInfoINTEL, (queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue), (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfCounterInfoINTEL_debug(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfCounterInfoINTEL, "(%u, %u, %u, %p, %u, %p, %p, %p, %p, %p, %p)", (unsigned int)queryId, (unsigned int)counterId, (unsigned int)counterNameLength, (void*)counterName, (unsigned int)counterDescLength, (void*)counterDesc, (void*)counterOffset, (void*)counterDataSize, (void*)counterTypeEnum, (void*)counterDataTypeEnum, (void*)rawCounterMaxValue)
    glatter_glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfCounterInfoINTEL_defined
#endif
#ifndef glGetPerfQueryDataINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfQueryDataINTEL, (queryHandle, flags, dataSize, data, bytesWritten), (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfQueryDataINTEL_debug(GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryDataINTEL, "(%u, %u, %d, %p, %p)", (unsigned int)queryHandle, (unsigned int)flags, (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfQueryDataINTEL_defined
#endif
#ifndef glGetPerfQueryIdByNameINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfQueryIdByNameINTEL, (queryName, queryId), (GLchar *queryName, GLuint *queryId))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfQueryIdByNameINTEL_debug(GLchar *queryName, GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryIdByNameINTEL, "(%p, %p)", (void*)queryName, (void*)queryId)
    glatter_glGetPerfQueryIdByNameINTEL(queryName, queryId);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfQueryIdByNameINTEL_defined
#endif
#ifndef glGetPerfQueryInfoINTEL_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPerfQueryInfoINTEL, (queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask), (GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask))
GLATTER_INLINE_OR_NOT void glatter_glGetPerfQueryInfoINTEL_debug(GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryInfoINTEL, "(%u, %u, %p, %p, %p, %p, %p)", (unsigned int)queryId, (unsigned int)queryNameLength, (void*)queryName, (void*)dataSize, (void*)noCounters, (void*)noInstances, (void*)capsMask)
    glatter_glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPerfQueryInfoINTEL_defined
#endif
#endif // defined(GL_INTEL_performance_query)
#if defined(GL_KHR_blend_equation_advanced)
#ifndef glBlendBarrierKHR_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendBarrierKHR, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glBlendBarrierKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierKHR, "()")
    glatter_glBlendBarrierKHR();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendBarrierKHR_defined
#endif
#endif // defined(GL_KHR_blend_equation_advanced)
#if defined(GL_KHR_parallel_shader_compile)
#ifndef glMaxShaderCompilerThreadsKHR_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMaxShaderCompilerThreadsKHR, (count), (GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glMaxShaderCompilerThreadsKHR_debug(GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaxShaderCompilerThreadsKHR, "(%u)", (unsigned int)count)
    glatter_glMaxShaderCompilerThreadsKHR(count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMaxShaderCompilerThreadsKHR_defined
#endif
#endif // defined(GL_KHR_parallel_shader_compile)
#if defined(GL_MESA_framebuffer_flip_y)
#ifndef glFramebufferParameteriMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferParameteriMESA, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferParameteriMESA_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferParameteriMESA, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glFramebufferParameteriMESA(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferParameteriMESA_defined
#endif
#ifndef glGetFramebufferParameterivMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferParameterivMESA, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferParameterivMESA_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameterivMESA, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameterivMESA(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferParameterivMESA_defined
#endif
#endif // defined(GL_MESA_framebuffer_flip_y)
#if defined(GL_MESA_resize_buffers)
#ifndef glResizeBuffersMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResizeBuffersMESA, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glResizeBuffersMESA_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResizeBuffersMESA, "()")
    glatter_glResizeBuffersMESA();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResizeBuffersMESA_defined
#endif
#endif // defined(GL_MESA_resize_buffers)
#if defined(GL_MESA_window_pos)
#ifndef glWindowPos2dMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2dMESA, (x, y), (GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2dMESA_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dMESA, "(%f, %f)", (double)x, (double)y)
    glatter_glWindowPos2dMESA(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2dMESA_defined
#endif
#ifndef glWindowPos2dvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2dvMESA, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dvMESA, "(%p)", (void*)v)
    glatter_glWindowPos2dvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2dvMESA_defined
#endif
#ifndef glWindowPos2fMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2fMESA, (x, y), (GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2fMESA_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fMESA, "(%f, %f)", (float)x, (float)y)
    glatter_glWindowPos2fMESA(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2fMESA_defined
#endif
#ifndef glWindowPos2fvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2fvMESA, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fvMESA, "(%p)", (void*)v)
    glatter_glWindowPos2fvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2fvMESA_defined
#endif
#ifndef glWindowPos2iMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2iMESA, (x, y), (GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2iMESA_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iMESA, "(%d, %d)", (int)x, (int)y)
    glatter_glWindowPos2iMESA(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2iMESA_defined
#endif
#ifndef glWindowPos2ivMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2ivMESA, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2ivMESA, "(%p)", (void*)v)
    glatter_glWindowPos2ivMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2ivMESA_defined
#endif
#ifndef glWindowPos2sMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2sMESA, (x, y), (GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2sMESA_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sMESA, "(%hi, %hi)", (short)x, (short)y)
    glatter_glWindowPos2sMESA(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2sMESA_defined
#endif
#ifndef glWindowPos2svMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2svMESA, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2svMESA, "(%p)", (void*)v)
    glatter_glWindowPos2svMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2svMESA_defined
#endif
#ifndef glWindowPos3dMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3dMESA, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3dMESA_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dMESA, "(%f, %f, %f)", (double)x, (double)y, (double)z)
    glatter_glWindowPos3dMESA(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3dMESA_defined
#endif
#ifndef glWindowPos3dvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3dvMESA, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dvMESA, "(%p)", (void*)v)
    glatter_glWindowPos3dvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3dvMESA_defined
#endif
#ifndef glWindowPos3fMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3fMESA, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3fMESA_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fMESA, "(%f, %f, %f)", (float)x, (float)y, (float)z)
    glatter_glWindowPos3fMESA(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3fMESA_defined
#endif
#ifndef glWindowPos3fvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3fvMESA, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fvMESA, "(%p)", (void*)v)
    glatter_glWindowPos3fvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3fvMESA_defined
#endif
#ifndef glWindowPos3iMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3iMESA, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3iMESA_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iMESA, "(%d, %d, %d)", (int)x, (int)y, (int)z)
    glatter_glWindowPos3iMESA(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3iMESA_defined
#endif
#ifndef glWindowPos3ivMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3ivMESA, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3ivMESA, "(%p)", (void*)v)
    glatter_glWindowPos3ivMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3ivMESA_defined
#endif
#ifndef glWindowPos3sMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3sMESA, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3sMESA_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sMESA, "(%hi, %hi, %hi)", (short)x, (short)y, (short)z)
    glatter_glWindowPos3sMESA(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3sMESA_defined
#endif
#ifndef glWindowPos3svMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3svMESA, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3svMESA, "(%p)", (void*)v)
    glatter_glWindowPos3svMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3svMESA_defined
#endif
#ifndef glWindowPos4dMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4dMESA, (x, y, z, w), (GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4dMESA_debug(GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4dMESA, "(%f, %f, %f, %f)", (double)x, (double)y, (double)z, (double)w)
    glatter_glWindowPos4dMESA(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4dMESA_defined
#endif
#ifndef glWindowPos4dvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4dvMESA, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4dvMESA, "(%p)", (void*)v)
    glatter_glWindowPos4dvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4dvMESA_defined
#endif
#ifndef glWindowPos4fMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4fMESA, (x, y, z, w), (GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4fMESA_debug(GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4fMESA, "(%f, %f, %f, %f)", (float)x, (float)y, (float)z, (float)w)
    glatter_glWindowPos4fMESA(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4fMESA_defined
#endif
#ifndef glWindowPos4fvMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4fvMESA, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4fvMESA, "(%p)", (void*)v)
    glatter_glWindowPos4fvMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4fvMESA_defined
#endif
#ifndef glWindowPos4iMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4iMESA, (x, y, z, w), (GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4iMESA_debug(GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4iMESA, "(%d, %d, %d, %d)", (int)x, (int)y, (int)z, (int)w)
    glatter_glWindowPos4iMESA(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4iMESA_defined
#endif
#ifndef glWindowPos4ivMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4ivMESA, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4ivMESA, "(%p)", (void*)v)
    glatter_glWindowPos4ivMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4ivMESA_defined
#endif
#ifndef glWindowPos4sMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4sMESA, (x, y, z, w), (GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4sMESA_debug(GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4sMESA, "(%hi, %hi, %hi, %hi)", (short)x, (short)y, (short)z, (short)w)
    glatter_glWindowPos4sMESA(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4sMESA_defined
#endif
#ifndef glWindowPos4svMESA_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos4svMESA, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos4svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4svMESA, "(%p)", (void*)v)
    glatter_glWindowPos4svMESA(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos4svMESA_defined
#endif
#endif // defined(GL_MESA_window_pos)
#if defined(GL_NVX_conditional_render)
#ifndef glBeginConditionalRenderNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginConditionalRenderNVX, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBeginConditionalRenderNVX_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNVX, "(%u)", (unsigned int)id)
    glatter_glBeginConditionalRenderNVX(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginConditionalRenderNVX_defined
#endif
#ifndef glEndConditionalRenderNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndConditionalRenderNVX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndConditionalRenderNVX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNVX, "()")
    glatter_glEndConditionalRenderNVX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndConditionalRenderNVX_defined
#endif
#endif // defined(GL_NVX_conditional_render)
#if defined(GL_NVX_gpu_multicast2)
#ifndef glAsyncCopyBufferSubDataNVX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glAsyncCopyBufferSubDataNVX, (waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray), (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray))
GLATTER_INLINE_OR_NOT GLuint glatter_glAsyncCopyBufferSubDataNVX_debug(GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAsyncCopyBufferSubDataNVX, "(%d, %p, %p, %u, %u, %u, %u, %s, %s, %s, %d, %p, %p)", (int)waitSemaphoreCount, (void*)waitSemaphoreArray, (void*)fenceValueArray, (unsigned int)readGpu, (unsigned int)writeGpuMask, (unsigned int)readBuffer, (unsigned int)writeBuffer, GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size), (int)signalSemaphoreCount, (void*)signalSemaphoreArray, (void*)signalValueArray)
    GLuint rval = glatter_glAsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glAsyncCopyBufferSubDataNVX_defined
#endif
#ifndef glAsyncCopyImageSubDataNVX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glAsyncCopyImageSubDataNVX, (waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray), (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray))
GLATTER_INLINE_OR_NOT GLuint glatter_glAsyncCopyImageSubDataNVX_debug(GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAsyncCopyImageSubDataNVX, "(%d, %p, %p, %u, %u, %u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d, %d, %p, %p)", (int)waitSemaphoreCount, (void*)waitSemaphoreArray, (void*)waitValueArray, (unsigned int)srcGpu, (unsigned int)dstGpuMask, (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth, (int)signalSemaphoreCount, (void*)signalSemaphoreArray, (void*)signalValueArray)
    GLuint rval = glatter_glAsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glAsyncCopyImageSubDataNVX_defined
#endif
#ifndef glMulticastScissorArrayvNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastScissorArrayvNVX, (gpu, first, count, v), (GLuint gpu, GLuint first, GLsizei count, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMulticastScissorArrayvNVX_debug(GLuint gpu, GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastScissorArrayvNVX, "(%u, %u, %d, %p)", (unsigned int)gpu, (unsigned int)first, (int)count, (void*)v)
    glatter_glMulticastScissorArrayvNVX(gpu, first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastScissorArrayvNVX_defined
#endif
#ifndef glMulticastViewportArrayvNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastViewportArrayvNVX, (gpu, first, count, v), (GLuint gpu, GLuint first, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMulticastViewportArrayvNVX_debug(GLuint gpu, GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastViewportArrayvNVX, "(%u, %u, %d, %p)", (unsigned int)gpu, (unsigned int)first, (int)count, (void*)v)
    glatter_glMulticastViewportArrayvNVX(gpu, first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastViewportArrayvNVX_defined
#endif
#ifndef glMulticastViewportPositionWScaleNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastViewportPositionWScaleNVX, (gpu, index, xcoeff, ycoeff), (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff))
GLATTER_INLINE_OR_NOT void glatter_glMulticastViewportPositionWScaleNVX_debug(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastViewportPositionWScaleNVX, "(%u, %u, %f, %f)", (unsigned int)gpu, (unsigned int)index, (float)xcoeff, (float)ycoeff)
    glatter_glMulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastViewportPositionWScaleNVX_defined
#endif
#ifndef glUploadGpuMaskNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUploadGpuMaskNVX, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glUploadGpuMaskNVX_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUploadGpuMaskNVX, "(%u)", (unsigned int)mask)
    glatter_glUploadGpuMaskNVX(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUploadGpuMaskNVX_defined
#endif
#endif // defined(GL_NVX_gpu_multicast2)
#if defined(GL_NVX_linked_gpu_multicast)
#ifndef glLGPUCopyImageSubDataNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLGPUCopyImageSubDataNVX, (sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glLGPUCopyImageSubDataNVX_debug(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLGPUCopyImageSubDataNVX, "(%u, %u, %u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)sourceGpu, (unsigned int)destinationGpuMask, (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srxY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    glatter_glLGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLGPUCopyImageSubDataNVX_defined
#endif
#ifndef glLGPUInterlockNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLGPUInterlockNVX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glLGPUInterlockNVX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLGPUInterlockNVX, "()")
    glatter_glLGPUInterlockNVX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLGPUInterlockNVX_defined
#endif
#ifndef glLGPUNamedBufferSubDataNVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLGPUNamedBufferSubDataNVX, (gpuMask, buffer, offset, size, data), (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glLGPUNamedBufferSubDataNVX_debug(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLGPUNamedBufferSubDataNVX, "(%u, %u, %s, %s, %p)", (unsigned int)gpuMask, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glLGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLGPUNamedBufferSubDataNVX_defined
#endif
#endif // defined(GL_NVX_linked_gpu_multicast)
#if defined(GL_NVX_progress_fence)
#ifndef glClientWaitSemaphoreui64NVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClientWaitSemaphoreui64NVX, (fenceObjectCount, semaphoreArray, fenceValueArray), (GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray))
GLATTER_INLINE_OR_NOT void glatter_glClientWaitSemaphoreui64NVX_debug(GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSemaphoreui64NVX, "(%d, %p, %p)", (int)fenceObjectCount, (void*)semaphoreArray, (void*)fenceValueArray)
    glatter_glClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClientWaitSemaphoreui64NVX_defined
#endif
#ifndef glCreateProgressFenceNVX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glCreateProgressFenceNVX, (), (void))
GLATTER_INLINE_OR_NOT GLuint glatter_glCreateProgressFenceNVX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgressFenceNVX, "()")
    GLuint rval = glatter_glCreateProgressFenceNVX();
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateProgressFenceNVX_defined
#endif
#ifndef glSignalSemaphoreui64NVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSignalSemaphoreui64NVX, (signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray), (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray))
GLATTER_INLINE_OR_NOT void glatter_glSignalSemaphoreui64NVX_debug(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSignalSemaphoreui64NVX, "(%u, %d, %p, %p)", (unsigned int)signalGpu, (int)fenceObjectCount, (void*)semaphoreArray, (void*)fenceValueArray)
    glatter_glSignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSignalSemaphoreui64NVX_defined
#endif
#ifndef glWaitSemaphoreui64NVX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWaitSemaphoreui64NVX, (waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray), (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray))
GLATTER_INLINE_OR_NOT void glatter_glWaitSemaphoreui64NVX_debug(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSemaphoreui64NVX, "(%u, %d, %p, %p)", (unsigned int)waitGpu, (int)fenceObjectCount, (void*)semaphoreArray, (void*)fenceValueArray)
    glatter_glWaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWaitSemaphoreui64NVX_defined
#endif
#endif // defined(GL_NVX_progress_fence)
#if defined(GL_NV_alpha_to_coverage_dither_control)
#ifndef glAlphaToCoverageDitherControlNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAlphaToCoverageDitherControlNV, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glAlphaToCoverageDitherControlNV_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaToCoverageDitherControlNV, "(%s)", enum_to_string_GL(mode))
    glatter_glAlphaToCoverageDitherControlNV(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAlphaToCoverageDitherControlNV_defined
#endif
#endif // defined(GL_NV_alpha_to_coverage_dither_control)
#if defined(GL_NV_bindless_multi_draw_indirect)
#ifndef glMultiDrawArraysIndirectBindlessNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirectBindlessNV, (mode, indirect, drawCount, stride, vertexBufferCount), (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirectBindlessNV_debug(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectBindlessNV, "(%s, %p, %d, %d, %d)", enum_to_string_GL(mode), (void*)indirect, (int)drawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirectBindlessNV_defined
#endif
#ifndef glMultiDrawElementsIndirectBindlessNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirectBindlessNV, (mode, type, indirect, drawCount, stride, vertexBufferCount), (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirectBindlessNV_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectBindlessNV, "(%s, %s, %p, %d, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawElementsIndirectBindlessNV(mode, type, indirect, drawCount, stride, vertexBufferCount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirectBindlessNV_defined
#endif
#endif // defined(GL_NV_bindless_multi_draw_indirect)
#if defined(GL_NV_bindless_multi_draw_indirect_count)
#ifndef glMultiDrawArraysIndirectBindlessCountNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirectBindlessCountNV, (mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount), (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirectBindlessCountNV_debug(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectBindlessCountNV, "(%s, %p, %d, %d, %d, %d)", enum_to_string_GL(mode), (void*)indirect, (int)drawCount, (int)maxDrawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirectBindlessCountNV_defined
#endif
#ifndef glMultiDrawElementsIndirectBindlessCountNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirectBindlessCountNV, (mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount), (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirectBindlessCountNV_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectBindlessCountNV, "(%s, %s, %p, %d, %d, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawCount, (int)maxDrawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawElementsIndirectBindlessCountNV(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirectBindlessCountNV_defined
#endif
#endif // defined(GL_NV_bindless_multi_draw_indirect_count)
#if defined(GL_NV_bindless_texture)
#ifndef glGetImageHandleNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetImageHandleNV, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetImageHandleNV_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleNV, "(%u, %d, %u, %d, %s)", (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleNV(texture, level, layered, layer, format);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetImageHandleNV_defined
#endif
#ifndef glGetTextureHandleNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetTextureHandleNV, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetTextureHandleNV_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleNV, "(%u)", (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleNV(texture);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetTextureHandleNV_defined
#endif
#ifndef glGetTextureSamplerHandleNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint64, APIENTRY, glGetTextureSamplerHandleNV, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_INLINE_OR_NOT GLuint64 glatter_glGetTextureSamplerHandleNV_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleNV, "(%u, %u)", (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleNV(texture, sampler);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetTextureSamplerHandleNV_defined
#endif
#ifndef glIsImageHandleResidentNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsImageHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsImageHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentNV, "(%s)", GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentNV(handle);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsImageHandleResidentNV_defined
#endif
#ifndef glIsTextureHandleResidentNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentNV, "(%s)", GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentNV(handle);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsTextureHandleResidentNV_defined
#endif
#ifndef glMakeImageHandleNonResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeImageHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeImageHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentNV, "(%s)", GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentNV(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeImageHandleNonResidentNV_defined
#endif
#ifndef glMakeImageHandleResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeImageHandleResidentNV, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_INLINE_OR_NOT void glatter_glMakeImageHandleResidentNV_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentNV, "(%s, %s)", GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentNV(handle, access);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeImageHandleResidentNV_defined
#endif
#ifndef glMakeTextureHandleNonResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeTextureHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeTextureHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentNV, "(%s)", GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentNV(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeTextureHandleNonResidentNV_defined
#endif
#ifndef glMakeTextureHandleResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_INLINE_OR_NOT void glatter_glMakeTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentNV, "(%s)", GET_PRS(handle))
    glatter_glMakeTextureHandleResidentNV(handle);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeTextureHandleResidentNV_defined
#endif
#ifndef glProgramUniformHandleui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformHandleui64NV, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformHandleui64NV_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64NV, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64NV(program, location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformHandleui64NV_defined
#endif
#ifndef glProgramUniformHandleui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformHandleui64vNV, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformHandleui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vNV(program, location, count, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformHandleui64vNV_defined
#endif
#ifndef glUniformHandleui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformHandleui64NV, (location, value), (GLint location, GLuint64 value))
GLATTER_INLINE_OR_NOT void glatter_glUniformHandleui64NV_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64NV, "(%d, %s)", (int)location, GET_PRS(value))
    glatter_glUniformHandleui64NV(location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformHandleui64NV_defined
#endif
#ifndef glUniformHandleui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformHandleui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformHandleui64vNV_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformHandleui64vNV_defined
#endif
#endif // defined(GL_NV_bindless_texture)
#if defined(GL_NV_blend_equation_advanced)
#ifndef glBlendBarrierNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendBarrierNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glBlendBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierNV, "()")
    glatter_glBlendBarrierNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendBarrierNV_defined
#endif
#ifndef glBlendParameteriNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendParameteriNV, (pname, value), (GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glBlendParameteriNV_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendParameteriNV, "(%s, %d)", enum_to_string_GL(pname), (int)value)
    glatter_glBlendParameteriNV(pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendParameteriNV_defined
#endif
#endif // defined(GL_NV_blend_equation_advanced)
#if defined(GL_NV_clip_space_w_scaling)
#ifndef glViewportPositionWScaleNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glViewportPositionWScaleNV, (index, xcoeff, ycoeff), (GLuint index, GLfloat xcoeff, GLfloat ycoeff))
GLATTER_INLINE_OR_NOT void glatter_glViewportPositionWScaleNV_debug(GLuint index, GLfloat xcoeff, GLfloat ycoeff, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportPositionWScaleNV, "(%u, %f, %f)", (unsigned int)index, (float)xcoeff, (float)ycoeff)
    glatter_glViewportPositionWScaleNV(index, xcoeff, ycoeff);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glViewportPositionWScaleNV_defined
#endif
#endif // defined(GL_NV_clip_space_w_scaling)
#if defined(GL_NV_command_list)
#ifndef glCallCommandListNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCallCommandListNV, (list), (GLuint list))
GLATTER_INLINE_OR_NOT void glatter_glCallCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCallCommandListNV, "(%u)", (unsigned int)list)
    glatter_glCallCommandListNV(list);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCallCommandListNV_defined
#endif
#ifndef glCommandListSegmentsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCommandListSegmentsNV, (list, segments), (GLuint list, GLuint segments))
GLATTER_INLINE_OR_NOT void glatter_glCommandListSegmentsNV_debug(GLuint list, GLuint segments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCommandListSegmentsNV, "(%u, %u)", (unsigned int)list, (unsigned int)segments)
    glatter_glCommandListSegmentsNV(list, segments);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCommandListSegmentsNV_defined
#endif
#ifndef glCompileCommandListNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompileCommandListNV, (list), (GLuint list))
GLATTER_INLINE_OR_NOT void glatter_glCompileCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileCommandListNV, "(%u)", (unsigned int)list)
    glatter_glCompileCommandListNV(list);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompileCommandListNV_defined
#endif
#ifndef glCreateCommandListsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateCommandListsNV, (n, lists), (GLsizei n, GLuint *lists))
GLATTER_INLINE_OR_NOT void glatter_glCreateCommandListsNV_debug(GLsizei n, GLuint *lists, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateCommandListsNV, "(%d, %p)", (int)n, (void*)lists)
    glatter_glCreateCommandListsNV(n, lists);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateCommandListsNV_defined
#endif
#ifndef glCreateStatesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateStatesNV, (n, states), (GLsizei n, GLuint *states))
GLATTER_INLINE_OR_NOT void glatter_glCreateStatesNV_debug(GLsizei n, GLuint *states, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateStatesNV, "(%d, %p)", (int)n, (void*)states)
    glatter_glCreateStatesNV(n, states);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateStatesNV_defined
#endif
#ifndef glDeleteCommandListsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteCommandListsNV, (n, lists), (GLsizei n, const GLuint *lists))
GLATTER_INLINE_OR_NOT void glatter_glDeleteCommandListsNV_debug(GLsizei n, const GLuint *lists, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteCommandListsNV, "(%d, %p)", (int)n, (void*)lists)
    glatter_glDeleteCommandListsNV(n, lists);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteCommandListsNV_defined
#endif
#ifndef glDeleteStatesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteStatesNV, (n, states), (GLsizei n, const GLuint *states))
GLATTER_INLINE_OR_NOT void glatter_glDeleteStatesNV_debug(GLsizei n, const GLuint *states, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteStatesNV, "(%d, %p)", (int)n, (void*)states)
    glatter_glDeleteStatesNV(n, states);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteStatesNV_defined
#endif
#ifndef glDrawCommandsAddressNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawCommandsAddressNV, (primitiveMode, indirects, sizes, count), (GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glDrawCommandsAddressNV_debug(GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsAddressNV, "(%s, %p, %p, %u)", enum_to_string_GL(primitiveMode), (void*)indirects, (void*)sizes, (unsigned int)count)
    glatter_glDrawCommandsAddressNV(primitiveMode, indirects, sizes, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawCommandsAddressNV_defined
#endif
#ifndef glDrawCommandsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawCommandsNV, (primitiveMode, buffer, indirects, sizes, count), (GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glDrawCommandsNV_debug(GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsNV, "(%s, %u, %p, %p, %u)", enum_to_string_GL(primitiveMode), (unsigned int)buffer, (void*)indirects, (void*)sizes, (unsigned int)count)
    glatter_glDrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawCommandsNV_defined
#endif
#ifndef glDrawCommandsStatesAddressNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawCommandsStatesAddressNV, (indirects, sizes, states, fbos, count), (const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glDrawCommandsStatesAddressNV_debug(const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsStatesAddressNV, "(%p, %p, %p, %p, %u)", (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glDrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawCommandsStatesAddressNV_defined
#endif
#ifndef glDrawCommandsStatesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawCommandsStatesNV, (buffer, indirects, sizes, states, fbos, count), (GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glDrawCommandsStatesNV_debug(GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsStatesNV, "(%u, %p, %p, %p, %p, %u)", (unsigned int)buffer, (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glDrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawCommandsStatesNV_defined
#endif
#ifndef glGetCommandHeaderNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetCommandHeaderNV, (tokenID, size), (GLenum tokenID, GLuint size))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetCommandHeaderNV_debug(GLenum tokenID, GLuint size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCommandHeaderNV, "(%s, %u)", enum_to_string_GL(tokenID), (unsigned int)size)
    GLuint rval = glatter_glGetCommandHeaderNV(tokenID, size);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetCommandHeaderNV_defined
#endif
#ifndef glGetStageIndexNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLushort, APIENTRY, glGetStageIndexNV, (shadertype), (GLenum shadertype))
GLATTER_INLINE_OR_NOT GLushort glatter_glGetStageIndexNV_debug(GLenum shadertype, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStageIndexNV, "(%s)", enum_to_string_GL(shadertype))
    GLushort rval = glatter_glGetStageIndexNV(shadertype);
    GLATTER_RBLOCK("%hu\n", (unsigned short)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetStageIndexNV_defined
#endif
#ifndef glIsCommandListNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsCommandListNV, (list), (GLuint list))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsCommandListNV, "(%u)", (unsigned int)list)
    GLboolean rval = glatter_glIsCommandListNV(list);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsCommandListNV_defined
#endif
#ifndef glIsStateNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsStateNV, (state), (GLuint state))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsStateNV_debug(GLuint state, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsStateNV, "(%u)", (unsigned int)state)
    GLboolean rval = glatter_glIsStateNV(state);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsStateNV_defined
#endif
#ifndef glListDrawCommandsStatesClientNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glListDrawCommandsStatesClientNV, (list, segment, indirects, sizes, states, fbos, count), (GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glListDrawCommandsStatesClientNV_debug(GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListDrawCommandsStatesClientNV, "(%u, %u, %p, %p, %p, %p, %u)", (unsigned int)list, (unsigned int)segment, (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glListDrawCommandsStatesClientNV_defined
#endif
#ifndef glStateCaptureNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStateCaptureNV, (state, mode), (GLuint state, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glStateCaptureNV_debug(GLuint state, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStateCaptureNV, "(%u, %s)", (unsigned int)state, enum_to_string_GL(mode))
    glatter_glStateCaptureNV(state, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStateCaptureNV_defined
#endif
#endif // defined(GL_NV_command_list)
#if defined(GL_NV_conditional_render)
#ifndef glBeginConditionalRenderNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginConditionalRenderNV, (id, mode), (GLuint id, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBeginConditionalRenderNV_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNV, "(%u, %s)", (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRenderNV(id, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginConditionalRenderNV_defined
#endif
#ifndef glEndConditionalRenderNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndConditionalRenderNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndConditionalRenderNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNV, "()")
    glatter_glEndConditionalRenderNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndConditionalRenderNV_defined
#endif
#endif // defined(GL_NV_conditional_render)
#if defined(GL_NV_conservative_raster)
#ifndef glSubpixelPrecisionBiasNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSubpixelPrecisionBiasNV, (xbits, ybits), (GLuint xbits, GLuint ybits))
GLATTER_INLINE_OR_NOT void glatter_glSubpixelPrecisionBiasNV_debug(GLuint xbits, GLuint ybits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSubpixelPrecisionBiasNV, "(%u, %u)", (unsigned int)xbits, (unsigned int)ybits)
    glatter_glSubpixelPrecisionBiasNV(xbits, ybits);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSubpixelPrecisionBiasNV_defined
#endif
#endif // defined(GL_NV_conservative_raster)
#if defined(GL_NV_conservative_raster_dilate)
#ifndef glConservativeRasterParameterfNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConservativeRasterParameterfNV, (pname, value), (GLenum pname, GLfloat value))
GLATTER_INLINE_OR_NOT void glatter_glConservativeRasterParameterfNV_debug(GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameterfNV, "(%s, %f)", enum_to_string_GL(pname), (float)value)
    glatter_glConservativeRasterParameterfNV(pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConservativeRasterParameterfNV_defined
#endif
#endif // defined(GL_NV_conservative_raster_dilate)
#if defined(GL_NV_conservative_raster_pre_snap_triangles)
#ifndef glConservativeRasterParameteriNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConservativeRasterParameteriNV, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glConservativeRasterParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameteriNV, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glConservativeRasterParameteriNV(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConservativeRasterParameteriNV_defined
#endif
#endif // defined(GL_NV_conservative_raster_pre_snap_triangles)
#if defined(GL_NV_copy_image)
#ifndef glCopyImageSubDataNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyImageSubDataNV, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glCopyImageSubDataNV_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubDataNV, "(%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    glatter_glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyImageSubDataNV_defined
#endif
#endif // defined(GL_NV_copy_image)
#if defined(GL_NV_depth_buffer_float)
#ifndef glClearDepthdNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearDepthdNV, (depth), (GLdouble depth))
GLATTER_INLINE_OR_NOT void glatter_glClearDepthdNV_debug(GLdouble depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthdNV, "(%f)", (double)depth)
    glatter_glClearDepthdNV(depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearDepthdNV_defined
#endif
#ifndef glDepthBoundsdNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthBoundsdNV, (zmin, zmax), (GLdouble zmin, GLdouble zmax))
GLATTER_INLINE_OR_NOT void glatter_glDepthBoundsdNV_debug(GLdouble zmin, GLdouble zmax, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthBoundsdNV, "(%f, %f)", (double)zmin, (double)zmax)
    glatter_glDepthBoundsdNV(zmin, zmax);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthBoundsdNV_defined
#endif
#ifndef glDepthRangedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangedNV, (zNear, zFar), (GLdouble zNear, GLdouble zFar))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangedNV_debug(GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangedNV, "(%f, %f)", (double)zNear, (double)zFar)
    glatter_glDepthRangedNV(zNear, zFar);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangedNV_defined
#endif
#endif // defined(GL_NV_depth_buffer_float)
#if defined(GL_NV_draw_texture)
#ifndef glDrawTextureNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTextureNV, (texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1), (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1))
GLATTER_INLINE_OR_NOT void glatter_glDrawTextureNV_debug(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTextureNV, "(%u, %u, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (unsigned int)texture, (unsigned int)sampler, (float)x0, (float)y0, (float)x1, (float)y1, (float)z, (float)s0, (float)t0, (float)s1, (float)t1)
    glatter_glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTextureNV_defined
#endif
#endif // defined(GL_NV_draw_texture)
#if defined(GL_NV_draw_vulkan_image)
#ifndef glDrawVkImageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawVkImageNV, (vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1), (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1))
GLATTER_INLINE_OR_NOT void glatter_glDrawVkImageNV_debug(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawVkImageNV, "(%s, %u, %f, %f, %f, %f, %f, %f, %f, %f, %f)", GET_PRS(vkImage), (unsigned int)sampler, (float)x0, (float)y0, (float)x1, (float)y1, (float)z, (float)s0, (float)t0, (float)s1, (float)t1)
    glatter_glDrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawVkImageNV_defined
#endif
#ifndef glGetVkProcAddrNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLVULKANPROCNV, APIENTRY, glGetVkProcAddrNV, (name), (const GLchar *name))
GLATTER_INLINE_OR_NOT GLVULKANPROCNV glatter_glGetVkProcAddrNV_debug(const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVkProcAddrNV, "(%p)", (void*)name)
    GLVULKANPROCNV rval = glatter_glGetVkProcAddrNV(name);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetVkProcAddrNV_defined
#endif
#ifndef glSignalVkFenceNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSignalVkFenceNV, (vkFence), (GLuint64 vkFence))
GLATTER_INLINE_OR_NOT void glatter_glSignalVkFenceNV_debug(GLuint64 vkFence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSignalVkFenceNV, "(%s)", GET_PRS(vkFence))
    glatter_glSignalVkFenceNV(vkFence);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSignalVkFenceNV_defined
#endif
#ifndef glSignalVkSemaphoreNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSignalVkSemaphoreNV, (vkSemaphore), (GLuint64 vkSemaphore))
GLATTER_INLINE_OR_NOT void glatter_glSignalVkSemaphoreNV_debug(GLuint64 vkSemaphore, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSignalVkSemaphoreNV, "(%s)", GET_PRS(vkSemaphore))
    glatter_glSignalVkSemaphoreNV(vkSemaphore);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSignalVkSemaphoreNV_defined
#endif
#ifndef glWaitVkSemaphoreNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWaitVkSemaphoreNV, (vkSemaphore), (GLuint64 vkSemaphore))
GLATTER_INLINE_OR_NOT void glatter_glWaitVkSemaphoreNV_debug(GLuint64 vkSemaphore, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitVkSemaphoreNV, "(%s)", GET_PRS(vkSemaphore))
    glatter_glWaitVkSemaphoreNV(vkSemaphore);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWaitVkSemaphoreNV_defined
#endif
#endif // defined(GL_NV_draw_vulkan_image)
#if defined(GL_NV_evaluators)
#ifndef glEvalMapsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvalMapsNV, (target, mode), (GLenum target, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glEvalMapsNV_debug(GLenum target, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalMapsNV, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(mode))
    glatter_glEvalMapsNV(target, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvalMapsNV_defined
#endif
#ifndef glGetMapAttribParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapAttribParameterfvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMapAttribParameterfvNV_debug(GLenum target, GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapAttribParameterfvNV, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapAttribParameterfvNV(target, index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapAttribParameterfvNV_defined
#endif
#ifndef glGetMapAttribParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapAttribParameterivNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMapAttribParameterivNV_debug(GLenum target, GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapAttribParameterivNV, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapAttribParameterivNV(target, index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapAttribParameterivNV_defined
#endif
#ifndef glGetMapControlPointsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapControlPointsNV, (target, index, type, ustride, vstride, packed, points), (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points))
GLATTER_INLINE_OR_NOT void glatter_glGetMapControlPointsNV_debug(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapControlPointsNV, "(%s, %u, %s, %d, %d, %u, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(type), (int)ustride, (int)vstride, (unsigned char)packed, (void*)points)
    glatter_glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapControlPointsNV_defined
#endif
#ifndef glGetMapParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapParameterfvNV, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMapParameterfvNV_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapParameterfvNV, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapParameterfvNV(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapParameterfvNV_defined
#endif
#ifndef glGetMapParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapParameterivNV, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMapParameterivNV_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapParameterivNV, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapParameterivNV(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapParameterivNV_defined
#endif
#ifndef glMapControlPointsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapControlPointsNV, (target, index, type, ustride, vstride, uorder, vorder, packed, points), (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points))
GLATTER_INLINE_OR_NOT void glatter_glMapControlPointsNV_debug(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapControlPointsNV, "(%s, %u, %s, %d, %d, %d, %d, %u, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(type), (int)ustride, (int)vstride, (int)uorder, (int)vorder, (unsigned char)packed, (void*)points)
    glatter_glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapControlPointsNV_defined
#endif
#ifndef glMapParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapParameterfvNV, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glMapParameterfvNV_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapParameterfvNV, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMapParameterfvNV(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapParameterfvNV_defined
#endif
#ifndef glMapParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapParameterivNV, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMapParameterivNV_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapParameterivNV, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMapParameterivNV(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapParameterivNV_defined
#endif
#endif // defined(GL_NV_evaluators)
#if defined(GL_NV_explicit_multisample)
#ifndef glGetMultisamplefvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultisamplefvNV, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_INLINE_OR_NOT void glatter_glGetMultisamplefvNV_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefvNV, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefvNV(pname, index, val);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultisamplefvNV_defined
#endif
#ifndef glSampleMaskIndexedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleMaskIndexedNV, (index, mask), (GLuint index, GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glSampleMaskIndexedNV_debug(GLuint index, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskIndexedNV, "(%u, %u)", (unsigned int)index, (unsigned int)mask)
    glatter_glSampleMaskIndexedNV(index, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleMaskIndexedNV_defined
#endif
#ifndef glTexRenderbufferNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexRenderbufferNV, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glTexRenderbufferNV_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexRenderbufferNV, "(%s, %u)", enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glTexRenderbufferNV(target, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexRenderbufferNV_defined
#endif
#endif // defined(GL_NV_explicit_multisample)
#if defined(GL_NV_fence)
#ifndef glDeleteFencesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteFencesNV, (n, fences), (GLsizei n, const GLuint *fences))
GLATTER_INLINE_OR_NOT void glatter_glDeleteFencesNV_debug(GLsizei n, const GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFencesNV, "(%d, %p)", (int)n, (void*)fences)
    glatter_glDeleteFencesNV(n, fences);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteFencesNV_defined
#endif
#ifndef glFinishFenceNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFinishFenceNV, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT void glatter_glFinishFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishFenceNV, "(%u)", (unsigned int)fence)
    glatter_glFinishFenceNV(fence);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFinishFenceNV_defined
#endif
#ifndef glGenFencesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenFencesNV, (n, fences), (GLsizei n, GLuint *fences))
GLATTER_INLINE_OR_NOT void glatter_glGenFencesNV_debug(GLsizei n, GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFencesNV, "(%d, %p)", (int)n, (void*)fences)
    glatter_glGenFencesNV(n, fences);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenFencesNV_defined
#endif
#ifndef glGetFenceivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFenceivNV, (fence, pname, params), (GLuint fence, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFenceivNV_debug(GLuint fence, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFenceivNV, "(%u, %s, %p)", (unsigned int)fence, enum_to_string_GL(pname), (void*)params)
    glatter_glGetFenceivNV(fence, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFenceivNV_defined
#endif
#ifndef glIsFenceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsFenceNV, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFenceNV, "(%u)", (unsigned int)fence)
    GLboolean rval = glatter_glIsFenceNV(fence);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsFenceNV_defined
#endif
#ifndef glSetFenceNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSetFenceNV, (fence, condition), (GLuint fence, GLenum condition))
GLATTER_INLINE_OR_NOT void glatter_glSetFenceNV_debug(GLuint fence, GLenum condition, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFenceNV, "(%u, %s)", (unsigned int)fence, enum_to_string_GL(condition))
    glatter_glSetFenceNV(fence, condition);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSetFenceNV_defined
#endif
#ifndef glTestFenceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glTestFenceNV, (fence), (GLuint fence))
GLATTER_INLINE_OR_NOT GLboolean glatter_glTestFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestFenceNV, "(%u)", (unsigned int)fence)
    GLboolean rval = glatter_glTestFenceNV(fence);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glTestFenceNV_defined
#endif
#endif // defined(GL_NV_fence)
#if defined(GL_NV_fragment_coverage_to_color)
#ifndef glFragmentCoverageColorNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentCoverageColorNV, (color), (GLuint color))
GLATTER_INLINE_OR_NOT void glatter_glFragmentCoverageColorNV_debug(GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentCoverageColorNV, "(%u)", (unsigned int)color)
    glatter_glFragmentCoverageColorNV(color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentCoverageColorNV_defined
#endif
#endif // defined(GL_NV_fragment_coverage_to_color)
#if defined(GL_NV_fragment_program)
#ifndef glGetProgramNamedParameterdvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramNamedParameterdvNV, (id, len, name, params), (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramNamedParameterdvNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramNamedParameterdvNV, "(%u, %d, %p, %p)", (unsigned int)id, (int)len, (void*)name, (void*)params)
    glatter_glGetProgramNamedParameterdvNV(id, len, name, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramNamedParameterdvNV_defined
#endif
#ifndef glGetProgramNamedParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramNamedParameterfvNV, (id, len, name, params), (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramNamedParameterfvNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramNamedParameterfvNV, "(%u, %d, %p, %p)", (unsigned int)id, (int)len, (void*)name, (void*)params)
    glatter_glGetProgramNamedParameterfvNV(id, len, name, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramNamedParameterfvNV_defined
#endif
#ifndef glProgramNamedParameter4dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramNamedParameter4dNV, (id, len, name, x, y, z, w), (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glProgramNamedParameter4dNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4dNV, "(%u, %d, %p, %f, %f, %f, %f)", (unsigned int)id, (int)len, (void*)name, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramNamedParameter4dNV_defined
#endif
#ifndef glProgramNamedParameter4dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramNamedParameter4dvNV, (id, len, name, v), (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramNamedParameter4dvNV_debug(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4dvNV, "(%u, %d, %p, %p)", (unsigned int)id, (int)len, (void*)name, (void*)v)
    glatter_glProgramNamedParameter4dvNV(id, len, name, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramNamedParameter4dvNV_defined
#endif
#ifndef glProgramNamedParameter4fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramNamedParameter4fNV, (id, len, name, x, y, z, w), (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glProgramNamedParameter4fNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4fNV, "(%u, %d, %p, %f, %f, %f, %f)", (unsigned int)id, (int)len, (void*)name, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramNamedParameter4fNV_defined
#endif
#ifndef glProgramNamedParameter4fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramNamedParameter4fvNV, (id, len, name, v), (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramNamedParameter4fvNV_debug(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4fvNV, "(%u, %d, %p, %p)", (unsigned int)id, (int)len, (void*)name, (void*)v)
    glatter_glProgramNamedParameter4fvNV(id, len, name, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramNamedParameter4fvNV_defined
#endif
#endif // defined(GL_NV_fragment_program)
#if defined(GL_NV_framebuffer_mixed_samples)
#ifndef glCoverageModulationNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverageModulationNV, (components), (GLenum components))
GLATTER_INLINE_OR_NOT void glatter_glCoverageModulationNV_debug(GLenum components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationNV, "(%s)", enum_to_string_GL(components))
    glatter_glCoverageModulationNV(components);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverageModulationNV_defined
#endif
#ifndef glCoverageModulationTableNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverageModulationTableNV, (n, v), (GLsizei n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glCoverageModulationTableNV_debug(GLsizei n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationTableNV, "(%d, %p)", (int)n, (void*)v)
    glatter_glCoverageModulationTableNV(n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverageModulationTableNV_defined
#endif
#ifndef glGetCoverageModulationTableNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCoverageModulationTableNV, (bufSize, v), (GLsizei bufSize, GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glGetCoverageModulationTableNV_debug(GLsizei bufSize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCoverageModulationTableNV, "(%d, %p)", (int)bufSize, (void*)v)
    glatter_glGetCoverageModulationTableNV(bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCoverageModulationTableNV_defined
#endif
#endif // defined(GL_NV_framebuffer_mixed_samples)
#if defined(GL_NV_framebuffer_multisample_coverage)
#ifndef glRenderbufferStorageMultisampleCoverageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorageMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalformat, width, height), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorageMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleCoverageNV, "(%s, %d, %d, %s, %d, %d)", enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorageMultisampleCoverageNV_defined
#endif
#endif // defined(GL_NV_framebuffer_multisample_coverage)
#if defined(GL_NV_geometry_program4)
#ifndef glFramebufferTextureEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureEXT, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureEXT, "(%s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureEXT(target, attachment, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureEXT_defined
#endif
#ifndef glFramebufferTextureFaceEXT_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureFaceEXT, (target, attachment, texture, level, face), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureFaceEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureFaceEXT, "(%s, %s, %u, %d, %s)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureFaceEXT_defined
#endif
#ifndef glProgramVertexLimitNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramVertexLimitNV, (target, limit), (GLenum target, GLint limit))
GLATTER_INLINE_OR_NOT void glatter_glProgramVertexLimitNV_debug(GLenum target, GLint limit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramVertexLimitNV, "(%s, %d)", enum_to_string_GL(target), (int)limit)
    glatter_glProgramVertexLimitNV(target, limit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramVertexLimitNV_defined
#endif
#endif // defined(GL_NV_geometry_program4)
#if defined(GL_NV_gpu_multicast)
#ifndef glMulticastBarrierNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastBarrierNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glMulticastBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastBarrierNV, "()")
    glatter_glMulticastBarrierNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastBarrierNV_defined
#endif
#ifndef glMulticastBlitFramebufferNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastBlitFramebufferNV, (srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glMulticastBlitFramebufferNV_debug(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastBlitFramebufferNV, "(%u, %u, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (unsigned int)srcGpu, (unsigned int)dstGpu, (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastBlitFramebufferNV_defined
#endif
#ifndef glMulticastBufferSubDataNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastBufferSubDataNV, (gpuMask, buffer, offset, size, data), (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glMulticastBufferSubDataNV_debug(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastBufferSubDataNV, "(%u, %u, %s, %s, %p)", (unsigned int)gpuMask, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glMulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastBufferSubDataNV_defined
#endif
#ifndef glMulticastCopyBufferSubDataNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastCopyBufferSubDataNV, (readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glMulticastCopyBufferSubDataNV_debug(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastCopyBufferSubDataNV, "(%u, %u, %u, %u, %s, %s, %s)", (unsigned int)readGpu, (unsigned int)writeGpuMask, (unsigned int)readBuffer, (unsigned int)writeBuffer, GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glMulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastCopyBufferSubDataNV_defined
#endif
#ifndef glMulticastCopyImageSubDataNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastCopyImageSubDataNV, (srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
GLATTER_INLINE_OR_NOT void glatter_glMulticastCopyImageSubDataNV_debug(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastCopyImageSubDataNV, "(%u, %u, %u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)srcGpu, (unsigned int)dstGpuMask, (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glMulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastCopyImageSubDataNV_defined
#endif
#ifndef glMulticastFramebufferSampleLocationsfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastFramebufferSampleLocationsfvNV, (gpu, framebuffer, start, count, v), (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMulticastFramebufferSampleLocationsfvNV_debug(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastFramebufferSampleLocationsfvNV, "(%u, %u, %u, %d, %p)", (unsigned int)gpu, (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastFramebufferSampleLocationsfvNV_defined
#endif
#ifndef glMulticastGetQueryObjecti64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastGetQueryObjecti64vNV, (gpu, id, pname, params), (GLuint gpu, GLuint id, GLenum pname, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glMulticastGetQueryObjecti64vNV_debug(GLuint gpu, GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastGetQueryObjecti64vNV, "(%u, %u, %s, %p)", (unsigned int)gpu, (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glMulticastGetQueryObjecti64vNV(gpu, id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastGetQueryObjecti64vNV_defined
#endif
#ifndef glMulticastGetQueryObjectivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastGetQueryObjectivNV, (gpu, id, pname, params), (GLuint gpu, GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glMulticastGetQueryObjectivNV_debug(GLuint gpu, GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastGetQueryObjectivNV, "(%u, %u, %s, %p)", (unsigned int)gpu, (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glMulticastGetQueryObjectivNV(gpu, id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastGetQueryObjectivNV_defined
#endif
#ifndef glMulticastGetQueryObjectui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastGetQueryObjectui64vNV, (gpu, id, pname, params), (GLuint gpu, GLuint id, GLenum pname, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glMulticastGetQueryObjectui64vNV_debug(GLuint gpu, GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastGetQueryObjectui64vNV, "(%u, %u, %s, %p)", (unsigned int)gpu, (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glMulticastGetQueryObjectui64vNV(gpu, id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastGetQueryObjectui64vNV_defined
#endif
#ifndef glMulticastGetQueryObjectuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastGetQueryObjectuivNV, (gpu, id, pname, params), (GLuint gpu, GLuint id, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glMulticastGetQueryObjectuivNV_debug(GLuint gpu, GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastGetQueryObjectuivNV, "(%u, %u, %s, %p)", (unsigned int)gpu, (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glMulticastGetQueryObjectuivNV(gpu, id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastGetQueryObjectuivNV_defined
#endif
#ifndef glMulticastWaitSyncNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMulticastWaitSyncNV, (signalGpu, waitGpuMask), (GLuint signalGpu, GLbitfield waitGpuMask))
GLATTER_INLINE_OR_NOT void glatter_glMulticastWaitSyncNV_debug(GLuint signalGpu, GLbitfield waitGpuMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMulticastWaitSyncNV, "(%u, %u)", (unsigned int)signalGpu, (unsigned int)waitGpuMask)
    glatter_glMulticastWaitSyncNV(signalGpu, waitGpuMask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMulticastWaitSyncNV_defined
#endif
#ifndef glRenderGpuMaskNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderGpuMaskNV, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glRenderGpuMaskNV_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderGpuMaskNV, "(%u)", (unsigned int)mask)
    glatter_glRenderGpuMaskNV(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderGpuMaskNV_defined
#endif
#endif // defined(GL_NV_gpu_multicast)
#if defined(GL_NV_gpu_program4)
#ifndef glGetProgramEnvParameterIivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramEnvParameterIivNV, (target, index, params), (GLenum target, GLuint index, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramEnvParameterIivNV_debug(GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterIivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterIivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramEnvParameterIivNV_defined
#endif
#ifndef glGetProgramEnvParameterIuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramEnvParameterIuivNV, (target, index, params), (GLenum target, GLuint index, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramEnvParameterIuivNV_debug(GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterIuivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterIuivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramEnvParameterIuivNV_defined
#endif
#ifndef glGetProgramLocalParameterIivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramLocalParameterIivNV, (target, index, params), (GLenum target, GLuint index, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramLocalParameterIivNV_debug(GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterIivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterIivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramLocalParameterIivNV_defined
#endif
#ifndef glGetProgramLocalParameterIuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramLocalParameterIuivNV, (target, index, params), (GLenum target, GLuint index, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramLocalParameterIuivNV_debug(GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterIuivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterIuivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramLocalParameterIuivNV_defined
#endif
#ifndef glProgramEnvParameterI4iNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameterI4iNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameterI4iNV_debug(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4iNV, "(%s, %u, %d, %d, %d, %d)", enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glProgramEnvParameterI4iNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameterI4iNV_defined
#endif
#ifndef glProgramEnvParameterI4ivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameterI4ivNV, (target, index, params), (GLenum target, GLuint index, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameterI4ivNV_debug(GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4ivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameterI4ivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameterI4ivNV_defined
#endif
#ifndef glProgramEnvParameterI4uiNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameterI4uiNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameterI4uiNV_debug(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4uiNV, "(%s, %u, %u, %u, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameterI4uiNV_defined
#endif
#ifndef glProgramEnvParameterI4uivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParameterI4uivNV, (target, index, params), (GLenum target, GLuint index, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParameterI4uivNV_debug(GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4uivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameterI4uivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParameterI4uivNV_defined
#endif
#ifndef glProgramEnvParametersI4ivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParametersI4ivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParametersI4ivNV_debug(GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParametersI4ivNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParametersI4ivNV(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParametersI4ivNV_defined
#endif
#ifndef glProgramEnvParametersI4uivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramEnvParametersI4uivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramEnvParametersI4uivNV_debug(GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParametersI4uivNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParametersI4uivNV(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramEnvParametersI4uivNV_defined
#endif
#ifndef glProgramLocalParameterI4iNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameterI4iNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameterI4iNV_debug(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4iNV, "(%s, %u, %d, %d, %d, %d)", enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glProgramLocalParameterI4iNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameterI4iNV_defined
#endif
#ifndef glProgramLocalParameterI4ivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameterI4ivNV, (target, index, params), (GLenum target, GLuint index, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameterI4ivNV_debug(GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4ivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameterI4ivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameterI4ivNV_defined
#endif
#ifndef glProgramLocalParameterI4uiNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameterI4uiNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameterI4uiNV_debug(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4uiNV, "(%s, %u, %u, %u, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameterI4uiNV_defined
#endif
#ifndef glProgramLocalParameterI4uivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParameterI4uivNV, (target, index, params), (GLenum target, GLuint index, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParameterI4uivNV_debug(GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4uivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameterI4uivNV(target, index, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParameterI4uivNV_defined
#endif
#ifndef glProgramLocalParametersI4ivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParametersI4ivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParametersI4ivNV_debug(GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParametersI4ivNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParametersI4ivNV(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParametersI4ivNV_defined
#endif
#ifndef glProgramLocalParametersI4uivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramLocalParametersI4uivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramLocalParametersI4uivNV_debug(GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParametersI4uivNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParametersI4uivNV(target, index, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramLocalParametersI4uivNV_defined
#endif
#endif // defined(GL_NV_gpu_program4)
#if defined(GL_NV_gpu_program5)
#ifndef glGetProgramSubroutineParameteruivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramSubroutineParameteruivNV, (target, index, param), (GLenum target, GLuint index, GLuint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramSubroutineParameteruivNV_debug(GLenum target, GLuint index, GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramSubroutineParameteruivNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)param)
    glatter_glGetProgramSubroutineParameteruivNV(target, index, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramSubroutineParameteruivNV_defined
#endif
#ifndef glProgramSubroutineParametersuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramSubroutineParametersuivNV, (target, count, params), (GLenum target, GLsizei count, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramSubroutineParametersuivNV_debug(GLenum target, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramSubroutineParametersuivNV, "(%s, %d, %p)", enum_to_string_GL(target), (int)count, (void*)params)
    glatter_glProgramSubroutineParametersuivNV(target, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramSubroutineParametersuivNV_defined
#endif
#endif // defined(GL_NV_gpu_program5)
#if defined(GL_NV_half_float)
#ifndef glColor3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3hNV, (red, green, blue), (GLhalfNV red, GLhalfNV green, GLhalfNV blue))
GLATTER_INLINE_OR_NOT void glatter_glColor3hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3hNV, "(%hu, %hu, %hu)", (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glColor3hNV(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3hNV_defined
#endif
#ifndef glColor3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glColor3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3hvNV, "(%p)", (void*)v)
    glatter_glColor3hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3hvNV_defined
#endif
#ifndef glColor4hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4hNV, (red, green, blue, alpha), (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha))
GLATTER_INLINE_OR_NOT void glatter_glColor4hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4hNV, "(%hu, %hu, %hu, %hu)", (unsigned short)red, (unsigned short)green, (unsigned short)blue, (unsigned short)alpha)
    glatter_glColor4hNV(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4hNV_defined
#endif
#ifndef glColor4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glColor4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4hvNV, "(%p)", (void*)v)
    glatter_glColor4hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4hvNV_defined
#endif
#ifndef glFogCoordhNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordhNV, (fog), (GLhalfNV fog))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordhNV_debug(GLhalfNV fog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordhNV, "(%hu)", (unsigned short)fog)
    glatter_glFogCoordhNV(fog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordhNV_defined
#endif
#ifndef glFogCoordhvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordhvNV, (fog), (const GLhalfNV *fog))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordhvNV_debug(const GLhalfNV *fog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordhvNV, "(%p)", (void*)fog)
    glatter_glFogCoordhvNV(fog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordhvNV_defined
#endif
#ifndef glMultiTexCoord1hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1hNV, (target, s), (GLenum target, GLhalfNV s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1hNV_debug(GLenum target, GLhalfNV s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1hNV, "(%s, %hu)", enum_to_string_GL(target), (unsigned short)s)
    glatter_glMultiTexCoord1hNV(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1hNV_defined
#endif
#ifndef glMultiTexCoord1hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1hvNV, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1hvNV(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1hvNV_defined
#endif
#ifndef glMultiTexCoord2hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2hNV, (target, s, t), (GLenum target, GLhalfNV s, GLhalfNV t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2hNV, "(%s, %hu, %hu)", enum_to_string_GL(target), (unsigned short)s, (unsigned short)t)
    glatter_glMultiTexCoord2hNV(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2hNV_defined
#endif
#ifndef glMultiTexCoord2hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2hvNV, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2hvNV(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2hvNV_defined
#endif
#ifndef glMultiTexCoord3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3hNV, (target, s, t, r), (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3hNV, "(%s, %hu, %hu, %hu)", enum_to_string_GL(target), (unsigned short)s, (unsigned short)t, (unsigned short)r)
    glatter_glMultiTexCoord3hNV(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3hNV_defined
#endif
#ifndef glMultiTexCoord3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3hvNV, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3hvNV(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3hvNV_defined
#endif
#ifndef glMultiTexCoord4hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4hNV, (target, s, t, r, q), (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4hNV, "(%s, %hu, %hu, %hu, %hu)", enum_to_string_GL(target), (unsigned short)s, (unsigned short)t, (unsigned short)r, (unsigned short)q)
    glatter_glMultiTexCoord4hNV(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4hNV_defined
#endif
#ifndef glMultiTexCoord4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4hvNV, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4hvNV(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4hvNV_defined
#endif
#ifndef glNormal3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3hNV, (nx, ny, nz), (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz))
GLATTER_INLINE_OR_NOT void glatter_glNormal3hNV_debug(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3hNV, "(%hu, %hu, %hu)", (unsigned short)nx, (unsigned short)ny, (unsigned short)nz)
    glatter_glNormal3hNV(nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3hNV_defined
#endif
#ifndef glNormal3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glNormal3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3hvNV, "(%p)", (void*)v)
    glatter_glNormal3hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3hvNV_defined
#endif
#ifndef glSecondaryColor3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3hNV, (red, green, blue), (GLhalfNV red, GLhalfNV green, GLhalfNV blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3hNV, "(%hu, %hu, %hu)", (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3hNV(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3hNV_defined
#endif
#ifndef glSecondaryColor3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3hvNV, "(%p)", (void*)v)
    glatter_glSecondaryColor3hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3hvNV_defined
#endif
#ifndef glTexCoord1hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1hNV, (s), (GLhalfNV s))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1hNV_debug(GLhalfNV s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1hNV, "(%hu)", (unsigned short)s)
    glatter_glTexCoord1hNV(s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1hNV_defined
#endif
#ifndef glTexCoord1hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1hvNV, "(%p)", (void*)v)
    glatter_glTexCoord1hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1hvNV_defined
#endif
#ifndef glTexCoord2hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2hNV, (s, t), (GLhalfNV s, GLhalfNV t))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2hNV_debug(GLhalfNV s, GLhalfNV t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2hNV, "(%hu, %hu)", (unsigned short)s, (unsigned short)t)
    glatter_glTexCoord2hNV(s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2hNV_defined
#endif
#ifndef glTexCoord2hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2hvNV, "(%p)", (void*)v)
    glatter_glTexCoord2hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2hvNV_defined
#endif
#ifndef glTexCoord3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3hNV, (s, t, r), (GLhalfNV s, GLhalfNV t, GLhalfNV r))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3hNV_debug(GLhalfNV s, GLhalfNV t, GLhalfNV r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3hNV, "(%hu, %hu, %hu)", (unsigned short)s, (unsigned short)t, (unsigned short)r)
    glatter_glTexCoord3hNV(s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3hNV_defined
#endif
#ifndef glTexCoord3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3hvNV, "(%p)", (void*)v)
    glatter_glTexCoord3hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3hvNV_defined
#endif
#ifndef glTexCoord4hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4hNV, (s, t, r, q), (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4hNV_debug(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4hNV, "(%hu, %hu, %hu, %hu)", (unsigned short)s, (unsigned short)t, (unsigned short)r, (unsigned short)q)
    glatter_glTexCoord4hNV(s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4hNV_defined
#endif
#ifndef glTexCoord4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4hvNV, "(%p)", (void*)v)
    glatter_glTexCoord4hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4hvNV_defined
#endif
#ifndef glVertex2hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2hNV, (x, y), (GLhalfNV x, GLhalfNV y))
GLATTER_INLINE_OR_NOT void glatter_glVertex2hNV_debug(GLhalfNV x, GLhalfNV y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2hNV, "(%hu, %hu)", (unsigned short)x, (unsigned short)y)
    glatter_glVertex2hNV(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2hNV_defined
#endif
#ifndef glVertex2hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertex2hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2hvNV, "(%p)", (void*)v)
    glatter_glVertex2hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2hvNV_defined
#endif
#ifndef glVertex3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3hNV, (x, y, z), (GLhalfNV x, GLhalfNV y, GLhalfNV z))
GLATTER_INLINE_OR_NOT void glatter_glVertex3hNV_debug(GLhalfNV x, GLhalfNV y, GLhalfNV z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3hNV, "(%hu, %hu, %hu)", (unsigned short)x, (unsigned short)y, (unsigned short)z)
    glatter_glVertex3hNV(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3hNV_defined
#endif
#ifndef glVertex3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertex3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3hvNV, "(%p)", (void*)v)
    glatter_glVertex3hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3hvNV_defined
#endif
#ifndef glVertex4hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4hNV, (x, y, z, w), (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w))
GLATTER_INLINE_OR_NOT void glatter_glVertex4hNV_debug(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4hNV, "(%hu, %hu, %hu, %hu)", (unsigned short)x, (unsigned short)y, (unsigned short)z, (unsigned short)w)
    glatter_glVertex4hNV(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4hNV_defined
#endif
#ifndef glVertex4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4hvNV, (v), (const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertex4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4hvNV, "(%p)", (void*)v)
    glatter_glVertex4hvNV(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4hvNV_defined
#endif
#ifndef glVertexAttrib1hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1hNV, (index, x), (GLuint index, GLhalfNV x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1hNV_debug(GLuint index, GLhalfNV x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1hNV, "(%u, %hu)", (unsigned int)index, (unsigned short)x)
    glatter_glVertexAttrib1hNV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1hNV_defined
#endif
#ifndef glVertexAttrib1hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1hvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1hvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1hvNV_defined
#endif
#ifndef glVertexAttrib2hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2hNV, (index, x, y), (GLuint index, GLhalfNV x, GLhalfNV y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2hNV, "(%u, %hu, %hu)", (unsigned int)index, (unsigned short)x, (unsigned short)y)
    glatter_glVertexAttrib2hNV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2hNV_defined
#endif
#ifndef glVertexAttrib2hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2hvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2hvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2hvNV_defined
#endif
#ifndef glVertexAttrib3hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3hNV, (index, x, y, z), (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3hNV, "(%u, %hu, %hu, %hu)", (unsigned int)index, (unsigned short)x, (unsigned short)y, (unsigned short)z)
    glatter_glVertexAttrib3hNV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3hNV_defined
#endif
#ifndef glVertexAttrib3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3hvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3hvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3hvNV_defined
#endif
#ifndef glVertexAttrib4hNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4hNV, (index, x, y, z, w), (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4hNV, "(%u, %hu, %hu, %hu, %hu)", (unsigned int)index, (unsigned short)x, (unsigned short)y, (unsigned short)z, (unsigned short)w)
    glatter_glVertexAttrib4hNV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4hNV_defined
#endif
#ifndef glVertexAttrib4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4hvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4hvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4hvNV_defined
#endif
#ifndef glVertexAttribs1hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs1hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs1hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1hvNV, "(%u, %d, %p)", (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs1hvNV(index, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs1hvNV_defined
#endif
#ifndef glVertexAttribs2hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs2hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs2hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2hvNV, "(%u, %d, %p)", (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs2hvNV(index, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs2hvNV_defined
#endif
#ifndef glVertexAttribs3hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs3hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs3hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3hvNV, "(%u, %d, %p)", (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs3hvNV(index, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs3hvNV_defined
#endif
#ifndef glVertexAttribs4hvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs4hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs4hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4hvNV, "(%u, %d, %p)", (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs4hvNV(index, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs4hvNV_defined
#endif
#ifndef glVertexWeighthNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexWeighthNV, (weight), (GLhalfNV weight))
GLATTER_INLINE_OR_NOT void glatter_glVertexWeighthNV_debug(GLhalfNV weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeighthNV, "(%hu)", (unsigned short)weight)
    glatter_glVertexWeighthNV(weight);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexWeighthNV_defined
#endif
#ifndef glVertexWeighthvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexWeighthvNV, (weight), (const GLhalfNV *weight))
GLATTER_INLINE_OR_NOT void glatter_glVertexWeighthvNV_debug(const GLhalfNV *weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeighthvNV, "(%p)", (void*)weight)
    glatter_glVertexWeighthvNV(weight);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexWeighthvNV_defined
#endif
#endif // defined(GL_NV_half_float)
#if defined(GL_NV_internalformat_sample_query)
#ifndef glGetInternalformatSampleivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInternalformatSampleivNV, (target, internalformat, samples, pname, count, params), (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetInternalformatSampleivNV_debug(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformatSampleivNV, "(%s, %s, %d, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)samples, enum_to_string_GL(pname), (int)count, (void*)params)
    glatter_glGetInternalformatSampleivNV(target, internalformat, samples, pname, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInternalformatSampleivNV_defined
#endif
#endif // defined(GL_NV_internalformat_sample_query)
#if defined(GL_NV_memory_attachment)
#ifndef glBufferAttachMemoryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferAttachMemoryNV, (target, memory, offset), (GLenum target, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glBufferAttachMemoryNV_debug(GLenum target, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferAttachMemoryNV, "(%s, %u, %s)", enum_to_string_GL(target), (unsigned int)memory, GET_PRS(offset))
    glatter_glBufferAttachMemoryNV(target, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferAttachMemoryNV_defined
#endif
#ifndef glGetMemoryObjectDetachedResourcesuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMemoryObjectDetachedResourcesuivNV, (memory, pname, first, count, params), (GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetMemoryObjectDetachedResourcesuivNV_debug(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMemoryObjectDetachedResourcesuivNV, "(%u, %s, %d, %d, %p)", (unsigned int)memory, enum_to_string_GL(pname), (int)first, (int)count, (void*)params)
    glatter_glGetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMemoryObjectDetachedResourcesuivNV_defined
#endif
#ifndef glNamedBufferAttachMemoryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferAttachMemoryNV, (buffer, memory, offset), (GLuint buffer, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferAttachMemoryNV_debug(GLuint buffer, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferAttachMemoryNV, "(%u, %u, %s)", (unsigned int)buffer, (unsigned int)memory, GET_PRS(offset))
    glatter_glNamedBufferAttachMemoryNV(buffer, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferAttachMemoryNV_defined
#endif
#ifndef glResetMemoryObjectParameterNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResetMemoryObjectParameterNV, (memory, pname), (GLuint memory, GLenum pname))
GLATTER_INLINE_OR_NOT void glatter_glResetMemoryObjectParameterNV_debug(GLuint memory, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetMemoryObjectParameterNV, "(%u, %s)", (unsigned int)memory, enum_to_string_GL(pname))
    glatter_glResetMemoryObjectParameterNV(memory, pname);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResetMemoryObjectParameterNV_defined
#endif
#ifndef glTexAttachMemoryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexAttachMemoryNV, (target, memory, offset), (GLenum target, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTexAttachMemoryNV_debug(GLenum target, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexAttachMemoryNV, "(%s, %u, %s)", enum_to_string_GL(target), (unsigned int)memory, GET_PRS(offset))
    glatter_glTexAttachMemoryNV(target, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexAttachMemoryNV_defined
#endif
#ifndef glTextureAttachMemoryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureAttachMemoryNV, (texture, memory, offset), (GLuint texture, GLuint memory, GLuint64 offset))
GLATTER_INLINE_OR_NOT void glatter_glTextureAttachMemoryNV_debug(GLuint texture, GLuint memory, GLuint64 offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureAttachMemoryNV, "(%u, %u, %s)", (unsigned int)texture, (unsigned int)memory, GET_PRS(offset))
    glatter_glTextureAttachMemoryNV(texture, memory, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureAttachMemoryNV_defined
#endif
#endif // defined(GL_NV_memory_attachment)
#if defined(GL_NV_memory_object_sparse)
#ifndef glBufferPageCommitmentMemNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferPageCommitmentMemNV, (target, offset, size, memory, memOffset, commit), (GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glBufferPageCommitmentMemNV_debug(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferPageCommitmentMemNV, "(%s, %s, %s, %u, %s, %u)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (unsigned int)memory, GET_PRS(memOffset), (unsigned char)commit)
    glatter_glBufferPageCommitmentMemNV(target, offset, size, memory, memOffset, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferPageCommitmentMemNV_defined
#endif
#ifndef glNamedBufferPageCommitmentMemNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferPageCommitmentMemNV, (buffer, offset, size, memory, memOffset, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferPageCommitmentMemNV_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentMemNV, "(%u, %s, %s, %u, %s, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (unsigned int)memory, GET_PRS(memOffset), (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferPageCommitmentMemNV_defined
#endif
#ifndef glTexPageCommitmentMemNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexPageCommitmentMemNV, (target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit), (GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glTexPageCommitmentMemNV_debug(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexPageCommitmentMemNV, "(%s, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s, %u)", enum_to_string_GL(target), (int)layer, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned int)memory, GET_PRS(offset), (unsigned char)commit)
    glatter_glTexPageCommitmentMemNV(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexPageCommitmentMemNV_defined
#endif
#ifndef glTexturePageCommitmentMemNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexturePageCommitmentMemNV, (texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit), (GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit))
GLATTER_INLINE_OR_NOT void glatter_glTexturePageCommitmentMemNV_debug(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexturePageCommitmentMemNV, "(%u, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s, %u)", (unsigned int)texture, (int)layer, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned int)memory, GET_PRS(offset), (unsigned char)commit)
    glatter_glTexturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexturePageCommitmentMemNV_defined
#endif
#endif // defined(GL_NV_memory_object_sparse)
#if defined(GL_NV_mesh_shader)
#ifndef glDrawMeshTasksIndirectNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawMeshTasksIndirectNV, (indirect), (GLintptr indirect))
GLATTER_INLINE_OR_NOT void glatter_glDrawMeshTasksIndirectNV_debug(GLintptr indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawMeshTasksIndirectNV, "(%s)", GET_PRS(indirect))
    glatter_glDrawMeshTasksIndirectNV(indirect);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawMeshTasksIndirectNV_defined
#endif
#ifndef glDrawMeshTasksNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawMeshTasksNV, (first, count), (GLuint first, GLuint count))
GLATTER_INLINE_OR_NOT void glatter_glDrawMeshTasksNV_debug(GLuint first, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawMeshTasksNV, "(%u, %u)", (unsigned int)first, (unsigned int)count)
    glatter_glDrawMeshTasksNV(first, count);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawMeshTasksNV_defined
#endif
#ifndef glMultiDrawMeshTasksIndirectCountNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawMeshTasksIndirectCountNV, (indirect, drawcount, maxdrawcount, stride), (GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawMeshTasksIndirectCountNV_debug(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawMeshTasksIndirectCountNV, "(%s, %s, %d, %d)", GET_PRS(indirect), GET_PRS(drawcount), (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawMeshTasksIndirectCountNV_defined
#endif
#ifndef glMultiDrawMeshTasksIndirectNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawMeshTasksIndirectNV, (indirect, drawcount, stride), (GLintptr indirect, GLsizei drawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawMeshTasksIndirectNV_debug(GLintptr indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawMeshTasksIndirectNV, "(%s, %d, %d)", GET_PRS(indirect), (int)drawcount, (int)stride)
    glatter_glMultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawMeshTasksIndirectNV_defined
#endif
#endif // defined(GL_NV_mesh_shader)
#if defined(GL_NV_occlusion_query)
#ifndef glBeginOcclusionQueryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginOcclusionQueryNV, (id), (GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBeginOcclusionQueryNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginOcclusionQueryNV, "(%u)", (unsigned int)id)
    glatter_glBeginOcclusionQueryNV(id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginOcclusionQueryNV_defined
#endif
#ifndef glDeleteOcclusionQueriesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteOcclusionQueriesNV, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glDeleteOcclusionQueriesNV_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteOcclusionQueriesNV, "(%d, %p)", (int)n, (void*)ids)
    glatter_glDeleteOcclusionQueriesNV(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteOcclusionQueriesNV_defined
#endif
#ifndef glEndOcclusionQueryNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndOcclusionQueryNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndOcclusionQueryNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndOcclusionQueryNV, "()")
    glatter_glEndOcclusionQueryNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndOcclusionQueryNV_defined
#endif
#ifndef glGenOcclusionQueriesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenOcclusionQueriesNV, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glGenOcclusionQueriesNV_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenOcclusionQueriesNV, "(%d, %p)", (int)n, (void*)ids)
    glatter_glGenOcclusionQueriesNV(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenOcclusionQueriesNV_defined
#endif
#ifndef glGetOcclusionQueryivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetOcclusionQueryivNV, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetOcclusionQueryivNV_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetOcclusionQueryivNV, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetOcclusionQueryivNV(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetOcclusionQueryivNV_defined
#endif
#ifndef glGetOcclusionQueryuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetOcclusionQueryuivNV, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetOcclusionQueryuivNV_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetOcclusionQueryuivNV, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetOcclusionQueryuivNV(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetOcclusionQueryuivNV_defined
#endif
#ifndef glIsOcclusionQueryNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsOcclusionQueryNV, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsOcclusionQueryNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsOcclusionQueryNV, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsOcclusionQueryNV(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsOcclusionQueryNV_defined
#endif
#endif // defined(GL_NV_occlusion_query)
#if defined(GL_NV_parameter_buffer_object)
#ifndef glProgramBufferParametersIivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramBufferParametersIivNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramBufferParametersIivNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersIivNV, "(%s, %u, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramBufferParametersIivNV_defined
#endif
#ifndef glProgramBufferParametersIuivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramBufferParametersIuivNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramBufferParametersIuivNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersIuivNV, "(%s, %u, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramBufferParametersIuivNV_defined
#endif
#ifndef glProgramBufferParametersfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramBufferParametersfvNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glProgramBufferParametersfvNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersfvNV, "(%s, %u, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramBufferParametersfvNV_defined
#endif
#endif // defined(GL_NV_parameter_buffer_object)
#if defined(GL_NV_path_rendering)
#ifndef glCopyPathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyPathNV, (resultPath, srcPath), (GLuint resultPath, GLuint srcPath))
GLATTER_INLINE_OR_NOT void glatter_glCopyPathNV_debug(GLuint resultPath, GLuint srcPath, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyPathNV, "(%u, %u)", (unsigned int)resultPath, (unsigned int)srcPath)
    glatter_glCopyPathNV(resultPath, srcPath);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyPathNV_defined
#endif
#ifndef glCoverFillPathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathInstancedNV, "(%d, %s, %p, %u, %s, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverFillPathInstancedNV_defined
#endif
#ifndef glCoverFillPathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverFillPathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_INLINE_OR_NOT void glatter_glCoverFillPathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathNV, "(%u, %s)", (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverFillPathNV(path, coverMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverFillPathNV_defined
#endif
#ifndef glCoverStrokePathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathInstancedNV, "(%d, %s, %p, %u, %s, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverStrokePathInstancedNV_defined
#endif
#ifndef glCoverStrokePathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCoverStrokePathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_INLINE_OR_NOT void glatter_glCoverStrokePathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathNV, "(%u, %s)", (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverStrokePathNV(path, coverMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCoverStrokePathNV_defined
#endif
#ifndef glDeletePathsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeletePathsNV, (path, range), (GLuint path, GLsizei range))
GLATTER_INLINE_OR_NOT void glatter_glDeletePathsNV_debug(GLuint path, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePathsNV, "(%u, %d)", (unsigned int)path, (int)range)
    glatter_glDeletePathsNV(path, range);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeletePathsNV_defined
#endif
#ifndef glGenPathsNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGenPathsNV, (range), (GLsizei range))
GLATTER_INLINE_OR_NOT GLuint glatter_glGenPathsNV_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPathsNV, "(%d)", (int)range)
    GLuint rval = glatter_glGenPathsNV(range);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGenPathsNV_defined
#endif
#ifndef glGetPathColorGenfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathColorGenfvNV, (color, pname, value), (GLenum color, GLenum pname, GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathColorGenfvNV_debug(GLenum color, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathColorGenfvNV, "(%s, %s, %p)", enum_to_string_GL(color), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathColorGenfvNV(color, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathColorGenfvNV_defined
#endif
#ifndef glGetPathColorGenivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathColorGenivNV, (color, pname, value), (GLenum color, GLenum pname, GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathColorGenivNV_debug(GLenum color, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathColorGenivNV, "(%s, %s, %p)", enum_to_string_GL(color), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathColorGenivNV(color, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathColorGenivNV_defined
#endif
#ifndef glGetPathCommandsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathCommandsNV, (path, commands), (GLuint path, GLubyte *commands))
GLATTER_INLINE_OR_NOT void glatter_glGetPathCommandsNV_debug(GLuint path, GLubyte *commands, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCommandsNV, "(%u, %p)", (unsigned int)path, (void*)commands)
    glatter_glGetPathCommandsNV(path, commands);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathCommandsNV_defined
#endif
#ifndef glGetPathCoordsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathCoordsNV, (path, coords), (GLuint path, GLfloat *coords))
GLATTER_INLINE_OR_NOT void glatter_glGetPathCoordsNV_debug(GLuint path, GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCoordsNV, "(%u, %p)", (unsigned int)path, (void*)coords)
    glatter_glGetPathCoordsNV(path, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathCoordsNV_defined
#endif
#ifndef glGetPathDashArrayNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathDashArrayNV, (path, dashArray), (GLuint path, GLfloat *dashArray))
GLATTER_INLINE_OR_NOT void glatter_glGetPathDashArrayNV_debug(GLuint path, GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathDashArrayNV, "(%u, %p)", (unsigned int)path, (void*)dashArray)
    glatter_glGetPathDashArrayNV(path, dashArray);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathDashArrayNV_defined
#endif
#ifndef glGetPathLengthNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLfloat, APIENTRY, glGetPathLengthNV, (path, startSegment, numSegments), (GLuint path, GLsizei startSegment, GLsizei numSegments))
GLATTER_INLINE_OR_NOT GLfloat glatter_glGetPathLengthNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathLengthNV, "(%u, %d, %d)", (unsigned int)path, (int)startSegment, (int)numSegments)
    GLfloat rval = glatter_glGetPathLengthNV(path, startSegment, numSegments);
    GLATTER_RBLOCK("%f\n", (float)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetPathLengthNV_defined
#endif
#ifndef glGetPathMetricRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathMetricRangeNV, (metricQueryMask, firstPathName, numPaths, stride, metrics), (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics))
GLATTER_INLINE_OR_NOT void glatter_glGetPathMetricRangeNV_debug(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricRangeNV, "(%u, %u, %d, %d, %p)", (unsigned int)metricQueryMask, (unsigned int)firstPathName, (int)numPaths, (int)stride, (void*)metrics)
    glatter_glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathMetricRangeNV_defined
#endif
#ifndef glGetPathMetricsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathMetricsNV, (metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics), (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics))
GLATTER_INLINE_OR_NOT void glatter_glGetPathMetricsNV_debug(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricsNV, "(%u, %d, %s, %p, %u, %d, %p)", (unsigned int)metricQueryMask, (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)stride, (void*)metrics)
    glatter_glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathMetricsNV_defined
#endif
#ifndef glGetPathParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathParameterfvNV_debug(GLuint path, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterfvNV, "(%u, %s, %p)", (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterfvNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathParameterfvNV_defined
#endif
#ifndef glGetPathParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathParameterivNV_debug(GLuint path, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterivNV, "(%u, %s, %p)", (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterivNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathParameterivNV_defined
#endif
#ifndef glGetPathSpacingNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathSpacingNV, (pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing), (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing))
GLATTER_INLINE_OR_NOT void glatter_glGetPathSpacingNV_debug(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathSpacingNV, "(%s, %d, %s, %p, %u, %f, %f, %s, %p)", enum_to_string_GL(pathListMode), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (float)advanceScale, (float)kerningScale, enum_to_string_GL(transformType), (void*)returnedSpacing)
    glatter_glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathSpacingNV_defined
#endif
#ifndef glGetPathTexGenfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathTexGenfvNV, (texCoordSet, pname, value), (GLenum texCoordSet, GLenum pname, GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathTexGenfvNV_debug(GLenum texCoordSet, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathTexGenfvNV, "(%s, %s, %p)", enum_to_string_GL(texCoordSet), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathTexGenfvNV(texCoordSet, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathTexGenfvNV_defined
#endif
#ifndef glGetPathTexGenivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPathTexGenivNV, (texCoordSet, pname, value), (GLenum texCoordSet, GLenum pname, GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glGetPathTexGenivNV_debug(GLenum texCoordSet, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathTexGenivNV, "(%s, %s, %p)", enum_to_string_GL(texCoordSet), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathTexGenivNV(texCoordSet, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPathTexGenivNV_defined
#endif
#ifndef glGetProgramResourcefvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramResourcefvNV, (program, programInterface, index, propCount, props, count, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramResourcefvNV_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourcefvNV, "(%u, %s, %u, %d, %p, %d, %p, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)count, (void*)length, (void*)params)
    glatter_glGetProgramResourcefvNV(program, programInterface, index, propCount, props, count, length, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramResourcefvNV_defined
#endif
#ifndef glInterpolatePathsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInterpolatePathsNV, (resultPath, pathA, pathB, weight), (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight))
GLATTER_INLINE_OR_NOT void glatter_glInterpolatePathsNV_debug(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInterpolatePathsNV, "(%u, %u, %u, %f)", (unsigned int)resultPath, (unsigned int)pathA, (unsigned int)pathB, (float)weight)
    glatter_glInterpolatePathsNV(resultPath, pathA, pathB, weight);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInterpolatePathsNV_defined
#endif
#ifndef glIsPathNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsPathNV, (path), (GLuint path))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsPathNV_debug(GLuint path, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPathNV, "(%u)", (unsigned int)path)
    GLboolean rval = glatter_glIsPathNV(path);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsPathNV_defined
#endif
#ifndef glIsPointInFillPathNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsPointInFillPathNV, (path, mask, x, y), (GLuint path, GLuint mask, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsPointInFillPathNV_debug(GLuint path, GLuint mask, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInFillPathNV, "(%u, %u, %f, %f)", (unsigned int)path, (unsigned int)mask, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInFillPathNV(path, mask, x, y);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsPointInFillPathNV_defined
#endif
#ifndef glIsPointInStrokePathNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsPointInStrokePathNV, (path, x, y), (GLuint path, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsPointInStrokePathNV_debug(GLuint path, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInStrokePathNV, "(%u, %f, %f)", (unsigned int)path, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInStrokePathNV(path, x, y);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsPointInStrokePathNV_defined
#endif
#ifndef glMatrixLoad3x2fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoad3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoad3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x2fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x2fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoad3x2fNV_defined
#endif
#ifndef glMatrixLoad3x3fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoad3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoad3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x3fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x3fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoad3x3fNV_defined
#endif
#ifndef glMatrixLoadTranspose3x3fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixLoadTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixLoadTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTranspose3x3fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoadTranspose3x3fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixLoadTranspose3x3fNV_defined
#endif
#ifndef glMatrixMult3x2fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMult3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMult3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x2fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x2fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMult3x2fNV_defined
#endif
#ifndef glMatrixMult3x3fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMult3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMult3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x3fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x3fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMult3x3fNV_defined
#endif
#ifndef glMatrixMultTranspose3x3fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMatrixMultTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMatrixMultTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTranspose3x3fNV, "(%s, %p)", enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMultTranspose3x3fNV(matrixMode, m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMatrixMultTranspose3x3fNV_defined
#endif
#ifndef glPathColorGenNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathColorGenNV, (color, genMode, colorFormat, coeffs), (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs))
GLATTER_INLINE_OR_NOT void glatter_glPathColorGenNV_debug(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathColorGenNV, "(%s, %s, %s, %p)", enum_to_string_GL(color), enum_to_string_GL(genMode), enum_to_string_GL(colorFormat), (void*)coeffs)
    glatter_glPathColorGenNV(color, genMode, colorFormat, coeffs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathColorGenNV_defined
#endif
#ifndef glPathCommandsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathCommandsNV, (path, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_INLINE_OR_NOT void glatter_glPathCommandsNV_debug(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCommandsNV, "(%u, %d, %p, %d, %s, %p)", (unsigned int)path, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathCommandsNV_defined
#endif
#ifndef glPathCoordsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathCoordsNV, (path, numCoords, coordType, coords), (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_INLINE_OR_NOT void glatter_glPathCoordsNV_debug(GLuint path, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoordsNV, "(%u, %d, %s, %p)", (unsigned int)path, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCoordsNV(path, numCoords, coordType, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathCoordsNV_defined
#endif
#ifndef glPathCoverDepthFuncNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathCoverDepthFuncNV, (func), (GLenum func))
GLATTER_INLINE_OR_NOT void glatter_glPathCoverDepthFuncNV_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoverDepthFuncNV, "(%s)", enum_to_string_GL(func))
    glatter_glPathCoverDepthFuncNV(func);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathCoverDepthFuncNV_defined
#endif
#ifndef glPathDashArrayNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathDashArrayNV, (path, dashCount, dashArray), (GLuint path, GLsizei dashCount, const GLfloat *dashArray))
GLATTER_INLINE_OR_NOT void glatter_glPathDashArrayNV_debug(GLuint path, GLsizei dashCount, const GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathDashArrayNV, "(%u, %d, %p)", (unsigned int)path, (int)dashCount, (void*)dashArray)
    glatter_glPathDashArrayNV(path, dashCount, dashArray);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathDashArrayNV_defined
#endif
#ifndef glPathFogGenNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathFogGenNV, (genMode), (GLenum genMode))
GLATTER_INLINE_OR_NOT void glatter_glPathFogGenNV_debug(GLenum genMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathFogGenNV, "(%s)", enum_to_string_GL(genMode))
    glatter_glPathFogGenNV(genMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathFogGenNV_defined
#endif
#ifndef glPathGlyphIndexArrayNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glPathGlyphIndexArrayNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_INLINE_OR_NOT GLenum glatter_glPathGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexArrayNV, "(%u, %s, %p, %u, %u, %d, %u, %f)", (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPathGlyphIndexArrayNV_defined
#endif
#ifndef glPathGlyphIndexRangeNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glPathGlyphIndexRangeNV, (fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount), (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint *baseAndCount))
GLATTER_INLINE_OR_NOT GLenum glatter_glPathGlyphIndexRangeNV_debug(GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint *baseAndCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexRangeNV, "(%s, %p, %u, %u, %f, %p)", enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)pathParameterTemplate, (float)emScale, (void*)baseAndCount)
    GLenum rval = glatter_glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPathGlyphIndexRangeNV_defined
#endif
#ifndef glPathGlyphRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathGlyphRangeNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_INLINE_OR_NOT void glatter_glPathGlyphRangeNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphRangeNV, "(%u, %s, %p, %u, %u, %d, %s, %u, %f)", (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyph, (int)numGlyphs, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathGlyphRangeNV_defined
#endif
#ifndef glPathGlyphsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathGlyphsNV, (firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_INLINE_OR_NOT void glatter_glPathGlyphsNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphsNV, "(%u, %s, %p, %u, %d, %s, %p, %s, %u, %f)", (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (int)numGlyphs, enum_to_string_GL(type), (void*)charcodes, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathGlyphsNV_defined
#endif
#ifndef glPathMemoryGlyphIndexArrayNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glPathMemoryGlyphIndexArrayNV, (firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_INLINE_OR_NOT GLenum glatter_glPathMemoryGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathMemoryGlyphIndexArrayNV, "(%u, %s, %s, %p, %d, %u, %d, %u, %f)", (unsigned int)firstPathName, enum_to_string_GL(fontTarget), GET_PRS(fontSize), (void*)fontData, (int)faceIndex, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPathMemoryGlyphIndexArrayNV_defined
#endif
#ifndef glPathParameterfNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathParameterfNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat value))
GLATTER_INLINE_OR_NOT void glatter_glPathParameterfNV_debug(GLuint path, GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfNV, "(%u, %s, %f)", (unsigned int)path, enum_to_string_GL(pname), (float)value)
    glatter_glPathParameterfNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathParameterfNV_defined
#endif
#ifndef glPathParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glPathParameterfvNV_debug(GLuint path, GLenum pname, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfvNV, "(%u, %s, %p)", (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterfvNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathParameterfvNV_defined
#endif
#ifndef glPathParameteriNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathParameteriNV, (path, pname, value), (GLuint path, GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glPathParameteriNV_debug(GLuint path, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameteriNV, "(%u, %s, %d)", (unsigned int)path, enum_to_string_GL(pname), (int)value)
    glatter_glPathParameteriNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathParameteriNV_defined
#endif
#ifndef glPathParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glPathParameterivNV_debug(GLuint path, GLenum pname, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterivNV, "(%u, %s, %p)", (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterivNV(path, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathParameterivNV_defined
#endif
#ifndef glPathStencilDepthOffsetNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathStencilDepthOffsetNV, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_INLINE_OR_NOT void glatter_glPathStencilDepthOffsetNV_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilDepthOffsetNV, "(%f, %f)", (float)factor, (float)units)
    glatter_glPathStencilDepthOffsetNV(factor, units);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathStencilDepthOffsetNV_defined
#endif
#ifndef glPathStencilFuncNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathStencilFuncNV, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glPathStencilFuncNV_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilFuncNV, "(%s, %d, %u)", enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glPathStencilFuncNV(func, ref, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathStencilFuncNV_defined
#endif
#ifndef glPathStringNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathStringNV, (path, format, length, pathString), (GLuint path, GLenum format, GLsizei length, const void *pathString))
GLATTER_INLINE_OR_NOT void glatter_glPathStringNV_debug(GLuint path, GLenum format, GLsizei length, const void *pathString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStringNV, "(%u, %s, %d, %p)", (unsigned int)path, enum_to_string_GL(format), (int)length, (void*)pathString)
    glatter_glPathStringNV(path, format, length, pathString);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathStringNV_defined
#endif
#ifndef glPathSubCommandsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathSubCommandsNV, (path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_INLINE_OR_NOT void glatter_glPathSubCommandsNV_debug(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCommandsNV, "(%u, %d, %d, %d, %p, %d, %s, %p)", (unsigned int)path, (int)commandStart, (int)commandsToDelete, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathSubCommandsNV_defined
#endif
#ifndef glPathSubCoordsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathSubCoordsNV, (path, coordStart, numCoords, coordType, coords), (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_INLINE_OR_NOT void glatter_glPathSubCoordsNV_debug(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCoordsNV, "(%u, %d, %d, %s, %p)", (unsigned int)path, (int)coordStart, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathSubCoordsNV_defined
#endif
#ifndef glPathTexGenNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPathTexGenNV, (texCoordSet, genMode, components, coeffs), (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_INLINE_OR_NOT void glatter_glPathTexGenNV_debug(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathTexGenNV, "(%s, %s, %d, %p)", enum_to_string_GL(texCoordSet), enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glPathTexGenNV(texCoordSet, genMode, components, coeffs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPathTexGenNV_defined
#endif
#ifndef glPointAlongPathNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glPointAlongPathNV, (path, startSegment, numSegments, distance, x, y, tangentX, tangentY), (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY))
GLATTER_INLINE_OR_NOT GLboolean glatter_glPointAlongPathNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointAlongPathNV, "(%u, %d, %d, %f, %p, %p, %p, %p)", (unsigned int)path, (int)startSegment, (int)numSegments, (float)distance, (void*)x, (void*)y, (void*)tangentX, (void*)tangentY)
    GLboolean rval = glatter_glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPointAlongPathNV_defined
#endif
#ifndef glProgramPathFragmentInputGenNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramPathFragmentInputGenNV, (program, location, genMode, components, coeffs), (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_INLINE_OR_NOT void glatter_glProgramPathFragmentInputGenNV_debug(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramPathFragmentInputGenNV, "(%u, %d, %s, %d, %p)", (unsigned int)program, (int)location, enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramPathFragmentInputGenNV_defined
#endif
#ifndef glStencilFillPathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glStencilFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathInstancedNV, "(%d, %s, %p, %u, %s, %u, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilFillPathInstancedNV_defined
#endif
#ifndef glStencilFillPathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilFillPathNV, (path, fillMode, mask), (GLuint path, GLenum fillMode, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glStencilFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathNV, "(%u, %s, %u)", (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask)
    glatter_glStencilFillPathNV(path, fillMode, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilFillPathNV_defined
#endif
#ifndef glStencilStrokePathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glStencilStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathInstancedNV, "(%d, %s, %p, %u, %d, %u, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilStrokePathInstancedNV_defined
#endif
#ifndef glStencilStrokePathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilStrokePathNV, (path, reference, mask), (GLuint path, GLint reference, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glStencilStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathNV, "(%u, %d, %u)", (unsigned int)path, (int)reference, (unsigned int)mask)
    glatter_glStencilStrokePathNV(path, reference, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilStrokePathNV_defined
#endif
#ifndef glStencilThenCoverFillPathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilThenCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glStencilThenCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathInstancedNV, "(%d, %s, %p, %u, %s, %u, %s, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilThenCoverFillPathInstancedNV_defined
#endif
#ifndef glStencilThenCoverFillPathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilThenCoverFillPathNV, (path, fillMode, mask, coverMode), (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode))
GLATTER_INLINE_OR_NOT void glatter_glStencilThenCoverFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathNV, "(%u, %s, %u, %s)", (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilThenCoverFillPathNV_defined
#endif
#ifndef glStencilThenCoverStrokePathInstancedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilThenCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glStencilThenCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathInstancedNV, "(%d, %s, %p, %u, %d, %u, %s, %s, %p)", (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilThenCoverStrokePathInstancedNV_defined
#endif
#ifndef glStencilThenCoverStrokePathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilThenCoverStrokePathNV, (path, reference, mask, coverMode), (GLuint path, GLint reference, GLuint mask, GLenum coverMode))
GLATTER_INLINE_OR_NOT void glatter_glStencilThenCoverStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathNV, "(%u, %d, %u, %s)", (unsigned int)path, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilThenCoverStrokePathNV_defined
#endif
#ifndef glTransformPathNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformPathNV, (resultPath, srcPath, transformType, transformValues), (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues))
GLATTER_INLINE_OR_NOT void glatter_glTransformPathNV_debug(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformPathNV, "(%u, %u, %s, %p)", (unsigned int)resultPath, (unsigned int)srcPath, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glTransformPathNV(resultPath, srcPath, transformType, transformValues);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformPathNV_defined
#endif
#ifndef glWeightPathsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWeightPathsNV, (resultPath, numPaths, paths, weights), (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights))
GLATTER_INLINE_OR_NOT void glatter_glWeightPathsNV_debug(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPathsNV, "(%u, %d, %p, %p)", (unsigned int)resultPath, (int)numPaths, (void*)paths, (void*)weights)
    glatter_glWeightPathsNV(resultPath, numPaths, paths, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWeightPathsNV_defined
#endif
#endif // defined(GL_NV_path_rendering)
#if defined(GL_NV_pixel_data_range)
#ifndef glFlushPixelDataRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushPixelDataRangeNV, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glFlushPixelDataRangeNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushPixelDataRangeNV, "(%s)", enum_to_string_GL(target))
    glatter_glFlushPixelDataRangeNV(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushPixelDataRangeNV_defined
#endif
#ifndef glPixelDataRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelDataRangeNV, (target, length, pointer), (GLenum target, GLsizei length, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glPixelDataRangeNV_debug(GLenum target, GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelDataRangeNV, "(%s, %d, %p)", enum_to_string_GL(target), (int)length, (void*)pointer)
    glatter_glPixelDataRangeNV(target, length, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelDataRangeNV_defined
#endif
#endif // defined(GL_NV_pixel_data_range)
#if defined(GL_NV_point_sprite)
#ifndef glPointParameteriNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameteriNV, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteriNV, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glPointParameteriNV(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameteriNV_defined
#endif
#ifndef glPointParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterivNV, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterivNV_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterivNV, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterivNV(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterivNV_defined
#endif
#endif // defined(GL_NV_point_sprite)
#if defined(GL_NV_present_video)
#ifndef glGetVideoi64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoi64vNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoi64vNV_debug(GLuint video_slot, GLenum pname, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoi64vNV, "(%u, %s, %p)", (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoi64vNV(video_slot, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoi64vNV_defined
#endif
#ifndef glGetVideoivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoivNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoivNV_debug(GLuint video_slot, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoivNV, "(%u, %s, %p)", (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoivNV(video_slot, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoivNV_defined
#endif
#ifndef glGetVideoui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoui64vNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoui64vNV_debug(GLuint video_slot, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoui64vNV, "(%u, %s, %p)", (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoui64vNV(video_slot, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoui64vNV_defined
#endif
#ifndef glGetVideouivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideouivNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideouivNV_debug(GLuint video_slot, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideouivNV, "(%u, %s, %p)", (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideouivNV(video_slot, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideouivNV_defined
#endif
#ifndef glPresentFrameDualFillNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPresentFrameDualFillNV, (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3), (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3))
GLATTER_INLINE_OR_NOT void glatter_glPresentFrameDualFillNV_debug(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPresentFrameDualFillNV, "(%u, %s, %u, %u, %s, %s, %u, %s, %u, %s, %u, %s, %u)", (unsigned int)video_slot, GET_PRS(minPresentTime), (unsigned int)beginPresentTimeId, (unsigned int)presentDurationId, enum_to_string_GL(type), enum_to_string_GL(target0), (unsigned int)fill0, enum_to_string_GL(target1), (unsigned int)fill1, enum_to_string_GL(target2), (unsigned int)fill2, enum_to_string_GL(target3), (unsigned int)fill3)
    glatter_glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPresentFrameDualFillNV_defined
#endif
#ifndef glPresentFrameKeyedNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPresentFrameKeyedNV, (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1), (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1))
GLATTER_INLINE_OR_NOT void glatter_glPresentFrameKeyedNV_debug(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPresentFrameKeyedNV, "(%u, %s, %u, %u, %s, %s, %u, %u, %s, %u, %u)", (unsigned int)video_slot, GET_PRS(minPresentTime), (unsigned int)beginPresentTimeId, (unsigned int)presentDurationId, enum_to_string_GL(type), enum_to_string_GL(target0), (unsigned int)fill0, (unsigned int)key0, enum_to_string_GL(target1), (unsigned int)fill1, (unsigned int)key1)
    glatter_glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPresentFrameKeyedNV_defined
#endif
#endif // defined(GL_NV_present_video)
#if defined(GL_NV_primitive_restart)
#ifndef glPrimitiveRestartIndexNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrimitiveRestartIndexNV, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glPrimitiveRestartIndexNV_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartIndexNV, "(%u)", (unsigned int)index)
    glatter_glPrimitiveRestartIndexNV(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrimitiveRestartIndexNV_defined
#endif
#ifndef glPrimitiveRestartNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrimitiveRestartNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glPrimitiveRestartNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartNV, "()")
    glatter_glPrimitiveRestartNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrimitiveRestartNV_defined
#endif
#endif // defined(GL_NV_primitive_restart)
#if defined(GL_NV_query_resource)
#ifndef glQueryResourceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glQueryResourceNV, (queryType, tagId, count, buffer), (GLenum queryType, GLint tagId, GLuint count, GLint *buffer))
GLATTER_INLINE_OR_NOT GLint glatter_glQueryResourceNV_debug(GLenum queryType, GLint tagId, GLuint count, GLint *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryResourceNV, "(%s, %d, %u, %p)", enum_to_string_GL(queryType), (int)tagId, (unsigned int)count, (void*)buffer)
    GLint rval = glatter_glQueryResourceNV(queryType, tagId, count, buffer);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glQueryResourceNV_defined
#endif
#endif // defined(GL_NV_query_resource)
#if defined(GL_NV_query_resource_tag)
#ifndef glDeleteQueryResourceTagNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteQueryResourceTagNV, (n, tagIds), (GLsizei n, const GLint *tagIds))
GLATTER_INLINE_OR_NOT void glatter_glDeleteQueryResourceTagNV_debug(GLsizei n, const GLint *tagIds, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueryResourceTagNV, "(%d, %p)", (int)n, (void*)tagIds)
    glatter_glDeleteQueryResourceTagNV(n, tagIds);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteQueryResourceTagNV_defined
#endif
#ifndef glGenQueryResourceTagNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenQueryResourceTagNV, (n, tagIds), (GLsizei n, GLint *tagIds))
GLATTER_INLINE_OR_NOT void glatter_glGenQueryResourceTagNV_debug(GLsizei n, GLint *tagIds, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueryResourceTagNV, "(%d, %p)", (int)n, (void*)tagIds)
    glatter_glGenQueryResourceTagNV(n, tagIds);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenQueryResourceTagNV_defined
#endif
#ifndef glQueryResourceTagNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glQueryResourceTagNV, (tagId, tagString), (GLint tagId, const GLchar *tagString))
GLATTER_INLINE_OR_NOT void glatter_glQueryResourceTagNV_debug(GLint tagId, const GLchar *tagString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryResourceTagNV, "(%d, %p)", (int)tagId, (void*)tagString)
    glatter_glQueryResourceTagNV(tagId, tagString);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glQueryResourceTagNV_defined
#endif
#endif // defined(GL_NV_query_resource_tag)
#if defined(GL_NV_register_combiners)
#ifndef glCombinerInputNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerInputNV, (stage, portion, variable, input, mapping, componentUsage), (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage))
GLATTER_INLINE_OR_NOT void glatter_glCombinerInputNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerInputNV, "(%s, %s, %s, %s, %s, %s)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(input), enum_to_string_GL(mapping), enum_to_string_GL(componentUsage))
    glatter_glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerInputNV_defined
#endif
#ifndef glCombinerOutputNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerOutputNV, (stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum), (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum))
GLATTER_INLINE_OR_NOT void glatter_glCombinerOutputNV_debug(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerOutputNV, "(%s, %s, %s, %s, %s, %s, %s, %u, %u, %u)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(abOutput), enum_to_string_GL(cdOutput), enum_to_string_GL(sumOutput), enum_to_string_GL(scale), enum_to_string_GL(bias), (unsigned char)abDotProduct, (unsigned char)cdDotProduct, (unsigned char)muxSum)
    glatter_glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerOutputNV_defined
#endif
#ifndef glCombinerParameterfNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerParameterfNV, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glCombinerParameterfNV_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterfNV, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glCombinerParameterfNV(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerParameterfNV_defined
#endif
#ifndef glCombinerParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerParameterfvNV, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glCombinerParameterfvNV_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterfvNV, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerParameterfvNV(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerParameterfvNV_defined
#endif
#ifndef glCombinerParameteriNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerParameteriNV, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glCombinerParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameteriNV, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glCombinerParameteriNV(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerParameteriNV_defined
#endif
#ifndef glCombinerParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerParameterivNV, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glCombinerParameterivNV_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterivNV, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerParameterivNV(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerParameterivNV_defined
#endif
#ifndef glFinalCombinerInputNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFinalCombinerInputNV, (variable, input, mapping, componentUsage), (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage))
GLATTER_INLINE_OR_NOT void glatter_glFinalCombinerInputNV_debug(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinalCombinerInputNV, "(%s, %s, %s, %s)", enum_to_string_GL(variable), enum_to_string_GL(input), enum_to_string_GL(mapping), enum_to_string_GL(componentUsage))
    glatter_glFinalCombinerInputNV(variable, input, mapping, componentUsage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFinalCombinerInputNV_defined
#endif
#ifndef glGetCombinerInputParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCombinerInputParameterfvNV, (stage, portion, variable, pname, params), (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetCombinerInputParameterfvNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerInputParameterfvNV, "(%s, %s, %s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCombinerInputParameterfvNV_defined
#endif
#ifndef glGetCombinerInputParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCombinerInputParameterivNV, (stage, portion, variable, pname, params), (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetCombinerInputParameterivNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerInputParameterivNV, "(%s, %s, %s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCombinerInputParameterivNV_defined
#endif
#ifndef glGetCombinerOutputParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCombinerOutputParameterfvNV, (stage, portion, pname, params), (GLenum stage, GLenum portion, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetCombinerOutputParameterfvNV_debug(GLenum stage, GLenum portion, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerOutputParameterfvNV, "(%s, %s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCombinerOutputParameterfvNV_defined
#endif
#ifndef glGetCombinerOutputParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCombinerOutputParameterivNV, (stage, portion, pname, params), (GLenum stage, GLenum portion, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetCombinerOutputParameterivNV_debug(GLenum stage, GLenum portion, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerOutputParameterivNV, "(%s, %s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerOutputParameterivNV(stage, portion, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCombinerOutputParameterivNV_defined
#endif
#ifndef glGetFinalCombinerInputParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFinalCombinerInputParameterfvNV, (variable, pname, params), (GLenum variable, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFinalCombinerInputParameterfvNV_debug(GLenum variable, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFinalCombinerInputParameterfvNV, "(%s, %s, %p)", enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFinalCombinerInputParameterfvNV(variable, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFinalCombinerInputParameterfvNV_defined
#endif
#ifndef glGetFinalCombinerInputParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFinalCombinerInputParameterivNV, (variable, pname, params), (GLenum variable, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFinalCombinerInputParameterivNV_debug(GLenum variable, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFinalCombinerInputParameterivNV, "(%s, %s, %p)", enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFinalCombinerInputParameterivNV(variable, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFinalCombinerInputParameterivNV_defined
#endif
#endif // defined(GL_NV_register_combiners)
#if defined(GL_NV_register_combiners2)
#ifndef glCombinerStageParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCombinerStageParameterfvNV, (stage, pname, params), (GLenum stage, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glCombinerStageParameterfvNV_debug(GLenum stage, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerStageParameterfvNV, "(%s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerStageParameterfvNV(stage, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCombinerStageParameterfvNV_defined
#endif
#ifndef glGetCombinerStageParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCombinerStageParameterfvNV, (stage, pname, params), (GLenum stage, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetCombinerStageParameterfvNV_debug(GLenum stage, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerStageParameterfvNV, "(%s, %s, %p)", enum_to_string_GL(stage), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerStageParameterfvNV(stage, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCombinerStageParameterfvNV_defined
#endif
#endif // defined(GL_NV_register_combiners2)
#if defined(GL_NV_sample_locations)
#ifndef glFramebufferSampleLocationsfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferSampleLocationsfvNV, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferSampleLocationsfvNV_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvNV(target, start, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferSampleLocationsfvNV_defined
#endif
#ifndef glNamedFramebufferSampleLocationsfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferSampleLocationsfvNV, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferSampleLocationsfvNV_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvNV, "(%u, %u, %d, %p)", (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferSampleLocationsfvNV_defined
#endif
#ifndef glResolveDepthValuesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResolveDepthValuesNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glResolveDepthValuesNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResolveDepthValuesNV, "()")
    glatter_glResolveDepthValuesNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResolveDepthValuesNV_defined
#endif
#endif // defined(GL_NV_sample_locations)
#if defined(GL_NV_scissor_exclusive)
#ifndef glScissorExclusiveArrayvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScissorExclusiveArrayvNV, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glScissorExclusiveArrayvNV_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorExclusiveArrayvNV, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorExclusiveArrayvNV(first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScissorExclusiveArrayvNV_defined
#endif
#ifndef glScissorExclusiveNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScissorExclusiveNV, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glScissorExclusiveNV_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorExclusiveNV, "(%d, %d, %d, %d)", (int)x, (int)y, (int)width, (int)height)
    glatter_glScissorExclusiveNV(x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScissorExclusiveNV_defined
#endif
#endif // defined(GL_NV_scissor_exclusive)
#if defined(GL_NV_shader_buffer_load)
#ifndef glGetBufferParameterui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferParameterui64vNV, (target, pname, params), (GLenum target, GLenum pname, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferParameterui64vNV_debug(GLenum target, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameterui64vNV, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameterui64vNV(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferParameterui64vNV_defined
#endif
#ifndef glGetIntegerui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetIntegerui64vNV, (value, result), (GLenum value, GLuint64EXT *result))
GLATTER_INLINE_OR_NOT void glatter_glGetIntegerui64vNV_debug(GLenum value, GLuint64EXT *result, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerui64vNV, "(%s, %p)", enum_to_string_GL(value), (void*)result)
    glatter_glGetIntegerui64vNV(value, result);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetIntegerui64vNV_defined
#endif
#ifndef glGetNamedBufferParameterui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferParameterui64vNV, (buffer, pname, params), (GLuint buffer, GLenum pname, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferParameterui64vNV_debug(GLuint buffer, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameterui64vNV, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameterui64vNV(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferParameterui64vNV_defined
#endif
#ifndef glIsBufferResidentNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsBufferResidentNV, (target), (GLenum target))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsBufferResidentNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBufferResidentNV, "(%s)", enum_to_string_GL(target))
    GLboolean rval = glatter_glIsBufferResidentNV(target);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsBufferResidentNV_defined
#endif
#ifndef glIsNamedBufferResidentNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsNamedBufferResidentNV, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsNamedBufferResidentNV_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNamedBufferResidentNV, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glIsNamedBufferResidentNV(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsNamedBufferResidentNV_defined
#endif
#ifndef glMakeBufferNonResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeBufferNonResidentNV, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glMakeBufferNonResidentNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeBufferNonResidentNV, "(%s)", enum_to_string_GL(target))
    glatter_glMakeBufferNonResidentNV(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeBufferNonResidentNV_defined
#endif
#ifndef glMakeBufferResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeBufferResidentNV, (target, access), (GLenum target, GLenum access))
GLATTER_INLINE_OR_NOT void glatter_glMakeBufferResidentNV_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeBufferResidentNV, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(access))
    glatter_glMakeBufferResidentNV(target, access);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeBufferResidentNV_defined
#endif
#ifndef glMakeNamedBufferNonResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeNamedBufferNonResidentNV, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glMakeNamedBufferNonResidentNV_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeNamedBufferNonResidentNV, "(%u)", (unsigned int)buffer)
    glatter_glMakeNamedBufferNonResidentNV(buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeNamedBufferNonResidentNV_defined
#endif
#ifndef glMakeNamedBufferResidentNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMakeNamedBufferResidentNV, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_INLINE_OR_NOT void glatter_glMakeNamedBufferResidentNV_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeNamedBufferResidentNV, "(%u, %s)", (unsigned int)buffer, enum_to_string_GL(access))
    glatter_glMakeNamedBufferResidentNV(buffer, access);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMakeNamedBufferResidentNV_defined
#endif
#ifndef glProgramUniformui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformui64NV, (program, location, value), (GLuint program, GLint location, GLuint64EXT value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformui64NV_debug(GLuint program, GLint location, GLuint64EXT value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformui64NV, "(%u, %d, %s)", (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformui64NV(program, location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformui64NV_defined
#endif
#ifndef glProgramUniformui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformui64vNV, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniformui64vNV(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformui64vNV_defined
#endif
#ifndef glUniformui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformui64NV, (location, value), (GLint location, GLuint64EXT value))
GLATTER_INLINE_OR_NOT void glatter_glUniformui64NV_debug(GLint location, GLuint64EXT value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformui64NV, "(%d, %s)", (int)location, GET_PRS(value))
    glatter_glUniformui64NV(location, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformui64NV_defined
#endif
#ifndef glUniformui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformui64vNV, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniformui64vNV(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformui64vNV_defined
#endif
#endif // defined(GL_NV_shader_buffer_load)
#if defined(GL_NV_shading_rate_image)
#ifndef glBindShadingRateImageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindShadingRateImageNV, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glBindShadingRateImageNV_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindShadingRateImageNV, "(%u)", (unsigned int)texture)
    glatter_glBindShadingRateImageNV(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindShadingRateImageNV_defined
#endif
#ifndef glGetShadingRateImagePaletteNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShadingRateImagePaletteNV, (viewport, entry, rate), (GLuint viewport, GLuint entry, GLenum *rate))
GLATTER_INLINE_OR_NOT void glatter_glGetShadingRateImagePaletteNV_debug(GLuint viewport, GLuint entry, GLenum *rate, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShadingRateImagePaletteNV, "(%u, %u, %p)", (unsigned int)viewport, (unsigned int)entry, (void*)rate)
    glatter_glGetShadingRateImagePaletteNV(viewport, entry, rate);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShadingRateImagePaletteNV_defined
#endif
#ifndef glGetShadingRateSampleLocationivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShadingRateSampleLocationivNV, (rate, samples, index, location), (GLenum rate, GLuint samples, GLuint index, GLint *location))
GLATTER_INLINE_OR_NOT void glatter_glGetShadingRateSampleLocationivNV_debug(GLenum rate, GLuint samples, GLuint index, GLint *location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShadingRateSampleLocationivNV, "(%s, %u, %u, %p)", enum_to_string_GL(rate), (unsigned int)samples, (unsigned int)index, (void*)location)
    glatter_glGetShadingRateSampleLocationivNV(rate, samples, index, location);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShadingRateSampleLocationivNV_defined
#endif
#ifndef glShadingRateImageBarrierNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShadingRateImageBarrierNV, (synchronize), (GLboolean synchronize))
GLATTER_INLINE_OR_NOT void glatter_glShadingRateImageBarrierNV_debug(GLboolean synchronize, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShadingRateImageBarrierNV, "(%u)", (unsigned char)synchronize)
    glatter_glShadingRateImageBarrierNV(synchronize);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShadingRateImageBarrierNV_defined
#endif
#ifndef glShadingRateImagePaletteNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShadingRateImagePaletteNV, (viewport, first, count, rates), (GLuint viewport, GLuint first, GLsizei count, const GLenum *rates))
GLATTER_INLINE_OR_NOT void glatter_glShadingRateImagePaletteNV_debug(GLuint viewport, GLuint first, GLsizei count, const GLenum *rates, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShadingRateImagePaletteNV, "(%u, %u, %d, %p)", (unsigned int)viewport, (unsigned int)first, (int)count, (void*)rates)
    glatter_glShadingRateImagePaletteNV(viewport, first, count, rates);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShadingRateImagePaletteNV_defined
#endif
#ifndef glShadingRateSampleOrderCustomNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShadingRateSampleOrderCustomNV, (rate, samples, locations), (GLenum rate, GLuint samples, const GLint *locations))
GLATTER_INLINE_OR_NOT void glatter_glShadingRateSampleOrderCustomNV_debug(GLenum rate, GLuint samples, const GLint *locations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShadingRateSampleOrderCustomNV, "(%s, %u, %p)", enum_to_string_GL(rate), (unsigned int)samples, (void*)locations)
    glatter_glShadingRateSampleOrderCustomNV(rate, samples, locations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShadingRateSampleOrderCustomNV_defined
#endif
#ifndef glShadingRateSampleOrderNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShadingRateSampleOrderNV, (order), (GLenum order))
GLATTER_INLINE_OR_NOT void glatter_glShadingRateSampleOrderNV_debug(GLenum order, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShadingRateSampleOrderNV, "(%s)", enum_to_string_GL(order))
    glatter_glShadingRateSampleOrderNV(order);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShadingRateSampleOrderNV_defined
#endif
#endif // defined(GL_NV_shading_rate_image)
#if defined(GL_NV_texture_barrier)
#ifndef glTextureBarrierNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBarrierNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glTextureBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBarrierNV, "()")
    glatter_glTextureBarrierNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBarrierNV_defined
#endif
#endif // defined(GL_NV_texture_barrier)
#if defined(GL_NV_texture_multisample)
#ifndef glTexImage2DMultisampleCoverageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage2DMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTexImage2DMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2DMultisampleCoverageNV, "(%s, %d, %d, %d, %d, %d, %u)", enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage2DMultisampleCoverageNV_defined
#endif
#ifndef glTexImage3DMultisampleCoverageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage3DMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTexImage3DMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DMultisampleCoverageNV, "(%s, %d, %d, %d, %d, %d, %d, %u)", enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage3DMultisampleCoverageNV_defined
#endif
#ifndef glTextureImage2DMultisampleCoverageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage2DMultisampleCoverageNV, (texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage2DMultisampleCoverageNV_debug(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DMultisampleCoverageNV, "(%u, %s, %d, %d, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage2DMultisampleCoverageNV_defined
#endif
#ifndef glTextureImage2DMultisampleNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage2DMultisampleNV, (texture, target, samples, internalFormat, width, height, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage2DMultisampleNV_debug(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DMultisampleNV, "(%u, %s, %d, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)samples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage2DMultisampleNV_defined
#endif
#ifndef glTextureImage3DMultisampleCoverageNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage3DMultisampleCoverageNV, (texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage3DMultisampleCoverageNV_debug(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DMultisampleCoverageNV, "(%u, %s, %d, %d, %d, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage3DMultisampleCoverageNV_defined
#endif
#ifndef glTextureImage3DMultisampleNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureImage3DMultisampleNV, (texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureImage3DMultisampleNV_debug(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DMultisampleNV, "(%u, %s, %d, %d, %d, %d, %d, %u)", (unsigned int)texture, enum_to_string_GL(target), (int)samples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureImage3DMultisampleNV_defined
#endif
#endif // defined(GL_NV_texture_multisample)
#if defined(GL_NV_timeline_semaphore)
#ifndef glCreateSemaphoresNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateSemaphoresNV, (n, semaphores), (GLsizei n, GLuint *semaphores))
GLATTER_INLINE_OR_NOT void glatter_glCreateSemaphoresNV_debug(GLsizei n, GLuint *semaphores, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSemaphoresNV, "(%d, %p)", (int)n, (void*)semaphores)
    glatter_glCreateSemaphoresNV(n, semaphores);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateSemaphoresNV_defined
#endif
#ifndef glGetSemaphoreParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSemaphoreParameterivNV, (semaphore, pname, params), (GLuint semaphore, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSemaphoreParameterivNV_debug(GLuint semaphore, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSemaphoreParameterivNV, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSemaphoreParameterivNV(semaphore, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSemaphoreParameterivNV_defined
#endif
#ifndef glSemaphoreParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSemaphoreParameterivNV, (semaphore, pname, params), (GLuint semaphore, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glSemaphoreParameterivNV_debug(GLuint semaphore, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSemaphoreParameterivNV, "(%u, %s, %p)", (unsigned int)semaphore, enum_to_string_GL(pname), (void*)params)
    glatter_glSemaphoreParameterivNV(semaphore, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSemaphoreParameterivNV_defined
#endif
#endif // defined(GL_NV_timeline_semaphore)
#if defined(GL_NV_transform_feedback)
#ifndef glActiveVaryingNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveVaryingNV, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glActiveVaryingNV_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveVaryingNV, "(%u, %p)", (unsigned int)program, (void*)name)
    glatter_glActiveVaryingNV(program, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveVaryingNV_defined
#endif
#ifndef glBeginTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginTransformFeedbackNV, (primitiveMode), (GLenum primitiveMode))
GLATTER_INLINE_OR_NOT void glatter_glBeginTransformFeedbackNV_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedbackNV, "(%s)", enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedbackNV(primitiveMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginTransformFeedbackNV_defined
#endif
#ifndef glBindBufferBaseNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferBaseNV, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferBaseNV_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBaseNV, "(%s, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBaseNV(target, index, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferBaseNV_defined
#endif
#ifndef glBindBufferOffsetNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferOffsetNV, (target, index, buffer, offset), (GLenum target, GLuint index, GLuint buffer, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferOffsetNV_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferOffsetNV, "(%s, %u, %u, %s)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, GET_PRS(offset))
    glatter_glBindBufferOffsetNV(target, index, buffer, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferOffsetNV_defined
#endif
#ifndef glBindBufferRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferRangeNV, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferRangeNV_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRangeNV, "(%s, %u, %u, %s, %s)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glBindBufferRangeNV(target, index, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferRangeNV_defined
#endif
#ifndef glEndTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndTransformFeedbackNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedbackNV, "()")
    glatter_glEndTransformFeedbackNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndTransformFeedbackNV_defined
#endif
#ifndef glGetActiveVaryingNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveVaryingNV, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveVaryingNV_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveVaryingNV, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveVaryingNV_defined
#endif
#ifndef glGetTransformFeedbackVaryingNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbackVaryingNV, (program, index, location), (GLuint program, GLuint index, GLint *location))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbackVaryingNV_debug(GLuint program, GLuint index, GLint *location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVaryingNV, "(%u, %u, %p)", (unsigned int)program, (unsigned int)index, (void*)location)
    glatter_glGetTransformFeedbackVaryingNV(program, index, location);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbackVaryingNV_defined
#endif
#ifndef glGetVaryingLocationNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetVaryingLocationNV, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetVaryingLocationNV_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVaryingLocationNV, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetVaryingLocationNV(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetVaryingLocationNV_defined
#endif
#ifndef glTransformFeedbackAttribsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackAttribsNV, (count, attribs, bufferMode), (GLsizei count, const GLint *attribs, GLenum bufferMode))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackAttribsNV_debug(GLsizei count, const GLint *attribs, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackAttribsNV, "(%d, %p, %s)", (int)count, (void*)attribs, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackAttribsNV(count, attribs, bufferMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackAttribsNV_defined
#endif
#ifndef glTransformFeedbackStreamAttribsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackStreamAttribsNV, (count, attribs, nbuffers, bufstreams, bufferMode), (GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackStreamAttribsNV_debug(GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackStreamAttribsNV, "(%d, %p, %d, %p, %s)", (int)count, (void*)attribs, (int)nbuffers, (void*)bufstreams, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackStreamAttribsNV_defined
#endif
#ifndef glTransformFeedbackVaryingsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackVaryingsNV, (program, count, locations, bufferMode), (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackVaryingsNV_debug(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryingsNV, "(%u, %d, %p, %s)", (unsigned int)program, (int)count, (void*)locations, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackVaryingsNV_defined
#endif
#endif // defined(GL_NV_transform_feedback)
#if defined(GL_NV_transform_feedback2)
#ifndef glBindTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindTransformFeedbackNV, (target, id), (GLenum target, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBindTransformFeedbackNV_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedbackNV, "(%s, %u)", enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedbackNV(target, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindTransformFeedbackNV_defined
#endif
#ifndef glDeleteTransformFeedbacksNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteTransformFeedbacksNV, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glDeleteTransformFeedbacksNV_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacksNV, "(%d, %p)", (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacksNV(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteTransformFeedbacksNV_defined
#endif
#ifndef glDrawTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTransformFeedbackNV, (mode, id), (GLenum mode, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glDrawTransformFeedbackNV_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackNV, "(%s, %u)", enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedbackNV(mode, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTransformFeedbackNV_defined
#endif
#ifndef glGenTransformFeedbacksNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenTransformFeedbacksNV, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glGenTransformFeedbacksNV_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacksNV, "(%d, %p)", (int)n, (void*)ids)
    glatter_glGenTransformFeedbacksNV(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenTransformFeedbacksNV_defined
#endif
#ifndef glIsTransformFeedbackNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsTransformFeedbackNV, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsTransformFeedbackNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedbackNV, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedbackNV(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsTransformFeedbackNV_defined
#endif
#ifndef glPauseTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPauseTransformFeedbackNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glPauseTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedbackNV, "()")
    glatter_glPauseTransformFeedbackNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPauseTransformFeedbackNV_defined
#endif
#ifndef glResumeTransformFeedbackNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResumeTransformFeedbackNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glResumeTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedbackNV, "()")
    glatter_glResumeTransformFeedbackNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResumeTransformFeedbackNV_defined
#endif
#endif // defined(GL_NV_transform_feedback2)
#if defined(GL_NV_vdpau_interop)
#ifndef glVDPAUFiniNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUFiniNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUFiniNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUFiniNV, "()")
    glatter_glVDPAUFiniNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUFiniNV_defined
#endif
#ifndef glVDPAUGetSurfaceivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUGetSurfaceivNV, (surface, pname, count, length, values), (GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei *length, GLint *values))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUGetSurfaceivNV_debug(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUGetSurfaceivNV, "(%s, %s, %d, %p, %p)", GET_PRS(surface), enum_to_string_GL(pname), (int)count, (void*)length, (void*)values)
    glatter_glVDPAUGetSurfaceivNV(surface, pname, count, length, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUGetSurfaceivNV_defined
#endif
#ifndef glVDPAUInitNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUInitNV, (vdpDevice, getProcAddress), (const void *vdpDevice, const void *getProcAddress))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUInitNV_debug(const void *vdpDevice, const void *getProcAddress, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUInitNV, "(%p, %p)", (void*)vdpDevice, (void*)getProcAddress)
    glatter_glVDPAUInitNV(vdpDevice, getProcAddress);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUInitNV_defined
#endif
#ifndef glVDPAUIsSurfaceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glVDPAUIsSurfaceNV, (surface), (GLvdpauSurfaceNV surface))
GLATTER_INLINE_OR_NOT GLboolean glatter_glVDPAUIsSurfaceNV_debug(GLvdpauSurfaceNV surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUIsSurfaceNV, "(%s)", GET_PRS(surface))
    GLboolean rval = glatter_glVDPAUIsSurfaceNV(surface);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glVDPAUIsSurfaceNV_defined
#endif
#ifndef glVDPAUMapSurfacesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUMapSurfacesNV, (numSurfaces, surfaces), (GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUMapSurfacesNV_debug(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUMapSurfacesNV, "(%d, %p)", (int)numSurfaces, (void*)surfaces)
    glatter_glVDPAUMapSurfacesNV(numSurfaces, surfaces);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUMapSurfacesNV_defined
#endif
#ifndef glVDPAURegisterOutputSurfaceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLvdpauSurfaceNV, APIENTRY, glVDPAURegisterOutputSurfaceNV, (vdpSurface, target, numTextureNames, textureNames), (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames))
GLATTER_INLINE_OR_NOT GLvdpauSurfaceNV glatter_glVDPAURegisterOutputSurfaceNV_debug(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAURegisterOutputSurfaceNV, "(%p, %s, %d, %p)", (void*)vdpSurface, enum_to_string_GL(target), (int)numTextureNames, (void*)textureNames)
    GLvdpauSurfaceNV rval = glatter_glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glVDPAURegisterOutputSurfaceNV_defined
#endif
#ifndef glVDPAURegisterVideoSurfaceNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLvdpauSurfaceNV, APIENTRY, glVDPAURegisterVideoSurfaceNV, (vdpSurface, target, numTextureNames, textureNames), (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames))
GLATTER_INLINE_OR_NOT GLvdpauSurfaceNV glatter_glVDPAURegisterVideoSurfaceNV_debug(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAURegisterVideoSurfaceNV, "(%p, %s, %d, %p)", (void*)vdpSurface, enum_to_string_GL(target), (int)numTextureNames, (void*)textureNames)
    GLvdpauSurfaceNV rval = glatter_glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glVDPAURegisterVideoSurfaceNV_defined
#endif
#ifndef glVDPAUSurfaceAccessNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUSurfaceAccessNV, (surface, access), (GLvdpauSurfaceNV surface, GLenum access))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUSurfaceAccessNV_debug(GLvdpauSurfaceNV surface, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUSurfaceAccessNV, "(%s, %s)", GET_PRS(surface), enum_to_string_GL(access))
    glatter_glVDPAUSurfaceAccessNV(surface, access);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUSurfaceAccessNV_defined
#endif
#ifndef glVDPAUUnmapSurfacesNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUUnmapSurfacesNV, (numSurface, surfaces), (GLsizei numSurface, const GLvdpauSurfaceNV *surfaces))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUUnmapSurfacesNV_debug(GLsizei numSurface, const GLvdpauSurfaceNV *surfaces, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUUnmapSurfacesNV, "(%d, %p)", (int)numSurface, (void*)surfaces)
    glatter_glVDPAUUnmapSurfacesNV(numSurface, surfaces);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUUnmapSurfacesNV_defined
#endif
#ifndef glVDPAUUnregisterSurfaceNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVDPAUUnregisterSurfaceNV, (surface), (GLvdpauSurfaceNV surface))
GLATTER_INLINE_OR_NOT void glatter_glVDPAUUnregisterSurfaceNV_debug(GLvdpauSurfaceNV surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUUnregisterSurfaceNV, "(%s)", GET_PRS(surface))
    glatter_glVDPAUUnregisterSurfaceNV(surface);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVDPAUUnregisterSurfaceNV_defined
#endif
#endif // defined(GL_NV_vdpau_interop)
#if defined(GL_NV_vdpau_interop2)
#ifndef glVDPAURegisterVideoSurfaceWithPictureStructureNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLvdpauSurfaceNV, APIENTRY, glVDPAURegisterVideoSurfaceWithPictureStructureNV, (vdpSurface, target, numTextureNames, textureNames, isFrameStructure), (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure))
GLATTER_INLINE_OR_NOT GLvdpauSurfaceNV glatter_glVDPAURegisterVideoSurfaceWithPictureStructureNV_debug(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAURegisterVideoSurfaceWithPictureStructureNV, "(%p, %s, %d, %p, %u)", (void*)vdpSurface, enum_to_string_GL(target), (int)numTextureNames, (void*)textureNames, (unsigned char)isFrameStructure)
    GLvdpauSurfaceNV rval = glatter_glVDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glVDPAURegisterVideoSurfaceWithPictureStructureNV_defined
#endif
#endif // defined(GL_NV_vdpau_interop2)
#if defined(GL_NV_vertex_array_range)
#ifndef glFlushVertexArrayRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushVertexArrayRangeNV, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glFlushVertexArrayRangeNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushVertexArrayRangeNV, "()")
    glatter_glFlushVertexArrayRangeNV();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushVertexArrayRangeNV_defined
#endif
#ifndef glVertexArrayRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayRangeNV, (length, pointer), (GLsizei length, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayRangeNV_debug(GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayRangeNV, "(%d, %p)", (int)length, (void*)pointer)
    glatter_glVertexArrayRangeNV(length, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayRangeNV_defined
#endif
#endif // defined(GL_NV_vertex_array_range)
#if defined(GL_NV_vertex_attrib_integer_64bit)
#ifndef glGetVertexAttribLi64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribLi64vNV, (index, pname, params), (GLuint index, GLenum pname, GLint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribLi64vNV_debug(GLuint index, GLenum pname, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLi64vNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLi64vNV(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribLi64vNV_defined
#endif
#ifndef glGetVertexAttribLui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribLui64vNV, (index, pname, params), (GLuint index, GLenum pname, GLuint64EXT *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribLui64vNV_debug(GLuint index, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLui64vNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLui64vNV(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribLui64vNV_defined
#endif
#ifndef glVertexAttribL1i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1i64NV, (index, x), (GLuint index, GLint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1i64NV_debug(GLuint index, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1i64NV, "(%u, %s)", (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1i64NV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1i64NV_defined
#endif
#ifndef glVertexAttribL1i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1i64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1i64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1i64vNV_defined
#endif
#ifndef glVertexAttribL1ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1ui64NV, (index, x), (GLuint index, GLuint64EXT x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1ui64NV_debug(GLuint index, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64NV, "(%u, %s)", (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1ui64NV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1ui64NV_defined
#endif
#ifndef glVertexAttribL1ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1ui64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1ui64vNV_defined
#endif
#ifndef glVertexAttribL2i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2i64NV, (index, x, y), (GLuint index, GLint64EXT x, GLint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2i64NV, "(%u, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y))
    glatter_glVertexAttribL2i64NV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2i64NV_defined
#endif
#ifndef glVertexAttribL2i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2i64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2i64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2i64vNV_defined
#endif
#ifndef glVertexAttribL2ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2ui64NV, (index, x, y), (GLuint index, GLuint64EXT x, GLuint64EXT y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2ui64NV, "(%u, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y))
    glatter_glVertexAttribL2ui64NV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2ui64NV_defined
#endif
#ifndef glVertexAttribL2ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2ui64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2ui64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2ui64vNV_defined
#endif
#ifndef glVertexAttribL3i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3i64NV, (index, x, y, z), (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3i64NV, "(%u, %s, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glVertexAttribL3i64NV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3i64NV_defined
#endif
#ifndef glVertexAttribL3i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3i64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3i64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3i64vNV_defined
#endif
#ifndef glVertexAttribL3ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3ui64NV, (index, x, y, z), (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3ui64NV, "(%u, %s, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glVertexAttribL3ui64NV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3ui64NV_defined
#endif
#ifndef glVertexAttribL3ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3ui64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3ui64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3ui64vNV_defined
#endif
#ifndef glVertexAttribL4i64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4i64NV, (index, x, y, z, w), (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4i64NV, "(%u, %s, %s, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glVertexAttribL4i64NV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4i64NV_defined
#endif
#ifndef glVertexAttribL4i64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4i64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4i64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4i64vNV_defined
#endif
#ifndef glVertexAttribL4ui64NV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4ui64NV, (index, x, y, z, w), (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4ui64NV, "(%u, %s, %s, %s, %s)", (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glVertexAttribL4ui64NV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4ui64NV_defined
#endif
#ifndef glVertexAttribL4ui64vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4ui64vNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4ui64vNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4ui64vNV_defined
#endif
#ifndef glVertexAttribLFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribLFormatNV, (index, size, type, stride), (GLuint index, GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribLFormatNV_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLFormatNV, "(%u, %d, %s, %d)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexAttribLFormatNV(index, size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribLFormatNV_defined
#endif
#endif // defined(GL_NV_vertex_attrib_integer_64bit)
#if defined(GL_NV_vertex_buffer_unified_memory)
#ifndef glBufferAddressRangeNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferAddressRangeNV, (pname, index, address, length), (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length))
GLATTER_INLINE_OR_NOT void glatter_glBufferAddressRangeNV_debug(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferAddressRangeNV, "(%s, %u, %s, %s)", enum_to_string_GL(pname), (unsigned int)index, GET_PRS(address), GET_PRS(length))
    glatter_glBufferAddressRangeNV(pname, index, address, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferAddressRangeNV_defined
#endif
#ifndef glColorFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glColorFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFormatNV, "(%d, %s, %d)", (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glColorFormatNV(size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorFormatNV_defined
#endif
#ifndef glEdgeFlagFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEdgeFlagFormatNV, (stride), (GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glEdgeFlagFormatNV_debug(GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagFormatNV, "(%d)", (int)stride)
    glatter_glEdgeFlagFormatNV(stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEdgeFlagFormatNV_defined
#endif
#ifndef glFogCoordFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordFormatNV, "(%s, %d)", enum_to_string_GL(type), (int)stride)
    glatter_glFogCoordFormatNV(type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordFormatNV_defined
#endif
#ifndef glGetIntegerui64i_vNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetIntegerui64i_vNV, (value, index, result), (GLenum value, GLuint index, GLuint64EXT *result))
GLATTER_INLINE_OR_NOT void glatter_glGetIntegerui64i_vNV_debug(GLenum value, GLuint index, GLuint64EXT *result, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerui64i_vNV, "(%s, %u, %p)", enum_to_string_GL(value), (unsigned int)index, (void*)result)
    glatter_glGetIntegerui64i_vNV(value, index, result);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetIntegerui64i_vNV_defined
#endif
#ifndef glIndexFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glIndexFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexFormatNV, "(%s, %d)", enum_to_string_GL(type), (int)stride)
    glatter_glIndexFormatNV(type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexFormatNV_defined
#endif
#ifndef glNormalFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glNormalFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalFormatNV, "(%s, %d)", enum_to_string_GL(type), (int)stride)
    glatter_glNormalFormatNV(type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalFormatNV_defined
#endif
#ifndef glSecondaryColorFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorFormatNV, "(%d, %s, %d)", (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glSecondaryColorFormatNV(size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorFormatNV_defined
#endif
#ifndef glTexCoordFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordFormatNV, "(%d, %s, %d)", (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glTexCoordFormatNV(size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordFormatNV_defined
#endif
#ifndef glVertexAttribFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribFormatNV, (index, size, type, normalized, stride), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribFormatNV_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormatNV, "(%u, %d, %s, %u, %d)", (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride)
    glatter_glVertexAttribFormatNV(index, size, type, normalized, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribFormatNV_defined
#endif
#ifndef glVertexAttribIFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribIFormatNV, (index, size, type, stride), (GLuint index, GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribIFormatNV_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormatNV, "(%u, %d, %s, %d)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexAttribIFormatNV(index, size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribIFormatNV_defined
#endif
#ifndef glVertexFormatNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexFormatNV, "(%d, %s, %d)", (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexFormatNV(size, type, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexFormatNV_defined
#endif
#endif // defined(GL_NV_vertex_buffer_unified_memory)
#if defined(GL_NV_vertex_program)
#ifndef glAreProgramsResidentNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glAreProgramsResidentNV, (n, programs, residences), (GLsizei n, const GLuint *programs, GLboolean *residences))
GLATTER_INLINE_OR_NOT GLboolean glatter_glAreProgramsResidentNV_debug(GLsizei n, const GLuint *programs, GLboolean *residences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAreProgramsResidentNV, "(%d, %p, %p)", (int)n, (void*)programs, (void*)residences)
    GLboolean rval = glatter_glAreProgramsResidentNV(n, programs, residences);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glAreProgramsResidentNV_defined
#endif
#ifndef glBindProgramNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindProgramNV, (target, id), (GLenum target, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBindProgramNV_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramNV, "(%s, %u)", enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindProgramNV(target, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindProgramNV_defined
#endif
#ifndef glDeleteProgramsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteProgramsNV, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_INLINE_OR_NOT void glatter_glDeleteProgramsNV_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramsNV, "(%d, %p)", (int)n, (void*)programs)
    glatter_glDeleteProgramsNV(n, programs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteProgramsNV_defined
#endif
#ifndef glExecuteProgramNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glExecuteProgramNV, (target, id, params), (GLenum target, GLuint id, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glExecuteProgramNV_debug(GLenum target, GLuint id, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExecuteProgramNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)id, (void*)params)
    glatter_glExecuteProgramNV(target, id, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glExecuteProgramNV_defined
#endif
#ifndef glGenProgramsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenProgramsNV, (n, programs), (GLsizei n, GLuint *programs))
GLATTER_INLINE_OR_NOT void glatter_glGenProgramsNV_debug(GLsizei n, GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramsNV, "(%d, %p)", (int)n, (void*)programs)
    glatter_glGenProgramsNV(n, programs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenProgramsNV_defined
#endif
#ifndef glGetProgramParameterdvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramParameterdvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramParameterdvNV_debug(GLenum target, GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramParameterdvNV, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramParameterdvNV(target, index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramParameterdvNV_defined
#endif
#ifndef glGetProgramParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramParameterfvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramParameterfvNV_debug(GLenum target, GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramParameterfvNV, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramParameterfvNV(target, index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramParameterfvNV_defined
#endif
#ifndef glGetProgramStringNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramStringNV, (id, pname, program), (GLuint id, GLenum pname, GLubyte *program))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramStringNV_debug(GLuint id, GLenum pname, GLubyte *program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStringNV, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)program)
    glatter_glGetProgramStringNV(id, pname, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramStringNV_defined
#endif
#ifndef glGetProgramivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramivNV, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramivNV_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramivNV, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramivNV(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramivNV_defined
#endif
#ifndef glGetTrackMatrixivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTrackMatrixivNV, (target, address, pname, params), (GLenum target, GLuint address, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTrackMatrixivNV_debug(GLenum target, GLuint address, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTrackMatrixivNV, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)address, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTrackMatrixivNV(target, address, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTrackMatrixivNV_defined
#endif
#ifndef glGetVertexAttribPointervNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribPointervNV, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribPointervNV_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointervNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointervNV(index, pname, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribPointervNV_defined
#endif
#ifndef glGetVertexAttribdvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribdvNV, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribdvNV_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdvNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdvNV(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribdvNV_defined
#endif
#ifndef glGetVertexAttribfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribfvNV, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribfvNV_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfvNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfvNV(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribfvNV_defined
#endif
#ifndef glGetVertexAttribivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribivNV, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribivNV_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribivNV, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribivNV(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribivNV_defined
#endif
#ifndef glIsProgramNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsProgramNV, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsProgramNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramNV, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsProgramNV(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsProgramNV_defined
#endif
#ifndef glLoadProgramNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadProgramNV, (target, id, len, program), (GLenum target, GLuint id, GLsizei len, const GLubyte *program))
GLATTER_INLINE_OR_NOT void glatter_glLoadProgramNV_debug(GLenum target, GLuint id, GLsizei len, const GLubyte *program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadProgramNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)id, (int)len, (void*)program)
    glatter_glLoadProgramNV(target, id, len, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadProgramNV_defined
#endif
#ifndef glProgramParameter4dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameter4dNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameter4dNV_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4dNV, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramParameter4dNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameter4dNV_defined
#endif
#ifndef glProgramParameter4dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameter4dvNV, (target, index, v), (GLenum target, GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameter4dvNV_debug(GLenum target, GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4dvNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)v)
    glatter_glProgramParameter4dvNV(target, index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameter4dvNV_defined
#endif
#ifndef glProgramParameter4fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameter4fNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameter4fNV_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4fNV, "(%s, %u, %f, %f, %f, %f)", enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramParameter4fNV(target, index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameter4fNV_defined
#endif
#ifndef glProgramParameter4fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameter4fvNV, (target, index, v), (GLenum target, GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameter4fvNV_debug(GLenum target, GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4fvNV, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)v)
    glatter_glProgramParameter4fvNV(target, index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameter4fvNV_defined
#endif
#ifndef glProgramParameters4dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameters4dvNV, (target, index, count, v), (GLenum target, GLuint index, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameters4dvNV_debug(GLenum target, GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameters4dvNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)v)
    glatter_glProgramParameters4dvNV(target, index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameters4dvNV_defined
#endif
#ifndef glProgramParameters4fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameters4fvNV, (target, index, count, v), (GLenum target, GLuint index, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameters4fvNV_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameters4fvNV, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)v)
    glatter_glProgramParameters4fvNV(target, index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameters4fvNV_defined
#endif
#ifndef glRequestResidentProgramsNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRequestResidentProgramsNV, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_INLINE_OR_NOT void glatter_glRequestResidentProgramsNV_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRequestResidentProgramsNV, "(%d, %p)", (int)n, (void*)programs)
    glatter_glRequestResidentProgramsNV(n, programs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRequestResidentProgramsNV_defined
#endif
#ifndef glTrackMatrixNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTrackMatrixNV, (target, address, matrix, transform), (GLenum target, GLuint address, GLenum matrix, GLenum transform))
GLATTER_INLINE_OR_NOT void glatter_glTrackMatrixNV_debug(GLenum target, GLuint address, GLenum matrix, GLenum transform, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTrackMatrixNV, "(%s, %u, %s, %s)", enum_to_string_GL(target), (unsigned int)address, enum_to_string_GL(matrix), enum_to_string_GL(transform))
    glatter_glTrackMatrixNV(target, address, matrix, transform);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTrackMatrixNV_defined
#endif
#ifndef glVertexAttrib1dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1dNV, (index, x), (GLuint index, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1dNV_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dNV, "(%u, %f)", (unsigned int)index, (double)x)
    glatter_glVertexAttrib1dNV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1dNV_defined
#endif
#ifndef glVertexAttrib1dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1dvNV_defined
#endif
#ifndef glVertexAttrib1fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1fNV, (index, x), (GLuint index, GLfloat x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1fNV_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fNV, "(%u, %f)", (unsigned int)index, (float)x)
    glatter_glVertexAttrib1fNV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1fNV_defined
#endif
#ifndef glVertexAttrib1fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1fvNV_defined
#endif
#ifndef glVertexAttrib1sNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1sNV, (index, x), (GLuint index, GLshort x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1sNV_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sNV, "(%u, %hi)", (unsigned int)index, (short)x)
    glatter_glVertexAttrib1sNV(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1sNV_defined
#endif
#ifndef glVertexAttrib1svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1svNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1svNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1svNV_defined
#endif
#ifndef glVertexAttrib2dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2dNV, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2dNV_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dNV, "(%u, %f, %f)", (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2dNV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2dNV_defined
#endif
#ifndef glVertexAttrib2dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2dvNV_defined
#endif
#ifndef glVertexAttrib2fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2fNV, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2fNV_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fNV, "(%u, %f, %f)", (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2fNV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2fNV_defined
#endif
#ifndef glVertexAttrib2fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2fvNV_defined
#endif
#ifndef glVertexAttrib2sNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2sNV, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2sNV_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sNV, "(%u, %hi, %hi)", (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2sNV(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2sNV_defined
#endif
#ifndef glVertexAttrib2svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2svNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2svNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2svNV_defined
#endif
#ifndef glVertexAttrib3dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3dNV, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3dNV_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dNV, "(%u, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3dNV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3dNV_defined
#endif
#ifndef glVertexAttrib3dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3dvNV_defined
#endif
#ifndef glVertexAttrib3fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3fNV, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3fNV_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fNV, "(%u, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3fNV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3fNV_defined
#endif
#ifndef glVertexAttrib3fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3fvNV_defined
#endif
#ifndef glVertexAttrib3sNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3sNV, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3sNV_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sNV, "(%u, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3sNV(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3sNV_defined
#endif
#ifndef glVertexAttrib3svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3svNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3svNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3svNV_defined
#endif
#ifndef glVertexAttrib4dNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4dNV, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4dNV_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dNV, "(%u, %f, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4dNV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4dNV_defined
#endif
#ifndef glVertexAttrib4dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4dvNV_defined
#endif
#ifndef glVertexAttrib4fNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4fNV, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4fNV_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fNV, "(%u, %f, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4fNV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4fNV_defined
#endif
#ifndef glVertexAttrib4fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4fvNV_defined
#endif
#ifndef glVertexAttrib4sNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4sNV, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4sNV_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sNV, "(%u, %hi, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4sNV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4sNV_defined
#endif
#ifndef glVertexAttrib4svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4svNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4svNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4svNV_defined
#endif
#ifndef glVertexAttrib4ubNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4ubNV, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4ubNV_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubNV, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4ubNV(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4ubNV_defined
#endif
#ifndef glVertexAttrib4ubvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4ubvNV, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4ubvNV_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubvNV, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubvNV(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4ubvNV_defined
#endif
#ifndef glVertexAttribPointerNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribPointerNV, (index, fsize, type, stride, pointer), (GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribPointerNV_debug(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointerNV, "(%u, %d, %s, %d, %p)", (unsigned int)index, (int)fsize, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribPointerNV(index, fsize, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribPointerNV_defined
#endif
#ifndef glVertexAttribs1dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs1dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs1dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1dvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1dvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs1dvNV_defined
#endif
#ifndef glVertexAttribs1fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs1fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs1fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1fvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1fvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs1fvNV_defined
#endif
#ifndef glVertexAttribs1svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs1svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs1svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1svNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1svNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs1svNV_defined
#endif
#ifndef glVertexAttribs2dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs2dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs2dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2dvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2dvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs2dvNV_defined
#endif
#ifndef glVertexAttribs2fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs2fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs2fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2fvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2fvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs2fvNV_defined
#endif
#ifndef glVertexAttribs2svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs2svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs2svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2svNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2svNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs2svNV_defined
#endif
#ifndef glVertexAttribs3dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs3dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs3dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3dvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3dvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs3dvNV_defined
#endif
#ifndef glVertexAttribs3fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs3fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs3fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3fvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3fvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs3fvNV_defined
#endif
#ifndef glVertexAttribs3svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs3svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs3svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3svNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3svNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs3svNV_defined
#endif
#ifndef glVertexAttribs4dvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs4dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs4dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4dvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4dvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs4dvNV_defined
#endif
#ifndef glVertexAttribs4fvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs4fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs4fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4fvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4fvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs4fvNV_defined
#endif
#ifndef glVertexAttribs4svNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs4svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs4svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4svNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4svNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs4svNV_defined
#endif
#ifndef glVertexAttribs4ubvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribs4ubvNV, (index, count, v), (GLuint index, GLsizei count, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribs4ubvNV_debug(GLuint index, GLsizei count, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4ubvNV, "(%u, %d, %p)", (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4ubvNV(index, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribs4ubvNV_defined
#endif
#endif // defined(GL_NV_vertex_program)
#if defined(GL_NV_video_capture)
#ifndef glBeginVideoCaptureNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginVideoCaptureNV, (video_capture_slot), (GLuint video_capture_slot))
GLATTER_INLINE_OR_NOT void glatter_glBeginVideoCaptureNV_debug(GLuint video_capture_slot, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginVideoCaptureNV, "(%u)", (unsigned int)video_capture_slot)
    glatter_glBeginVideoCaptureNV(video_capture_slot);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginVideoCaptureNV_defined
#endif
#ifndef glBindVideoCaptureStreamBufferNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVideoCaptureStreamBufferNV, (video_capture_slot, stream, frame_region, offset), (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset))
GLATTER_INLINE_OR_NOT void glatter_glBindVideoCaptureStreamBufferNV_debug(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVideoCaptureStreamBufferNV, "(%u, %u, %s, %s)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(frame_region), GET_PRS(offset))
    glatter_glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVideoCaptureStreamBufferNV_defined
#endif
#ifndef glBindVideoCaptureStreamTextureNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVideoCaptureStreamTextureNV, (video_capture_slot, stream, frame_region, target, texture), (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glBindVideoCaptureStreamTextureNV_debug(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVideoCaptureStreamTextureNV, "(%u, %u, %s, %s, %u)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(frame_region), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVideoCaptureStreamTextureNV_defined
#endif
#ifndef glEndVideoCaptureNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndVideoCaptureNV, (video_capture_slot), (GLuint video_capture_slot))
GLATTER_INLINE_OR_NOT void glatter_glEndVideoCaptureNV_debug(GLuint video_capture_slot, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndVideoCaptureNV, "(%u)", (unsigned int)video_capture_slot)
    glatter_glEndVideoCaptureNV(video_capture_slot);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndVideoCaptureNV_defined
#endif
#ifndef glGetVideoCaptureStreamdvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoCaptureStreamdvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoCaptureStreamdvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamdvNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoCaptureStreamdvNV_defined
#endif
#ifndef glGetVideoCaptureStreamfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoCaptureStreamfvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoCaptureStreamfvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamfvNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoCaptureStreamfvNV_defined
#endif
#ifndef glGetVideoCaptureStreamivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoCaptureStreamivNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoCaptureStreamivNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamivNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoCaptureStreamivNV_defined
#endif
#ifndef glGetVideoCaptureivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVideoCaptureivNV, (video_capture_slot, pname, params), (GLuint video_capture_slot, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVideoCaptureivNV_debug(GLuint video_capture_slot, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureivNV, "(%u, %s, %p)", (unsigned int)video_capture_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureivNV(video_capture_slot, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVideoCaptureivNV_defined
#endif
#ifndef glVideoCaptureNV_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glVideoCaptureNV, (video_capture_slot, sequence_num, capture_time), (GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time))
GLATTER_INLINE_OR_NOT GLenum glatter_glVideoCaptureNV_debug(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureNV, "(%u, %p, %p)", (unsigned int)video_capture_slot, (void*)sequence_num, (void*)capture_time)
    GLenum rval = glatter_glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glVideoCaptureNV_defined
#endif
#ifndef glVideoCaptureStreamParameterdvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVideoCaptureStreamParameterdvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glVideoCaptureStreamParameterdvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterdvNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVideoCaptureStreamParameterdvNV_defined
#endif
#ifndef glVideoCaptureStreamParameterfvNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVideoCaptureStreamParameterfvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glVideoCaptureStreamParameterfvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterfvNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVideoCaptureStreamParameterfvNV_defined
#endif
#ifndef glVideoCaptureStreamParameterivNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVideoCaptureStreamParameterivNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glVideoCaptureStreamParameterivNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterivNV, "(%u, %u, %s, %p)", (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVideoCaptureStreamParameterivNV_defined
#endif
#endif // defined(GL_NV_video_capture)
#if defined(GL_NV_viewport_swizzle)
#ifndef glViewportSwizzleNV_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glViewportSwizzleNV, (index, swizzlex, swizzley, swizzlez, swizzlew), (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew))
GLATTER_INLINE_OR_NOT void glatter_glViewportSwizzleNV_debug(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportSwizzleNV, "(%u, %s, %s, %s, %s)", (unsigned int)index, enum_to_string_GL(swizzlex), enum_to_string_GL(swizzley), enum_to_string_GL(swizzlez), enum_to_string_GL(swizzlew))
    glatter_glViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glViewportSwizzleNV_defined
#endif
#endif // defined(GL_NV_viewport_swizzle)
#if defined(GL_OES_byte_coordinates)
#ifndef glMultiTexCoord1bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1bOES, (texture, s), (GLenum texture, GLbyte s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1bOES_debug(GLenum texture, GLbyte s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1bOES, "(%s, %d)", enum_to_string_GL(texture), (signed char)s)
    glatter_glMultiTexCoord1bOES(texture, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1bOES_defined
#endif
#ifndef glMultiTexCoord1bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1bvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord1bvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1bvOES_defined
#endif
#ifndef glMultiTexCoord2bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2bOES, (texture, s, t), (GLenum texture, GLbyte s, GLbyte t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2bOES_debug(GLenum texture, GLbyte s, GLbyte t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2bOES, "(%s, %d, %d)", enum_to_string_GL(texture), (signed char)s, (signed char)t)
    glatter_glMultiTexCoord2bOES(texture, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2bOES_defined
#endif
#ifndef glMultiTexCoord2bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2bvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord2bvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2bvOES_defined
#endif
#ifndef glMultiTexCoord3bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3bOES, (texture, s, t, r), (GLenum texture, GLbyte s, GLbyte t, GLbyte r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3bOES_debug(GLenum texture, GLbyte s, GLbyte t, GLbyte r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3bOES, "(%s, %d, %d, %d)", enum_to_string_GL(texture), (signed char)s, (signed char)t, (signed char)r)
    glatter_glMultiTexCoord3bOES(texture, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3bOES_defined
#endif
#ifndef glMultiTexCoord3bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3bvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord3bvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3bvOES_defined
#endif
#ifndef glMultiTexCoord4bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4bOES, (texture, s, t, r, q), (GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4bOES_debug(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4bOES, "(%s, %d, %d, %d, %d)", enum_to_string_GL(texture), (signed char)s, (signed char)t, (signed char)r, (signed char)q)
    glatter_glMultiTexCoord4bOES(texture, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4bOES_defined
#endif
#ifndef glMultiTexCoord4bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4bvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord4bvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4bvOES_defined
#endif
#ifndef glTexCoord1bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1bOES, (s), (GLbyte s))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1bOES_debug(GLbyte s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1bOES, "(%d)", (signed char)s)
    glatter_glTexCoord1bOES(s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1bOES_defined
#endif
#ifndef glTexCoord1bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1bvOES, "(%p)", (void*)coords)
    glatter_glTexCoord1bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1bvOES_defined
#endif
#ifndef glTexCoord2bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2bOES, (s, t), (GLbyte s, GLbyte t))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2bOES_debug(GLbyte s, GLbyte t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2bOES, "(%d, %d)", (signed char)s, (signed char)t)
    glatter_glTexCoord2bOES(s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2bOES_defined
#endif
#ifndef glTexCoord2bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2bvOES, "(%p)", (void*)coords)
    glatter_glTexCoord2bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2bvOES_defined
#endif
#ifndef glTexCoord3bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3bOES, (s, t, r), (GLbyte s, GLbyte t, GLbyte r))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3bOES_debug(GLbyte s, GLbyte t, GLbyte r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3bOES, "(%d, %d, %d)", (signed char)s, (signed char)t, (signed char)r)
    glatter_glTexCoord3bOES(s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3bOES_defined
#endif
#ifndef glTexCoord3bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3bvOES, "(%p)", (void*)coords)
    glatter_glTexCoord3bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3bvOES_defined
#endif
#ifndef glTexCoord4bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4bOES, (s, t, r, q), (GLbyte s, GLbyte t, GLbyte r, GLbyte q))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4bOES_debug(GLbyte s, GLbyte t, GLbyte r, GLbyte q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4bOES, "(%d, %d, %d, %d)", (signed char)s, (signed char)t, (signed char)r, (signed char)q)
    glatter_glTexCoord4bOES(s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4bOES_defined
#endif
#ifndef glTexCoord4bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4bvOES, "(%p)", (void*)coords)
    glatter_glTexCoord4bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4bvOES_defined
#endif
#ifndef glVertex2bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2bOES, (x, y), (GLbyte x, GLbyte y))
GLATTER_INLINE_OR_NOT void glatter_glVertex2bOES_debug(GLbyte x, GLbyte y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2bOES, "(%d, %d)", (signed char)x, (signed char)y)
    glatter_glVertex2bOES(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2bOES_defined
#endif
#ifndef glVertex2bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex2bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2bvOES, "(%p)", (void*)coords)
    glatter_glVertex2bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2bvOES_defined
#endif
#ifndef glVertex3bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3bOES, (x, y, z), (GLbyte x, GLbyte y, GLbyte z))
GLATTER_INLINE_OR_NOT void glatter_glVertex3bOES_debug(GLbyte x, GLbyte y, GLbyte z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3bOES, "(%d, %d, %d)", (signed char)x, (signed char)y, (signed char)z)
    glatter_glVertex3bOES(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3bOES_defined
#endif
#ifndef glVertex3bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex3bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3bvOES, "(%p)", (void*)coords)
    glatter_glVertex3bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3bvOES_defined
#endif
#ifndef glVertex4bOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4bOES, (x, y, z, w), (GLbyte x, GLbyte y, GLbyte z, GLbyte w))
GLATTER_INLINE_OR_NOT void glatter_glVertex4bOES_debug(GLbyte x, GLbyte y, GLbyte z, GLbyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4bOES, "(%d, %d, %d, %d)", (signed char)x, (signed char)y, (signed char)z, (signed char)w)
    glatter_glVertex4bOES(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4bOES_defined
#endif
#ifndef glVertex4bvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4bvOES, (coords), (const GLbyte *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex4bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4bvOES, "(%p)", (void*)coords)
    glatter_glVertex4bvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4bvOES_defined
#endif
#endif // defined(GL_OES_byte_coordinates)
#if defined(GL_OES_fixed_point)
#ifndef glAccumxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAccumxOES, (op, value), (GLenum op, GLfixed value))
GLATTER_INLINE_OR_NOT void glatter_glAccumxOES_debug(GLenum op, GLfixed value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAccumxOES, "(%s, %s)", enum_to_string_GL(op), GET_PRS(value))
    glatter_glAccumxOES(op, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAccumxOES_defined
#endif
#ifndef glAlphaFuncxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAlphaFuncxOES, (func, ref), (GLenum func, GLfixed ref))
GLATTER_INLINE_OR_NOT void glatter_glAlphaFuncxOES_debug(GLenum func, GLfixed ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFuncxOES, "(%s, %s)", enum_to_string_GL(func), GET_PRS(ref))
    glatter_glAlphaFuncxOES(func, ref);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAlphaFuncxOES_defined
#endif
#ifndef glBitmapxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBitmapxOES, (width, height, xorig, yorig, xmove, ymove, bitmap), (GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap))
GLATTER_INLINE_OR_NOT void glatter_glBitmapxOES_debug(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBitmapxOES, "(%d, %d, %s, %s, %s, %s, %p)", (int)width, (int)height, GET_PRS(xorig), GET_PRS(yorig), GET_PRS(xmove), GET_PRS(ymove), (void*)bitmap)
    glatter_glBitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBitmapxOES_defined
#endif
#ifndef glBlendColorxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendColorxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendColorxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColorxOES, "(%s, %s, %s, %s)", GET_PRS(red), GET_PRS(green), GET_PRS(blue), GET_PRS(alpha))
    glatter_glBlendColorxOES(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendColorxOES_defined
#endif
#ifndef glClearAccumxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearAccumxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_INLINE_OR_NOT void glatter_glClearAccumxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearAccumxOES, "(%s, %s, %s, %s)", GET_PRS(red), GET_PRS(green), GET_PRS(blue), GET_PRS(alpha))
    glatter_glClearAccumxOES(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearAccumxOES_defined
#endif
#ifndef glClearColorxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearColorxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_INLINE_OR_NOT void glatter_glClearColorxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorxOES, "(%s, %s, %s, %s)", GET_PRS(red), GET_PRS(green), GET_PRS(blue), GET_PRS(alpha))
    glatter_glClearColorxOES(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearColorxOES_defined
#endif
#ifndef glClearDepthxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearDepthxOES, (depth), (GLfixed depth))
GLATTER_INLINE_OR_NOT void glatter_glClearDepthxOES_debug(GLfixed depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthxOES, "(%s)", GET_PRS(depth))
    glatter_glClearDepthxOES(depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearDepthxOES_defined
#endif
#ifndef glClipPlanexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClipPlanexOES, (plane, equation), (GLenum plane, const GLfixed *equation))
GLATTER_INLINE_OR_NOT void glatter_glClipPlanexOES_debug(GLenum plane, const GLfixed *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipPlanexOES, "(%s, %p)", enum_to_string_GL(plane), (void*)equation)
    glatter_glClipPlanexOES(plane, equation);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClipPlanexOES_defined
#endif
#ifndef glColor3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3xOES, (red, green, blue), (GLfixed red, GLfixed green, GLfixed blue))
GLATTER_INLINE_OR_NOT void glatter_glColor3xOES_debug(GLfixed red, GLfixed green, GLfixed blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3xOES, "(%s, %s, %s)", GET_PRS(red), GET_PRS(green), GET_PRS(blue))
    glatter_glColor3xOES(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3xOES_defined
#endif
#ifndef glColor3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3xvOES, (components), (const GLfixed *components))
GLATTER_INLINE_OR_NOT void glatter_glColor3xvOES_debug(const GLfixed *components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3xvOES, "(%p)", (void*)components)
    glatter_glColor3xvOES(components);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3xvOES_defined
#endif
#ifndef glColor4xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4xOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_INLINE_OR_NOT void glatter_glColor4xOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4xOES, "(%s, %s, %s, %s)", GET_PRS(red), GET_PRS(green), GET_PRS(blue), GET_PRS(alpha))
    glatter_glColor4xOES(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4xOES_defined
#endif
#ifndef glColor4xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4xvOES, (components), (const GLfixed *components))
GLATTER_INLINE_OR_NOT void glatter_glColor4xvOES_debug(const GLfixed *components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4xvOES, "(%p)", (void*)components)
    glatter_glColor4xvOES(components);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4xvOES_defined
#endif
#ifndef glConvolutionParameterxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterxOES, "(%s, %s, %s)", enum_to_string_GL(target), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glConvolutionParameterxOES(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterxOES_defined
#endif
#ifndef glConvolutionParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glConvolutionParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glConvolutionParameterxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glConvolutionParameterxvOES_defined
#endif
#ifndef glDepthRangexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangexOES, (n, f), (GLfixed n, GLfixed f))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangexOES_debug(GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangexOES, "(%s, %s)", GET_PRS(n), GET_PRS(f))
    glatter_glDepthRangexOES(n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangexOES_defined
#endif
#ifndef glEvalCoord1xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvalCoord1xOES, (u), (GLfixed u))
GLATTER_INLINE_OR_NOT void glatter_glEvalCoord1xOES_debug(GLfixed u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1xOES, "(%s)", GET_PRS(u))
    glatter_glEvalCoord1xOES(u);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvalCoord1xOES_defined
#endif
#ifndef glEvalCoord1xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvalCoord1xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glEvalCoord1xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1xvOES, "(%p)", (void*)coords)
    glatter_glEvalCoord1xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvalCoord1xvOES_defined
#endif
#ifndef glEvalCoord2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvalCoord2xOES, (u, v), (GLfixed u, GLfixed v))
GLATTER_INLINE_OR_NOT void glatter_glEvalCoord2xOES_debug(GLfixed u, GLfixed v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2xOES, "(%s, %s)", GET_PRS(u), GET_PRS(v))
    glatter_glEvalCoord2xOES(u, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvalCoord2xOES_defined
#endif
#ifndef glEvalCoord2xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEvalCoord2xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glEvalCoord2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2xvOES, "(%p)", (void*)coords)
    glatter_glEvalCoord2xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEvalCoord2xvOES_defined
#endif
#ifndef glFeedbackBufferxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFeedbackBufferxOES, (n, type, buffer), (GLsizei n, GLenum type, const GLfixed *buffer))
GLATTER_INLINE_OR_NOT void glatter_glFeedbackBufferxOES_debug(GLsizei n, GLenum type, const GLfixed *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFeedbackBufferxOES, "(%d, %s, %p)", (int)n, enum_to_string_GL(type), (void*)buffer)
    glatter_glFeedbackBufferxOES(n, type, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFeedbackBufferxOES_defined
#endif
#ifndef glFogxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glFogxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogxOES, "(%s, %s)", enum_to_string_GL(pname), GET_PRS(param))
    glatter_glFogxOES(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogxOES_defined
#endif
#ifndef glFogxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogxvOES, (pname, param), (GLenum pname, const GLfixed *param))
GLATTER_INLINE_OR_NOT void glatter_glFogxvOES_debug(GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogxvOES, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glFogxvOES(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogxvOES_defined
#endif
#ifndef glFrustumxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFrustumxOES, (l, r, b, t, n, f), (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f))
GLATTER_INLINE_OR_NOT void glatter_glFrustumxOES_debug(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrustumxOES, "(%s, %s, %s, %s, %s, %s)", GET_PRS(l), GET_PRS(r), GET_PRS(b), GET_PRS(t), GET_PRS(n), GET_PRS(f))
    glatter_glFrustumxOES(l, r, b, t, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFrustumxOES_defined
#endif
#ifndef glGetClipPlanexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetClipPlanexOES, (plane, equation), (GLenum plane, GLfixed *equation))
GLATTER_INLINE_OR_NOT void glatter_glGetClipPlanexOES_debug(GLenum plane, GLfixed *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetClipPlanexOES, "(%s, %p)", enum_to_string_GL(plane), (void*)equation)
    glatter_glGetClipPlanexOES(plane, equation);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetClipPlanexOES_defined
#endif
#ifndef glGetConvolutionParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetConvolutionParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetConvolutionParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetConvolutionParameterxvOES_defined
#endif
#ifndef glGetFixedvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFixedvOES, (pname, params), (GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFixedvOES_debug(GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFixedvOES, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glGetFixedvOES(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFixedvOES_defined
#endif
#ifndef glGetHistogramParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetHistogramParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetHistogramParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetHistogramParameterxvOES_defined
#endif
#ifndef glGetLightxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetLightxOES, (light, pname, params), (GLenum light, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetLightxOES_debug(GLenum light, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLightxOES, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetLightxOES(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetLightxOES_defined
#endif
#ifndef glGetMapxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMapxvOES, (target, query, v), (GLenum target, GLenum query, GLfixed *v))
GLATTER_INLINE_OR_NOT void glatter_glGetMapxvOES_debug(GLenum target, GLenum query, GLfixed *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (void*)v)
    glatter_glGetMapxvOES(target, query, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMapxvOES_defined
#endif
#ifndef glGetMaterialxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMaterialxOES, (face, pname, param), (GLenum face, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glGetMaterialxOES_debug(GLenum face, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMaterialxOES, "(%s, %s, %s)", enum_to_string_GL(face), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glGetMaterialxOES(face, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMaterialxOES_defined
#endif
#ifndef glGetPixelMapxv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPixelMapxv, (map, size, values), (GLenum map, GLint size, GLfixed *values))
GLATTER_INLINE_OR_NOT void glatter_glGetPixelMapxv_debug(GLenum map, GLint size, GLfixed *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelMapxv, "(%s, %d, %p)", enum_to_string_GL(map), (int)size, (void*)values)
    glatter_glGetPixelMapxv(map, size, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPixelMapxv_defined
#endif
#ifndef glGetTexEnvxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexEnvxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexEnvxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexEnvxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexEnvxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexEnvxvOES_defined
#endif
#ifndef glGetTexGenxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexGenxvOES, (coord, pname, params), (GLenum coord, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexGenxvOES_debug(GLenum coord, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexGenxvOES, "(%s, %s, %p)", enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexGenxvOES(coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexGenxvOES_defined
#endif
#ifndef glGetTexLevelParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexLevelParameterxvOES, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexLevelParameterxvOES_debug(GLenum target, GLint level, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameterxvOES, "(%s, %d, %s, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameterxvOES(target, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexLevelParameterxvOES_defined
#endif
#ifndef glGetTexParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterxvOES_defined
#endif
#ifndef glIndexxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexxOES, (component), (GLfixed component))
GLATTER_INLINE_OR_NOT void glatter_glIndexxOES_debug(GLfixed component, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexxOES, "(%s)", GET_PRS(component))
    glatter_glIndexxOES(component);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexxOES_defined
#endif
#ifndef glIndexxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIndexxvOES, (component), (const GLfixed *component))
GLATTER_INLINE_OR_NOT void glatter_glIndexxvOES_debug(const GLfixed *component, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexxvOES, "(%p)", (void*)component)
    glatter_glIndexxvOES(component);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIndexxvOES_defined
#endif
#ifndef glLightModelxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLightModelxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glLightModelxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelxOES, "(%s, %s)", enum_to_string_GL(pname), GET_PRS(param))
    glatter_glLightModelxOES(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLightModelxOES_defined
#endif
#ifndef glLightModelxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLightModelxvOES, (pname, param), (GLenum pname, const GLfixed *param))
GLATTER_INLINE_OR_NOT void glatter_glLightModelxvOES_debug(GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelxvOES, "(%s, %p)", enum_to_string_GL(pname), (void*)param)
    glatter_glLightModelxvOES(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLightModelxvOES_defined
#endif
#ifndef glLightxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLightxOES, (light, pname, param), (GLenum light, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glLightxOES_debug(GLenum light, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightxOES, "(%s, %s, %s)", enum_to_string_GL(light), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glLightxOES(light, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLightxOES_defined
#endif
#ifndef glLightxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLightxvOES, (light, pname, params), (GLenum light, GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glLightxvOES_debug(GLenum light, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightxvOES, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glLightxvOES(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLightxvOES_defined
#endif
#ifndef glLineWidthxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLineWidthxOES, (width), (GLfixed width))
GLATTER_INLINE_OR_NOT void glatter_glLineWidthxOES_debug(GLfixed width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineWidthxOES, "(%s)", GET_PRS(width))
    glatter_glLineWidthxOES(width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLineWidthxOES_defined
#endif
#ifndef glLoadMatrixxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadMatrixxOES, (m), (const GLfixed *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadMatrixxOES, "(%p)", (void*)m)
    glatter_glLoadMatrixxOES(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadMatrixxOES_defined
#endif
#ifndef glLoadTransposeMatrixxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadTransposeMatrixxOES, (m), (const GLfixed *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadTransposeMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixxOES, "(%p)", (void*)m)
    glatter_glLoadTransposeMatrixxOES(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadTransposeMatrixxOES_defined
#endif
#ifndef glMap1xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMap1xOES, (target, u1, u2, stride, order, points), (GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points))
GLATTER_INLINE_OR_NOT void glatter_glMap1xOES_debug(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap1xOES, "(%s, %s, %s, %d, %d, %s)", enum_to_string_GL(target), GET_PRS(u1), GET_PRS(u2), (int)stride, (int)order, GET_PRS(points))
    glatter_glMap1xOES(target, u1, u2, stride, order, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMap1xOES_defined
#endif
#ifndef glMap2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMap2xOES, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points))
GLATTER_INLINE_OR_NOT void glatter_glMap2xOES_debug(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap2xOES, "(%s, %s, %s, %d, %d, %s, %s, %d, %d, %s)", enum_to_string_GL(target), GET_PRS(u1), GET_PRS(u2), (int)ustride, (int)uorder, GET_PRS(v1), GET_PRS(v2), (int)vstride, (int)vorder, GET_PRS(points))
    glatter_glMap2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMap2xOES_defined
#endif
#ifndef glMapGrid1xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapGrid1xOES, (n, u1, u2), (GLint n, GLfixed u1, GLfixed u2))
GLATTER_INLINE_OR_NOT void glatter_glMapGrid1xOES_debug(GLint n, GLfixed u1, GLfixed u2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid1xOES, "(%d, %s, %s)", (int)n, GET_PRS(u1), GET_PRS(u2))
    glatter_glMapGrid1xOES(n, u1, u2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapGrid1xOES_defined
#endif
#ifndef glMapGrid2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMapGrid2xOES, (n, u1, u2, v1, v2), (GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2))
GLATTER_INLINE_OR_NOT void glatter_glMapGrid2xOES_debug(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid2xOES, "(%d, %s, %s, %s, %s)", (int)n, GET_PRS(u1), GET_PRS(u2), GET_PRS(v1), GET_PRS(v2))
    glatter_glMapGrid2xOES(n, u1, u2, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMapGrid2xOES_defined
#endif
#ifndef glMaterialxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMaterialxOES, (face, pname, param), (GLenum face, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glMaterialxOES_debug(GLenum face, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialxOES, "(%s, %s, %s)", enum_to_string_GL(face), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glMaterialxOES(face, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMaterialxOES_defined
#endif
#ifndef glMaterialxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMaterialxvOES, (face, pname, param), (GLenum face, GLenum pname, const GLfixed *param))
GLATTER_INLINE_OR_NOT void glatter_glMaterialxvOES_debug(GLenum face, GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialxvOES, "(%s, %s, %p)", enum_to_string_GL(face), enum_to_string_GL(pname), (void*)param)
    glatter_glMaterialxvOES(face, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMaterialxvOES_defined
#endif
#ifndef glMultMatrixxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultMatrixxOES, (m), (const GLfixed *m))
GLATTER_INLINE_OR_NOT void glatter_glMultMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultMatrixxOES, "(%p)", (void*)m)
    glatter_glMultMatrixxOES(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultMatrixxOES_defined
#endif
#ifndef glMultTransposeMatrixxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultTransposeMatrixxOES, (m), (const GLfixed *m))
GLATTER_INLINE_OR_NOT void glatter_glMultTransposeMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixxOES, "(%p)", (void*)m)
    glatter_glMultTransposeMatrixxOES(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultTransposeMatrixxOES_defined
#endif
#ifndef glMultiTexCoord1xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1xOES, (texture, s), (GLenum texture, GLfixed s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1xOES_debug(GLenum texture, GLfixed s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1xOES, "(%s, %s)", enum_to_string_GL(texture), GET_PRS(s))
    glatter_glMultiTexCoord1xOES(texture, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1xOES_defined
#endif
#ifndef glMultiTexCoord1xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1xvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord1xvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1xvOES_defined
#endif
#ifndef glMultiTexCoord2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2xOES, (texture, s, t), (GLenum texture, GLfixed s, GLfixed t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2xOES_debug(GLenum texture, GLfixed s, GLfixed t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2xOES, "(%s, %s, %s)", enum_to_string_GL(texture), GET_PRS(s), GET_PRS(t))
    glatter_glMultiTexCoord2xOES(texture, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2xOES_defined
#endif
#ifndef glMultiTexCoord2xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2xvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord2xvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2xvOES_defined
#endif
#ifndef glMultiTexCoord3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3xOES, (texture, s, t, r), (GLenum texture, GLfixed s, GLfixed t, GLfixed r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3xOES_debug(GLenum texture, GLfixed s, GLfixed t, GLfixed r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3xOES, "(%s, %s, %s, %s)", enum_to_string_GL(texture), GET_PRS(s), GET_PRS(t), GET_PRS(r))
    glatter_glMultiTexCoord3xOES(texture, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3xOES_defined
#endif
#ifndef glMultiTexCoord3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3xvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord3xvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3xvOES_defined
#endif
#ifndef glMultiTexCoord4xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4xOES, (texture, s, t, r, q), (GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4xOES_debug(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4xOES, "(%s, %s, %s, %s, %s)", enum_to_string_GL(texture), GET_PRS(s), GET_PRS(t), GET_PRS(r), GET_PRS(q))
    glatter_glMultiTexCoord4xOES(texture, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4xOES_defined
#endif
#ifndef glMultiTexCoord4xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4xvOES, "(%s, %p)", enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord4xvOES(texture, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4xvOES_defined
#endif
#ifndef glNormal3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3xOES, (nx, ny, nz), (GLfixed nx, GLfixed ny, GLfixed nz))
GLATTER_INLINE_OR_NOT void glatter_glNormal3xOES_debug(GLfixed nx, GLfixed ny, GLfixed nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3xOES, "(%s, %s, %s)", GET_PRS(nx), GET_PRS(ny), GET_PRS(nz))
    glatter_glNormal3xOES(nx, ny, nz);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3xOES_defined
#endif
#ifndef glNormal3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormal3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3xvOES, "(%p)", (void*)coords)
    glatter_glNormal3xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3xvOES_defined
#endif
#ifndef glOrthoxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glOrthoxOES, (l, r, b, t, n, f), (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f))
GLATTER_INLINE_OR_NOT void glatter_glOrthoxOES_debug(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glOrthoxOES, "(%s, %s, %s, %s, %s, %s)", GET_PRS(l), GET_PRS(r), GET_PRS(b), GET_PRS(t), GET_PRS(n), GET_PRS(f))
    glatter_glOrthoxOES(l, r, b, t, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glOrthoxOES_defined
#endif
#ifndef glPassThroughxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPassThroughxOES, (token), (GLfixed token))
GLATTER_INLINE_OR_NOT void glatter_glPassThroughxOES_debug(GLfixed token, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPassThroughxOES, "(%s)", GET_PRS(token))
    glatter_glPassThroughxOES(token);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPassThroughxOES_defined
#endif
#ifndef glPixelMapx_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelMapx, (map, size, values), (GLenum map, GLint size, const GLfixed *values))
GLATTER_INLINE_OR_NOT void glatter_glPixelMapx_debug(GLenum map, GLint size, const GLfixed *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelMapx, "(%s, %d, %p)", enum_to_string_GL(map), (int)size, (void*)values)
    glatter_glPixelMapx(map, size, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelMapx_defined
#endif
#ifndef glPixelStorex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelStorex, (pname, param), (GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glPixelStorex_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStorex, "(%s, %s)", enum_to_string_GL(pname), GET_PRS(param))
    glatter_glPixelStorex(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelStorex_defined
#endif
#ifndef glPixelTransferxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTransferxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glPixelTransferxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransferxOES, "(%s, %s)", enum_to_string_GL(pname), GET_PRS(param))
    glatter_glPixelTransferxOES(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTransferxOES_defined
#endif
#ifndef glPixelZoomxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelZoomxOES, (xfactor, yfactor), (GLfixed xfactor, GLfixed yfactor))
GLATTER_INLINE_OR_NOT void glatter_glPixelZoomxOES_debug(GLfixed xfactor, GLfixed yfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelZoomxOES, "(%s, %s)", GET_PRS(xfactor), GET_PRS(yfactor))
    glatter_glPixelZoomxOES(xfactor, yfactor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelZoomxOES_defined
#endif
#ifndef glPointParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterxvOES, (pname, params), (GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterxvOES_debug(GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterxvOES, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterxvOES(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterxvOES_defined
#endif
#ifndef glPointSizexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointSizexOES, (size), (GLfixed size))
GLATTER_INLINE_OR_NOT void glatter_glPointSizexOES_debug(GLfixed size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointSizexOES, "(%s)", GET_PRS(size))
    glatter_glPointSizexOES(size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointSizexOES_defined
#endif
#ifndef glPolygonOffsetxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPolygonOffsetxOES, (factor, units), (GLfixed factor, GLfixed units))
GLATTER_INLINE_OR_NOT void glatter_glPolygonOffsetxOES_debug(GLfixed factor, GLfixed units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetxOES, "(%s, %s)", GET_PRS(factor), GET_PRS(units))
    glatter_glPolygonOffsetxOES(factor, units);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPolygonOffsetxOES_defined
#endif
#ifndef glPrioritizeTexturesxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrioritizeTexturesxOES, (n, textures, priorities), (GLsizei n, const GLuint *textures, const GLfixed *priorities))
GLATTER_INLINE_OR_NOT void glatter_glPrioritizeTexturesxOES_debug(GLsizei n, const GLuint *textures, const GLfixed *priorities, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrioritizeTexturesxOES, "(%d, %p, %p)", (int)n, (void*)textures, (void*)priorities)
    glatter_glPrioritizeTexturesxOES(n, textures, priorities);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrioritizeTexturesxOES_defined
#endif
#ifndef glRasterPos2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos2xOES, (x, y), (GLfixed x, GLfixed y))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos2xOES_debug(GLfixed x, GLfixed y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2xOES, "(%s, %s)", GET_PRS(x), GET_PRS(y))
    glatter_glRasterPos2xOES(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos2xOES_defined
#endif
#ifndef glRasterPos2xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos2xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2xvOES, "(%p)", (void*)coords)
    glatter_glRasterPos2xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos2xvOES_defined
#endif
#ifndef glRasterPos3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos3xOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos3xOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3xOES, "(%s, %s, %s)", GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glRasterPos3xOES(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos3xOES_defined
#endif
#ifndef glRasterPos3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos3xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3xvOES, "(%p)", (void*)coords)
    glatter_glRasterPos3xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos3xvOES_defined
#endif
#ifndef glRasterPos4xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos4xOES, (x, y, z, w), (GLfixed x, GLfixed y, GLfixed z, GLfixed w))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos4xOES_debug(GLfixed x, GLfixed y, GLfixed z, GLfixed w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4xOES, "(%s, %s, %s, %s)", GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glRasterPos4xOES(x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos4xOES_defined
#endif
#ifndef glRasterPos4xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRasterPos4xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glRasterPos4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4xvOES, "(%p)", (void*)coords)
    glatter_glRasterPos4xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRasterPos4xvOES_defined
#endif
#ifndef glRectxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRectxOES, (x1, y1, x2, y2), (GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2))
GLATTER_INLINE_OR_NOT void glatter_glRectxOES_debug(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectxOES, "(%s, %s, %s, %s)", GET_PRS(x1), GET_PRS(y1), GET_PRS(x2), GET_PRS(y2))
    glatter_glRectxOES(x1, y1, x2, y2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRectxOES_defined
#endif
#ifndef glRectxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRectxvOES, (v1, v2), (const GLfixed *v1, const GLfixed *v2))
GLATTER_INLINE_OR_NOT void glatter_glRectxvOES_debug(const GLfixed *v1, const GLfixed *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectxvOES, "(%p, %p)", (void*)v1, (void*)v2)
    glatter_glRectxvOES(v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRectxvOES_defined
#endif
#ifndef glRotatexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRotatexOES, (angle, x, y, z), (GLfixed angle, GLfixed x, GLfixed y, GLfixed z))
GLATTER_INLINE_OR_NOT void glatter_glRotatexOES_debug(GLfixed angle, GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRotatexOES, "(%s, %s, %s, %s)", GET_PRS(angle), GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glRotatexOES(angle, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRotatexOES_defined
#endif
#ifndef glScalexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScalexOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_INLINE_OR_NOT void glatter_glScalexOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScalexOES, "(%s, %s, %s)", GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glScalexOES(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScalexOES_defined
#endif
#ifndef glTexCoord1xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1xOES, (s), (GLfixed s))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1xOES_debug(GLfixed s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1xOES, "(%s)", GET_PRS(s))
    glatter_glTexCoord1xOES(s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1xOES_defined
#endif
#ifndef glTexCoord1xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord1xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord1xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1xvOES, "(%p)", (void*)coords)
    glatter_glTexCoord1xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord1xvOES_defined
#endif
#ifndef glTexCoord2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2xOES, (s, t), (GLfixed s, GLfixed t))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2xOES_debug(GLfixed s, GLfixed t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2xOES, "(%s, %s)", GET_PRS(s), GET_PRS(t))
    glatter_glTexCoord2xOES(s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2xOES_defined
#endif
#ifndef glTexCoord2xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2xvOES, "(%p)", (void*)coords)
    glatter_glTexCoord2xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2xvOES_defined
#endif
#ifndef glTexCoord3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3xOES, (s, t, r), (GLfixed s, GLfixed t, GLfixed r))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3xOES_debug(GLfixed s, GLfixed t, GLfixed r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3xOES, "(%s, %s, %s)", GET_PRS(s), GET_PRS(t), GET_PRS(r))
    glatter_glTexCoord3xOES(s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3xOES_defined
#endif
#ifndef glTexCoord3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord3xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3xvOES, "(%p)", (void*)coords)
    glatter_glTexCoord3xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord3xvOES_defined
#endif
#ifndef glTexCoord4xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4xOES, (s, t, r, q), (GLfixed s, GLfixed t, GLfixed r, GLfixed q))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4xOES_debug(GLfixed s, GLfixed t, GLfixed r, GLfixed q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4xOES, "(%s, %s, %s, %s)", GET_PRS(s), GET_PRS(t), GET_PRS(r), GET_PRS(q))
    glatter_glTexCoord4xOES(s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4xOES_defined
#endif
#ifndef glTexCoord4xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4xvOES, "(%p)", (void*)coords)
    glatter_glTexCoord4xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4xvOES_defined
#endif
#ifndef glTexEnvxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexEnvxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glTexEnvxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvxOES, "(%s, %s, %s)", enum_to_string_GL(target), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glTexEnvxOES(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexEnvxOES_defined
#endif
#ifndef glTexEnvxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexEnvxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glTexEnvxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexEnvxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexEnvxvOES_defined
#endif
#ifndef glTexGenxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexGenxOES, (coord, pname, param), (GLenum coord, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glTexGenxOES_debug(GLenum coord, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenxOES, "(%s, %s, %s)", enum_to_string_GL(coord), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glTexGenxOES(coord, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexGenxOES_defined
#endif
#ifndef glTexGenxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexGenxvOES, (coord, pname, params), (GLenum coord, GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glTexGenxvOES_debug(GLenum coord, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenxvOES, "(%s, %s, %p)", enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glTexGenxvOES(coord, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexGenxvOES_defined
#endif
#ifndef glTexParameterxOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterxOES, "(%s, %s, %s)", enum_to_string_GL(target), enum_to_string_GL(pname), GET_PRS(param))
    glatter_glTexParameterxOES(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterxOES_defined
#endif
#ifndef glTexParameterxvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterxvOES, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterxvOES(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterxvOES_defined
#endif
#ifndef glTranslatexOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTranslatexOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_INLINE_OR_NOT void glatter_glTranslatexOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTranslatexOES, "(%s, %s, %s)", GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glTranslatexOES(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTranslatexOES_defined
#endif
#ifndef glVertex2xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2xOES, (x), (GLfixed x))
GLATTER_INLINE_OR_NOT void glatter_glVertex2xOES_debug(GLfixed x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2xOES, "(%s)", GET_PRS(x))
    glatter_glVertex2xOES(x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2xOES_defined
#endif
#ifndef glVertex2xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex2xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2xvOES, "(%p)", (void*)coords)
    glatter_glVertex2xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex2xvOES_defined
#endif
#ifndef glVertex3xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3xOES, (x, y), (GLfixed x, GLfixed y))
GLATTER_INLINE_OR_NOT void glatter_glVertex3xOES_debug(GLfixed x, GLfixed y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3xOES, "(%s, %s)", GET_PRS(x), GET_PRS(y))
    glatter_glVertex3xOES(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3xOES_defined
#endif
#ifndef glVertex3xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex3xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3xvOES, "(%p)", (void*)coords)
    glatter_glVertex3xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex3xvOES_defined
#endif
#ifndef glVertex4xOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4xOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_INLINE_OR_NOT void glatter_glVertex4xOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4xOES, "(%s, %s, %s)", GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glVertex4xOES(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4xOES_defined
#endif
#ifndef glVertex4xvOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertex4xvOES, (coords), (const GLfixed *coords))
GLATTER_INLINE_OR_NOT void glatter_glVertex4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4xvOES, "(%p)", (void*)coords)
    glatter_glVertex4xvOES(coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertex4xvOES_defined
#endif
#endif // defined(GL_OES_fixed_point)
#if defined(GL_OES_query_matrix)
#ifndef glQueryMatrixxOES_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLbitfield, APIENTRY, glQueryMatrixxOES, (mantissa, exponent), (GLfixed *mantissa, GLint *exponent))
GLATTER_INLINE_OR_NOT GLbitfield glatter_glQueryMatrixxOES_debug(GLfixed *mantissa, GLint *exponent, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryMatrixxOES, "(%p, %p)", (void*)mantissa, (void*)exponent)
    GLbitfield rval = glatter_glQueryMatrixxOES(mantissa, exponent);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glQueryMatrixxOES_defined
#endif
#endif // defined(GL_OES_query_matrix)
#if defined(GL_OES_single_precision)
#ifndef glClearDepthfOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearDepthfOES, (depth), (GLclampf depth))
GLATTER_INLINE_OR_NOT void glatter_glClearDepthfOES_debug(GLclampf depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthfOES, "(%f)", (float)depth)
    glatter_glClearDepthfOES(depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearDepthfOES_defined
#endif
#ifndef glClipPlanefOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClipPlanefOES, (plane, equation), (GLenum plane, const GLfloat *equation))
GLATTER_INLINE_OR_NOT void glatter_glClipPlanefOES_debug(GLenum plane, const GLfloat *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipPlanefOES, "(%s, %p)", enum_to_string_GL(plane), (void*)equation)
    glatter_glClipPlanefOES(plane, equation);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClipPlanefOES_defined
#endif
#ifndef glDepthRangefOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangefOES, (n, f), (GLclampf n, GLclampf f))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangefOES_debug(GLclampf n, GLclampf f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangefOES, "(%f, %f)", (float)n, (float)f)
    glatter_glDepthRangefOES(n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangefOES_defined
#endif
#ifndef glFrustumfOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFrustumfOES, (l, r, b, t, n, f), (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f))
GLATTER_INLINE_OR_NOT void glatter_glFrustumfOES_debug(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrustumfOES, "(%f, %f, %f, %f, %f, %f)", (float)l, (float)r, (float)b, (float)t, (float)n, (float)f)
    glatter_glFrustumfOES(l, r, b, t, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFrustumfOES_defined
#endif
#ifndef glGetClipPlanefOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetClipPlanefOES, (plane, equation), (GLenum plane, GLfloat *equation))
GLATTER_INLINE_OR_NOT void glatter_glGetClipPlanefOES_debug(GLenum plane, GLfloat *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetClipPlanefOES, "(%s, %p)", enum_to_string_GL(plane), (void*)equation)
    glatter_glGetClipPlanefOES(plane, equation);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetClipPlanefOES_defined
#endif
#ifndef glOrthofOES_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glOrthofOES, (l, r, b, t, n, f), (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f))
GLATTER_INLINE_OR_NOT void glatter_glOrthofOES_debug(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glOrthofOES, "(%f, %f, %f, %f, %f, %f)", (float)l, (float)r, (float)b, (float)t, (float)n, (float)f)
    glatter_glOrthofOES(l, r, b, t, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glOrthofOES_defined
#endif
#endif // defined(GL_OES_single_precision)
#if defined(GL_OVR_multiview)
#ifndef glFramebufferTextureMultiviewOVR_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureMultiviewOVR, (target, attachment, texture, level, baseViewIndex, numViews), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureMultiviewOVR_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureMultiviewOVR, "(%s, %s, %u, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)baseViewIndex, (int)numViews)
    glatter_glFramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureMultiviewOVR_defined
#endif
#ifndef glNamedFramebufferTextureMultiviewOVR_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTextureMultiviewOVR, (framebuffer, attachment, texture, level, baseViewIndex, numViews), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTextureMultiviewOVR_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureMultiviewOVR, "(%u, %s, %u, %d, %d, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)baseViewIndex, (int)numViews)
    glatter_glNamedFramebufferTextureMultiviewOVR(framebuffer, attachment, texture, level, baseViewIndex, numViews);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTextureMultiviewOVR_defined
#endif
#endif // defined(GL_OVR_multiview)
#if defined(GL_PGI_misc_hints)
#ifndef glHintPGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glHintPGI, (target, mode), (GLenum target, GLint mode))
GLATTER_INLINE_OR_NOT void glatter_glHintPGI_debug(GLenum target, GLint mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHintPGI, "(%s, %d)", enum_to_string_GL(target), (int)mode)
    glatter_glHintPGI(target, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glHintPGI_defined
#endif
#endif // defined(GL_PGI_misc_hints)
#if defined(GL_SGIS_detail_texture)
#ifndef glDetailTexFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDetailTexFuncSGIS, (target, n, points), (GLenum target, GLsizei n, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glDetailTexFuncSGIS_debug(GLenum target, GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetailTexFuncSGIS, "(%s, %d, %p)", enum_to_string_GL(target), (int)n, (void*)points)
    glatter_glDetailTexFuncSGIS(target, n, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDetailTexFuncSGIS_defined
#endif
#ifndef glGetDetailTexFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetDetailTexFuncSGIS, (target, points), (GLenum target, GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glGetDetailTexFuncSGIS_debug(GLenum target, GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDetailTexFuncSGIS, "(%s, %p)", enum_to_string_GL(target), (void*)points)
    glatter_glGetDetailTexFuncSGIS(target, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetDetailTexFuncSGIS_defined
#endif
#endif // defined(GL_SGIS_detail_texture)
#if defined(GL_SGIS_fog_function)
#ifndef glFogFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogFuncSGIS, (n, points), (GLsizei n, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glFogFuncSGIS_debug(GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogFuncSGIS, "(%d, %p)", (int)n, (void*)points)
    glatter_glFogFuncSGIS(n, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogFuncSGIS_defined
#endif
#ifndef glGetFogFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFogFuncSGIS, (points), (GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glGetFogFuncSGIS_debug(GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFogFuncSGIS, "(%p)", (void*)points)
    glatter_glGetFogFuncSGIS(points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFogFuncSGIS_defined
#endif
#endif // defined(GL_SGIS_fog_function)
#if defined(GL_SGIS_multisample)
#ifndef glSampleMaskSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleMaskSGIS, (value, invert), (GLclampf value, GLboolean invert))
GLATTER_INLINE_OR_NOT void glatter_glSampleMaskSGIS_debug(GLclampf value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskSGIS, "(%f, %u)", (float)value, (unsigned char)invert)
    glatter_glSampleMaskSGIS(value, invert);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleMaskSGIS_defined
#endif
#ifndef glSamplePatternSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplePatternSGIS, (pattern), (GLenum pattern))
GLATTER_INLINE_OR_NOT void glatter_glSamplePatternSGIS_debug(GLenum pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplePatternSGIS, "(%s)", enum_to_string_GL(pattern))
    glatter_glSamplePatternSGIS(pattern);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplePatternSGIS_defined
#endif
#endif // defined(GL_SGIS_multisample)
#if defined(GL_SGIS_pixel_texture)
#ifndef glGetPixelTexGenParameterfvSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPixelTexGenParameterfvSGIS, (pname, params), (GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetPixelTexGenParameterfvSGIS_debug(GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTexGenParameterfvSGIS, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTexGenParameterfvSGIS(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPixelTexGenParameterfvSGIS_defined
#endif
#ifndef glGetPixelTexGenParameterivSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetPixelTexGenParameterivSGIS, (pname, params), (GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetPixelTexGenParameterivSGIS_debug(GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTexGenParameterivSGIS, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTexGenParameterivSGIS(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetPixelTexGenParameterivSGIS_defined
#endif
#ifndef glPixelTexGenParameterfSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTexGenParameterfSGIS, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPixelTexGenParameterfSGIS_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterfSGIS, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPixelTexGenParameterfSGIS(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTexGenParameterfSGIS_defined
#endif
#ifndef glPixelTexGenParameterfvSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTexGenParameterfvSGIS, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPixelTexGenParameterfvSGIS_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterfvSGIS, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTexGenParameterfvSGIS(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTexGenParameterfvSGIS_defined
#endif
#ifndef glPixelTexGenParameteriSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTexGenParameteriSGIS, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glPixelTexGenParameteriSGIS_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameteriSGIS, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glPixelTexGenParameteriSGIS(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTexGenParameteriSGIS_defined
#endif
#ifndef glPixelTexGenParameterivSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTexGenParameterivSGIS, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glPixelTexGenParameterivSGIS_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterivSGIS, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTexGenParameterivSGIS(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTexGenParameterivSGIS_defined
#endif
#endif // defined(GL_SGIS_pixel_texture)
#if defined(GL_SGIS_point_parameters)
#ifndef glPointParameterfSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfSGIS, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfSGIS_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfSGIS, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfSGIS(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfSGIS_defined
#endif
#ifndef glPointParameterfvSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfvSGIS, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfvSGIS_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvSGIS, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvSGIS(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfvSGIS_defined
#endif
#endif // defined(GL_SGIS_point_parameters)
#if defined(GL_SGIS_sharpen_texture)
#ifndef glGetSharpenTexFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSharpenTexFuncSGIS, (target, points), (GLenum target, GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glGetSharpenTexFuncSGIS_debug(GLenum target, GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSharpenTexFuncSGIS, "(%s, %p)", enum_to_string_GL(target), (void*)points)
    glatter_glGetSharpenTexFuncSGIS(target, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSharpenTexFuncSGIS_defined
#endif
#ifndef glSharpenTexFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSharpenTexFuncSGIS, (target, n, points), (GLenum target, GLsizei n, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glSharpenTexFuncSGIS_debug(GLenum target, GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSharpenTexFuncSGIS, "(%s, %d, %p)", enum_to_string_GL(target), (int)n, (void*)points)
    glatter_glSharpenTexFuncSGIS(target, n, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSharpenTexFuncSGIS_defined
#endif
#endif // defined(GL_SGIS_sharpen_texture)
#if defined(GL_SGIS_texture4D)
#ifndef glTexImage4DSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage4DSGIS, (target, level, internalformat, width, height, depth, size4d, border, format, type, pixels), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexImage4DSGIS_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage4DSGIS, "(%s, %d, %s, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)size4d, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage4DSGIS_defined
#endif
#ifndef glTexSubImage4DSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexSubImage4DSGIS, (target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexSubImage4DSGIS_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage4DSGIS, "(%s, %d, %d, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)woffset, (int)width, (int)height, (int)depth, (int)size4d, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexSubImage4DSGIS_defined
#endif
#endif // defined(GL_SGIS_texture4D)
#if defined(GL_SGIS_texture_color_mask)
#ifndef glTextureColorMaskSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureColorMaskSGIS, (red, green, blue, alpha), (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
GLATTER_INLINE_OR_NOT void glatter_glTextureColorMaskSGIS_debug(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureColorMaskSGIS, "(%u, %u, %u, %u)", (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glTextureColorMaskSGIS(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureColorMaskSGIS_defined
#endif
#endif // defined(GL_SGIS_texture_color_mask)
#if defined(GL_SGIS_texture_filter4)
#ifndef glGetTexFilterFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexFilterFuncSGIS, (target, filter, weights), (GLenum target, GLenum filter, GLfloat *weights))
GLATTER_INLINE_OR_NOT void glatter_glGetTexFilterFuncSGIS_debug(GLenum target, GLenum filter, GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexFilterFuncSGIS, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(filter), (void*)weights)
    glatter_glGetTexFilterFuncSGIS(target, filter, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexFilterFuncSGIS_defined
#endif
#ifndef glTexFilterFuncSGIS_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexFilterFuncSGIS, (target, filter, n, weights), (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights))
GLATTER_INLINE_OR_NOT void glatter_glTexFilterFuncSGIS_debug(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexFilterFuncSGIS, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(filter), (int)n, (void*)weights)
    glatter_glTexFilterFuncSGIS(target, filter, n, weights);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexFilterFuncSGIS_defined
#endif
#endif // defined(GL_SGIS_texture_filter4)
#if defined(GL_SGIX_async)
#ifndef glAsyncMarkerSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAsyncMarkerSGIX, (marker), (GLuint marker))
GLATTER_INLINE_OR_NOT void glatter_glAsyncMarkerSGIX_debug(GLuint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAsyncMarkerSGIX, "(%u)", (unsigned int)marker)
    glatter_glAsyncMarkerSGIX(marker);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAsyncMarkerSGIX_defined
#endif
#ifndef glDeleteAsyncMarkersSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteAsyncMarkersSGIX, (marker, range), (GLuint marker, GLsizei range))
GLATTER_INLINE_OR_NOT void glatter_glDeleteAsyncMarkersSGIX_debug(GLuint marker, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteAsyncMarkersSGIX, "(%u, %d)", (unsigned int)marker, (int)range)
    glatter_glDeleteAsyncMarkersSGIX(marker, range);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteAsyncMarkersSGIX_defined
#endif
#ifndef glFinishAsyncSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glFinishAsyncSGIX, (markerp), (GLuint *markerp))
GLATTER_INLINE_OR_NOT GLint glatter_glFinishAsyncSGIX_debug(GLuint *markerp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishAsyncSGIX, "(%p)", (void*)markerp)
    GLint rval = glatter_glFinishAsyncSGIX(markerp);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glFinishAsyncSGIX_defined
#endif
#ifndef glGenAsyncMarkersSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGenAsyncMarkersSGIX, (range), (GLsizei range))
GLATTER_INLINE_OR_NOT GLuint glatter_glGenAsyncMarkersSGIX_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenAsyncMarkersSGIX, "(%d)", (int)range)
    GLuint rval = glatter_glGenAsyncMarkersSGIX(range);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGenAsyncMarkersSGIX_defined
#endif
#ifndef glIsAsyncMarkerSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsAsyncMarkerSGIX, (marker), (GLuint marker))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsAsyncMarkerSGIX_debug(GLuint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsAsyncMarkerSGIX, "(%u)", (unsigned int)marker)
    GLboolean rval = glatter_glIsAsyncMarkerSGIX(marker);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsAsyncMarkerSGIX_defined
#endif
#ifndef glPollAsyncSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glPollAsyncSGIX, (markerp), (GLuint *markerp))
GLATTER_INLINE_OR_NOT GLint glatter_glPollAsyncSGIX_debug(GLuint *markerp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPollAsyncSGIX, "(%p)", (void*)markerp)
    GLint rval = glatter_glPollAsyncSGIX(markerp);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPollAsyncSGIX_defined
#endif
#endif // defined(GL_SGIX_async)
#if defined(GL_SGIX_flush_raster)
#ifndef glFlushRasterSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushRasterSGIX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glFlushRasterSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushRasterSGIX, "()")
    glatter_glFlushRasterSGIX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushRasterSGIX_defined
#endif
#endif // defined(GL_SGIX_flush_raster)
#if defined(GL_SGIX_fragment_lighting)
#ifndef glFragmentColorMaterialSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentColorMaterialSGIX, (face, mode), (GLenum face, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glFragmentColorMaterialSGIX_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentColorMaterialSGIX, "(%s, %s)", enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glFragmentColorMaterialSGIX(face, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentColorMaterialSGIX_defined
#endif
#ifndef glFragmentLightModelfSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightModelfSGIX, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightModelfSGIX_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelfSGIX, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glFragmentLightModelfSGIX(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightModelfSGIX_defined
#endif
#ifndef glFragmentLightModelfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightModelfvSGIX, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightModelfvSGIX_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelfvSGIX, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightModelfvSGIX(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightModelfvSGIX_defined
#endif
#ifndef glFragmentLightModeliSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightModeliSGIX, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightModeliSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModeliSGIX, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glFragmentLightModeliSGIX(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightModeliSGIX_defined
#endif
#ifndef glFragmentLightModelivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightModelivSGIX, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightModelivSGIX_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelivSGIX, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightModelivSGIX(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightModelivSGIX_defined
#endif
#ifndef glFragmentLightfSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightfSGIX, (light, pname, param), (GLenum light, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightfSGIX_debug(GLenum light, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightfSGIX, "(%s, %s, %f)", enum_to_string_GL(light), enum_to_string_GL(pname), (float)param)
    glatter_glFragmentLightfSGIX(light, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightfSGIX_defined
#endif
#ifndef glFragmentLightfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightfvSGIX, (light, pname, params), (GLenum light, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightfvSGIX_debug(GLenum light, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightfvSGIX, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightfvSGIX(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightfvSGIX_defined
#endif
#ifndef glFragmentLightiSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightiSGIX, (light, pname, param), (GLenum light, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightiSGIX_debug(GLenum light, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightiSGIX, "(%s, %s, %d)", enum_to_string_GL(light), enum_to_string_GL(pname), (int)param)
    glatter_glFragmentLightiSGIX(light, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightiSGIX_defined
#endif
#ifndef glFragmentLightivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentLightivSGIX, (light, pname, params), (GLenum light, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentLightivSGIX_debug(GLenum light, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightivSGIX, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightivSGIX(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentLightivSGIX_defined
#endif
#ifndef glFragmentMaterialfSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentMaterialfSGIX, (face, pname, param), (GLenum face, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentMaterialfSGIX_debug(GLenum face, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialfSGIX, "(%s, %s, %f)", enum_to_string_GL(face), enum_to_string_GL(pname), (float)param)
    glatter_glFragmentMaterialfSGIX(face, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentMaterialfSGIX_defined
#endif
#ifndef glFragmentMaterialfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentMaterialfvSGIX, (face, pname, params), (GLenum face, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentMaterialfvSGIX_debug(GLenum face, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialfvSGIX, "(%s, %s, %p)", enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentMaterialfvSGIX(face, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentMaterialfvSGIX_defined
#endif
#ifndef glFragmentMaterialiSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentMaterialiSGIX, (face, pname, param), (GLenum face, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glFragmentMaterialiSGIX_debug(GLenum face, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialiSGIX, "(%s, %s, %d)", enum_to_string_GL(face), enum_to_string_GL(pname), (int)param)
    glatter_glFragmentMaterialiSGIX(face, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentMaterialiSGIX_defined
#endif
#ifndef glFragmentMaterialivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFragmentMaterialivSGIX, (face, pname, params), (GLenum face, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glFragmentMaterialivSGIX_debug(GLenum face, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialivSGIX, "(%s, %s, %p)", enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentMaterialivSGIX(face, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFragmentMaterialivSGIX_defined
#endif
#ifndef glGetFragmentLightfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFragmentLightfvSGIX, (light, pname, params), (GLenum light, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFragmentLightfvSGIX_debug(GLenum light, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentLightfvSGIX, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentLightfvSGIX(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFragmentLightfvSGIX_defined
#endif
#ifndef glGetFragmentLightivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFragmentLightivSGIX, (light, pname, params), (GLenum light, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFragmentLightivSGIX_debug(GLenum light, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentLightivSGIX, "(%s, %s, %p)", enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentLightivSGIX(light, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFragmentLightivSGIX_defined
#endif
#ifndef glGetFragmentMaterialfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFragmentMaterialfvSGIX, (face, pname, params), (GLenum face, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFragmentMaterialfvSGIX_debug(GLenum face, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentMaterialfvSGIX, "(%s, %s, %p)", enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentMaterialfvSGIX(face, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFragmentMaterialfvSGIX_defined
#endif
#ifndef glGetFragmentMaterialivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFragmentMaterialivSGIX, (face, pname, params), (GLenum face, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFragmentMaterialivSGIX_debug(GLenum face, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentMaterialivSGIX, "(%s, %s, %p)", enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentMaterialivSGIX(face, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFragmentMaterialivSGIX_defined
#endif
#ifndef glLightEnviSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLightEnviSGIX, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glLightEnviSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightEnviSGIX, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glLightEnviSGIX(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLightEnviSGIX_defined
#endif
#endif // defined(GL_SGIX_fragment_lighting)
#if defined(GL_SGIX_framezoom)
#ifndef glFrameZoomSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFrameZoomSGIX, (factor), (GLint factor))
GLATTER_INLINE_OR_NOT void glatter_glFrameZoomSGIX_debug(GLint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrameZoomSGIX, "(%d)", (int)factor)
    glatter_glFrameZoomSGIX(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFrameZoomSGIX_defined
#endif
#endif // defined(GL_SGIX_framezoom)
#if defined(GL_SGIX_igloo_interface)
#ifndef glIglooInterfaceSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glIglooInterfaceSGIX, (pname, params), (GLenum pname, const void *params))
GLATTER_INLINE_OR_NOT void glatter_glIglooInterfaceSGIX_debug(GLenum pname, const void *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIglooInterfaceSGIX, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glIglooInterfaceSGIX(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glIglooInterfaceSGIX_defined
#endif
#endif // defined(GL_SGIX_igloo_interface)
#if defined(GL_SGIX_instruments)
#ifndef glGetInstrumentsSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetInstrumentsSGIX, (), (void))
GLATTER_INLINE_OR_NOT GLint glatter_glGetInstrumentsSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInstrumentsSGIX, "()")
    GLint rval = glatter_glGetInstrumentsSGIX();
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetInstrumentsSGIX_defined
#endif
#ifndef glInstrumentsBufferSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInstrumentsBufferSGIX, (size, buffer), (GLsizei size, GLint *buffer))
GLATTER_INLINE_OR_NOT void glatter_glInstrumentsBufferSGIX_debug(GLsizei size, GLint *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInstrumentsBufferSGIX, "(%d, %p)", (int)size, (void*)buffer)
    glatter_glInstrumentsBufferSGIX(size, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInstrumentsBufferSGIX_defined
#endif
#ifndef glPollInstrumentsSGIX_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glPollInstrumentsSGIX, (marker_p), (GLint *marker_p))
GLATTER_INLINE_OR_NOT GLint glatter_glPollInstrumentsSGIX_debug(GLint *marker_p, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPollInstrumentsSGIX, "(%p)", (void*)marker_p)
    GLint rval = glatter_glPollInstrumentsSGIX(marker_p);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glPollInstrumentsSGIX_defined
#endif
#ifndef glReadInstrumentsSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReadInstrumentsSGIX, (marker), (GLint marker))
GLATTER_INLINE_OR_NOT void glatter_glReadInstrumentsSGIX_debug(GLint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadInstrumentsSGIX, "(%d)", (int)marker)
    glatter_glReadInstrumentsSGIX(marker);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReadInstrumentsSGIX_defined
#endif
#ifndef glStartInstrumentsSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStartInstrumentsSGIX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glStartInstrumentsSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStartInstrumentsSGIX, "()")
    glatter_glStartInstrumentsSGIX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStartInstrumentsSGIX_defined
#endif
#ifndef glStopInstrumentsSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStopInstrumentsSGIX, (marker), (GLint marker))
GLATTER_INLINE_OR_NOT void glatter_glStopInstrumentsSGIX_debug(GLint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStopInstrumentsSGIX, "(%d)", (int)marker)
    glatter_glStopInstrumentsSGIX(marker);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStopInstrumentsSGIX_defined
#endif
#endif // defined(GL_SGIX_instruments)
#if defined(GL_SGIX_list_priority)
#ifndef glGetListParameterfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetListParameterfvSGIX, (list, pname, params), (GLuint list, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetListParameterfvSGIX_debug(GLuint list, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetListParameterfvSGIX, "(%u, %s, %p)", (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glGetListParameterfvSGIX(list, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetListParameterfvSGIX_defined
#endif
#ifndef glGetListParameterivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetListParameterivSGIX, (list, pname, params), (GLuint list, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetListParameterivSGIX_debug(GLuint list, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetListParameterivSGIX, "(%u, %s, %p)", (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glGetListParameterivSGIX(list, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetListParameterivSGIX_defined
#endif
#ifndef glListParameterfSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glListParameterfSGIX, (list, pname, param), (GLuint list, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glListParameterfSGIX_debug(GLuint list, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterfSGIX, "(%u, %s, %f)", (unsigned int)list, enum_to_string_GL(pname), (float)param)
    glatter_glListParameterfSGIX(list, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glListParameterfSGIX_defined
#endif
#ifndef glListParameterfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glListParameterfvSGIX, (list, pname, params), (GLuint list, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glListParameterfvSGIX_debug(GLuint list, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterfvSGIX, "(%u, %s, %p)", (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glListParameterfvSGIX(list, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glListParameterfvSGIX_defined
#endif
#ifndef glListParameteriSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glListParameteriSGIX, (list, pname, param), (GLuint list, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glListParameteriSGIX_debug(GLuint list, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameteriSGIX, "(%u, %s, %d)", (unsigned int)list, enum_to_string_GL(pname), (int)param)
    glatter_glListParameteriSGIX(list, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glListParameteriSGIX_defined
#endif
#ifndef glListParameterivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glListParameterivSGIX, (list, pname, params), (GLuint list, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glListParameterivSGIX_debug(GLuint list, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterivSGIX, "(%u, %s, %p)", (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glListParameterivSGIX(list, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glListParameterivSGIX_defined
#endif
#endif // defined(GL_SGIX_list_priority)
#if defined(GL_SGIX_pixel_texture)
#ifndef glPixelTexGenSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPixelTexGenSGIX, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glPixelTexGenSGIX_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenSGIX, "(%s)", enum_to_string_GL(mode))
    glatter_glPixelTexGenSGIX(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPixelTexGenSGIX_defined
#endif
#endif // defined(GL_SGIX_pixel_texture)
#if defined(GL_SGIX_polynomial_ffd)
#ifndef glDeformSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeformSGIX, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glDeformSGIX_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformSGIX, "(%u)", (unsigned int)mask)
    glatter_glDeformSGIX(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeformSGIX_defined
#endif
#ifndef glDeformationMap3dSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeformationMap3dSGIX, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points), (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points))
GLATTER_INLINE_OR_NOT void glatter_glDeformationMap3dSGIX_debug(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformationMap3dSGIX, "(%s, %f, %f, %d, %d, %f, %f, %d, %d, %f, %f, %d, %d, %p)", enum_to_string_GL(target), (double)u1, (double)u2, (int)ustride, (int)uorder, (double)v1, (double)v2, (int)vstride, (int)vorder, (double)w1, (double)w2, (int)wstride, (int)worder, (void*)points)
    glatter_glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeformationMap3dSGIX_defined
#endif
#ifndef glDeformationMap3fSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeformationMap3fSGIX, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points), (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points))
GLATTER_INLINE_OR_NOT void glatter_glDeformationMap3fSGIX_debug(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformationMap3fSGIX, "(%s, %f, %f, %d, %d, %f, %f, %d, %d, %f, %f, %d, %d, %p)", enum_to_string_GL(target), (float)u1, (float)u2, (int)ustride, (int)uorder, (float)v1, (float)v2, (int)vstride, (int)vorder, (float)w1, (float)w2, (int)wstride, (int)worder, (void*)points)
    glatter_glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeformationMap3fSGIX_defined
#endif
#ifndef glLoadIdentityDeformationMapSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadIdentityDeformationMapSGIX, (mask), (GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glLoadIdentityDeformationMapSGIX_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadIdentityDeformationMapSGIX, "(%u)", (unsigned int)mask)
    glatter_glLoadIdentityDeformationMapSGIX(mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadIdentityDeformationMapSGIX_defined
#endif
#endif // defined(GL_SGIX_polynomial_ffd)
#if defined(GL_SGIX_reference_plane)
#ifndef glReferencePlaneSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReferencePlaneSGIX, (equation), (const GLdouble *equation))
GLATTER_INLINE_OR_NOT void glatter_glReferencePlaneSGIX_debug(const GLdouble *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReferencePlaneSGIX, "(%p)", (void*)equation)
    glatter_glReferencePlaneSGIX(equation);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReferencePlaneSGIX_defined
#endif
#endif // defined(GL_SGIX_reference_plane)
#if defined(GL_SGIX_sprite)
#ifndef glSpriteParameterfSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpriteParameterfSGIX, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glSpriteParameterfSGIX_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterfSGIX, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glSpriteParameterfSGIX(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpriteParameterfSGIX_defined
#endif
#ifndef glSpriteParameterfvSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpriteParameterfvSGIX, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glSpriteParameterfvSGIX_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterfvSGIX, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glSpriteParameterfvSGIX(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpriteParameterfvSGIX_defined
#endif
#ifndef glSpriteParameteriSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpriteParameteriSGIX, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glSpriteParameteriSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameteriSGIX, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glSpriteParameteriSGIX(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpriteParameteriSGIX_defined
#endif
#ifndef glSpriteParameterivSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpriteParameterivSGIX, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glSpriteParameterivSGIX_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterivSGIX, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glSpriteParameterivSGIX(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpriteParameterivSGIX_defined
#endif
#endif // defined(GL_SGIX_sprite)
#if defined(GL_SGIX_tag_sample_buffer)
#ifndef glTagSampleBufferSGIX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTagSampleBufferSGIX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glTagSampleBufferSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTagSampleBufferSGIX, "()")
    glatter_glTagSampleBufferSGIX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTagSampleBufferSGIX_defined
#endif
#endif // defined(GL_SGIX_tag_sample_buffer)
#if defined(GL_SGI_color_table)
#ifndef glColorTableParameterfvSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableParameterfvSGI, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glColorTableParameterfvSGI_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterfvSGI, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterfvSGI(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableParameterfvSGI_defined
#endif
#ifndef glColorTableParameterivSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableParameterivSGI, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glColorTableParameterivSGI_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterivSGI, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterivSGI(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableParameterivSGI_defined
#endif
#ifndef glColorTableSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorTableSGI, (target, internalformat, width, format, type, table), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_INLINE_OR_NOT void glatter_glColorTableSGI_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableSGI, "(%s, %s, %d, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTableSGI(target, internalformat, width, format, type, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorTableSGI_defined
#endif
#ifndef glCopyColorTableSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyColorTableSGI, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyColorTableSGI_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorTableSGI, "(%s, %s, %d, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyColorTableSGI(target, internalformat, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyColorTableSGI_defined
#endif
#ifndef glGetColorTableParameterfvSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameterfvSGI, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameterfvSGI_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfvSGI, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfvSGI(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameterfvSGI_defined
#endif
#ifndef glGetColorTableParameterivSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableParameterivSGI, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableParameterivSGI_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterivSGI, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterivSGI(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableParameterivSGI_defined
#endif
#ifndef glGetColorTableSGI_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetColorTableSGI, (target, format, type, table), (GLenum target, GLenum format, GLenum type, void *table))
GLATTER_INLINE_OR_NOT void glatter_glGetColorTableSGI_debug(GLenum target, GLenum format, GLenum type, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableSGI, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glGetColorTableSGI(target, format, type, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetColorTableSGI_defined
#endif
#endif // defined(GL_SGI_color_table)
#if defined(GL_SUNX_constant_data)
#ifndef glFinishTextureSUNX_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFinishTextureSUNX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glFinishTextureSUNX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishTextureSUNX, "()")
    glatter_glFinishTextureSUNX();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFinishTextureSUNX_defined
#endif
#endif // defined(GL_SUNX_constant_data)
#if defined(GL_SUN_global_alpha)
#ifndef glGlobalAlphaFactorbSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactorbSUN, (factor), (GLbyte factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactorbSUN_debug(GLbyte factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorbSUN, "(%d)", (signed char)factor)
    glatter_glGlobalAlphaFactorbSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactorbSUN_defined
#endif
#ifndef glGlobalAlphaFactordSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactordSUN, (factor), (GLdouble factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactordSUN_debug(GLdouble factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactordSUN, "(%f)", (double)factor)
    glatter_glGlobalAlphaFactordSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactordSUN_defined
#endif
#ifndef glGlobalAlphaFactorfSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactorfSUN, (factor), (GLfloat factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactorfSUN_debug(GLfloat factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorfSUN, "(%f)", (float)factor)
    glatter_glGlobalAlphaFactorfSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactorfSUN_defined
#endif
#ifndef glGlobalAlphaFactoriSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactoriSUN, (factor), (GLint factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactoriSUN_debug(GLint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactoriSUN, "(%d)", (int)factor)
    glatter_glGlobalAlphaFactoriSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactoriSUN_defined
#endif
#ifndef glGlobalAlphaFactorsSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactorsSUN, (factor), (GLshort factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactorsSUN_debug(GLshort factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorsSUN, "(%hi)", (short)factor)
    glatter_glGlobalAlphaFactorsSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactorsSUN_defined
#endif
#ifndef glGlobalAlphaFactorubSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactorubSUN, (factor), (GLubyte factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactorubSUN_debug(GLubyte factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorubSUN, "(%u)", (unsigned char)factor)
    glatter_glGlobalAlphaFactorubSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactorubSUN_defined
#endif
#ifndef glGlobalAlphaFactoruiSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactoruiSUN, (factor), (GLuint factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactoruiSUN_debug(GLuint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactoruiSUN, "(%u)", (unsigned int)factor)
    glatter_glGlobalAlphaFactoruiSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactoruiSUN_defined
#endif
#ifndef glGlobalAlphaFactorusSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGlobalAlphaFactorusSUN, (factor), (GLushort factor))
GLATTER_INLINE_OR_NOT void glatter_glGlobalAlphaFactorusSUN_debug(GLushort factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorusSUN, "(%hu)", (unsigned short)factor)
    glatter_glGlobalAlphaFactorusSUN(factor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGlobalAlphaFactorusSUN_defined
#endif
#endif // defined(GL_SUN_global_alpha)
#if defined(GL_SUN_mesh_array)
#ifndef glDrawMeshArraysSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawMeshArraysSUN, (mode, first, count, width), (GLenum mode, GLint first, GLsizei count, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glDrawMeshArraysSUN_debug(GLenum mode, GLint first, GLsizei count, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawMeshArraysSUN, "(%s, %d, %d, %d)", enum_to_string_GL(mode), (int)first, (int)count, (int)width)
    glatter_glDrawMeshArraysSUN(mode, first, count, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawMeshArraysSUN_defined
#endif
#endif // defined(GL_SUN_mesh_array)
#if defined(GL_SUN_triangle_list)
#ifndef glReplacementCodePointerSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodePointerSUN, (type, stride, pointer), (GLenum type, GLsizei stride, const void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodePointerSUN_debug(GLenum type, GLsizei stride, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodePointerSUN, "(%s, %d, %p)", enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glReplacementCodePointerSUN(type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodePointerSUN_defined
#endif
#ifndef glReplacementCodeubSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeubSUN, (code), (GLubyte code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeubSUN_debug(GLubyte code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeubSUN, "(%u)", (unsigned char)code)
    glatter_glReplacementCodeubSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeubSUN_defined
#endif
#ifndef glReplacementCodeubvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeubvSUN, (code), (const GLubyte *code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeubvSUN_debug(const GLubyte *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeubvSUN, "(%p)", (void*)code)
    glatter_glReplacementCodeubvSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeubvSUN_defined
#endif
#ifndef glReplacementCodeuiSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiSUN, (code), (GLuint code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiSUN_debug(GLuint code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiSUN, "(%u)", (unsigned int)code)
    glatter_glReplacementCodeuiSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiSUN_defined
#endif
#ifndef glReplacementCodeuivSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuivSUN, (code), (const GLuint *code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuivSUN_debug(const GLuint *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuivSUN, "(%p)", (void*)code)
    glatter_glReplacementCodeuivSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuivSUN_defined
#endif
#ifndef glReplacementCodeusSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeusSUN, (code), (GLushort code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeusSUN_debug(GLushort code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeusSUN, "(%hu)", (unsigned short)code)
    glatter_glReplacementCodeusSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeusSUN_defined
#endif
#ifndef glReplacementCodeusvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeusvSUN, (code), (const GLushort *code))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeusvSUN_debug(const GLushort *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeusvSUN, "(%p)", (void*)code)
    glatter_glReplacementCodeusvSUN(code);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeusvSUN_defined
#endif
#endif // defined(GL_SUN_triangle_list)
#if defined(GL_SUN_vertex)
#ifndef glColor3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3fVertex3fSUN, (r, g, b, x, y, z), (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glColor3fVertex3fSUN_debug(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f)", (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glColor3fVertex3fSUN(r, g, b, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3fVertex3fSUN_defined
#endif
#ifndef glColor3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor3fVertex3fvSUN, (c, v), (const GLfloat *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glColor3fVertex3fvSUN_debug(const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3fVertex3fvSUN, "(%p, %p)", (void*)c, (void*)v)
    glatter_glColor3fVertex3fvSUN(c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor3fVertex3fvSUN_defined
#endif
#ifndef glColor4fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4fNormal3fVertex3fSUN, (r, g, b, a, nx, ny, nz, x, y, z), (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glColor4fNormal3fVertex3fSUN_debug(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4fNormal3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4fNormal3fVertex3fSUN_defined
#endif
#ifndef glColor4fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4fNormal3fVertex3fvSUN, (c, n, v), (const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glColor4fNormal3fVertex3fvSUN_debug(const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4fNormal3fVertex3fvSUN, "(%p, %p, %p)", (void*)c, (void*)n, (void*)v)
    glatter_glColor4fNormal3fVertex3fvSUN(c, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4fNormal3fVertex3fvSUN_defined
#endif
#ifndef glColor4ubVertex2fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4ubVertex2fSUN, (r, g, b, a, x, y), (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glColor4ubVertex2fSUN_debug(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex2fSUN, "(%u, %u, %u, %u, %f, %f)", (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y)
    glatter_glColor4ubVertex2fSUN(r, g, b, a, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4ubVertex2fSUN_defined
#endif
#ifndef glColor4ubVertex2fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4ubVertex2fvSUN, (c, v), (const GLubyte *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glColor4ubVertex2fvSUN_debug(const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex2fvSUN, "(%p, %p)", (void*)c, (void*)v)
    glatter_glColor4ubVertex2fvSUN(c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4ubVertex2fvSUN_defined
#endif
#ifndef glColor4ubVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4ubVertex3fSUN, (r, g, b, a, x, y, z), (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glColor4ubVertex3fSUN_debug(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex3fSUN, "(%u, %u, %u, %u, %f, %f, %f)", (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4ubVertex3fSUN_defined
#endif
#ifndef glColor4ubVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColor4ubVertex3fvSUN, (c, v), (const GLubyte *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glColor4ubVertex3fvSUN_debug(const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex3fvSUN, "(%p, %p)", (void*)c, (void*)v)
    glatter_glColor4ubVertex3fvSUN(c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColor4ubVertex3fvSUN_defined
#endif
#ifndef glNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3fVertex3fSUN, (nx, ny, nz, x, y, z), (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glNormal3fVertex3fSUN_debug(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f)", (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3fVertex3fSUN_defined
#endif
#ifndef glNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormal3fVertex3fvSUN, (n, v), (const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glNormal3fVertex3fvSUN_debug(const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3fVertex3fvSUN, "(%p, %p)", (void*)n, (void*)v)
    glatter_glNormal3fVertex3fvSUN(n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormal3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiColor3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor3fVertex3fSUN, (rc, r, g, b, x, y, z), (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor3fVertex3fSUN_debug(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor3fVertex3fSUN, "(%u, %f, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor3fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiColor3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor3fVertex3fvSUN, (rc, c, v), (const GLuint *rc, const GLfloat *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor3fVertex3fvSUN, "(%p, %p, %p)", (void*)rc, (void*)c, (void*)v)
    glatter_glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor4fNormal3fVertex3fSUN, (rc, r, g, b, a, nx, ny, nz, x, y, z), (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor4fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4fNormal3fVertex3fSUN, "(%u, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor4fNormal3fVertex3fvSUN, (rc, c, n, v), (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor4fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4fNormal3fVertex3fvSUN, "(%p, %p, %p, %p)", (void*)rc, (void*)c, (void*)n, (void*)v)
    glatter_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor4ubVertex3fSUN, (rc, r, g, b, a, x, y, z), (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor4ubVertex3fSUN_debug(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4ubVertex3fSUN, "(%u, %u, %u, %u, %u, %f, %f, %f)", (unsigned int)rc, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor4ubVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiColor4ubVertex3fvSUN, (rc, c, v), (const GLuint *rc, const GLubyte *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiColor4ubVertex3fvSUN_debug(const GLuint *rc, const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4ubVertex3fvSUN, "(%p, %p, %p)", (void*)rc, (void*)c, (void*)v)
    glatter_glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiColor4ubVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiNormal3fVertex3fSUN, (rc, nx, ny, nz, x, y, z), (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiNormal3fVertex3fSUN_debug(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiNormal3fVertex3fSUN, "(%u, %f, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiNormal3fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiNormal3fVertex3fvSUN, (rc, n, v), (const GLuint *rc, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiNormal3fVertex3fvSUN, "(%p, %p, %p)", (void*)rc, (void*)n, (void*)v)
    glatter_glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiNormal3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, (rc, s, t, r, g, b, a, nx, ny, nz, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, "(%u, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)s, (float)t, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, (rc, tc, c, n, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, "(%p, %p, %p, %p, %p)", (void*)rc, (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, (rc, s, t, nx, ny, nz, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, "(%u, %f, %f, %f, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)s, (float)t, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, (rc, tc, n, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, "(%p, %p, %p, %p)", (void*)rc, (void*)tc, (void*)n, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fVertex3fSUN, (rc, s, t, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fVertex3fSUN, "(%u, %f, %f, %f, %f, %f)", (unsigned int)rc, (float)s, (float)t, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiTexCoord2fVertex3fvSUN, (rc, tc, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiTexCoord2fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fVertex3fvSUN, "(%p, %p, %p)", (void*)rc, (void*)tc, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_defined
#endif
#ifndef glReplacementCodeuiVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiVertex3fSUN, (rc, x, y, z), (GLuint rc, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiVertex3fSUN_debug(GLuint rc, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiVertex3fSUN, "(%u, %f, %f, %f)", (unsigned int)rc, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiVertex3fSUN(rc, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiVertex3fSUN_defined
#endif
#ifndef glReplacementCodeuiVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReplacementCodeuiVertex3fvSUN, (rc, v), (const GLuint *rc, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glReplacementCodeuiVertex3fvSUN_debug(const GLuint *rc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiVertex3fvSUN, "(%p, %p)", (void*)rc, (void*)v)
    glatter_glReplacementCodeuiVertex3fvSUN(rc, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReplacementCodeuiVertex3fvSUN_defined
#endif
#ifndef glTexCoord2fColor3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor3fVertex3fSUN, (s, t, r, g, b, x, y, z), (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f)", (float)s, (float)t, (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor3fVertex3fSUN_defined
#endif
#ifndef glTexCoord2fColor3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor3fVertex3fvSUN, (tc, c, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor3fVertex3fvSUN, "(%p, %p, %p)", (void*)tc, (void*)c, (void*)v)
    glatter_glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor3fVertex3fvSUN_defined
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor4fNormal3fVertex3fSUN, (s, t, r, g, b, a, nx, ny, nz, x, y, z), (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor4fNormal3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4fNormal3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (float)s, (float)t, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor4fNormal3fVertex3fSUN_defined
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor4fNormal3fVertex3fvSUN, (tc, c, n, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor4fNormal3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4fNormal3fVertex3fvSUN, "(%p, %p, %p, %p)", (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_defined
#endif
#ifndef glTexCoord2fColor4ubVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor4ubVertex3fSUN, (s, t, r, g, b, a, x, y, z), (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor4ubVertex3fSUN_debug(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4ubVertex3fSUN, "(%f, %f, %u, %u, %u, %u, %f, %f, %f)", (float)s, (float)t, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor4ubVertex3fSUN_defined
#endif
#ifndef glTexCoord2fColor4ubVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fColor4ubVertex3fvSUN, (tc, c, v), (const GLfloat *tc, const GLubyte *c, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fColor4ubVertex3fvSUN_debug(const GLfloat *tc, const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4ubVertex3fvSUN, "(%p, %p, %p)", (void*)tc, (void*)c, (void*)v)
    glatter_glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fColor4ubVertex3fvSUN_defined
#endif
#ifndef glTexCoord2fNormal3fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fNormal3fVertex3fSUN, (s, t, nx, ny, nz, x, y, z), (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fNormal3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fNormal3fVertex3fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f)", (float)s, (float)t, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fNormal3fVertex3fSUN_defined
#endif
#ifndef glTexCoord2fNormal3fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fNormal3fVertex3fvSUN, (tc, n, v), (const GLfloat *tc, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fNormal3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fNormal3fVertex3fvSUN, "(%p, %p, %p)", (void*)tc, (void*)n, (void*)v)
    glatter_glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fNormal3fVertex3fvSUN_defined
#endif
#ifndef glTexCoord2fVertex3fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fVertex3fSUN, (s, t, x, y, z), (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fVertex3fSUN, "(%f, %f, %f, %f, %f)", (float)s, (float)t, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fVertex3fSUN(s, t, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fVertex3fSUN_defined
#endif
#ifndef glTexCoord2fVertex3fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord2fVertex3fvSUN, (tc, v), (const GLfloat *tc, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord2fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fVertex3fvSUN, "(%p, %p)", (void*)tc, (void*)v)
    glatter_glTexCoord2fVertex3fvSUN(tc, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord2fVertex3fvSUN_defined
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4fColor4fNormal3fVertex4fSUN, (s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w), (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4fColor4fNormal3fVertex4fSUN_debug(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fColor4fNormal3fVertex4fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f)", (float)s, (float)t, (float)p, (float)q, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z, (float)w)
    glatter_glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4fColor4fNormal3fVertex4fSUN_defined
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4fColor4fNormal3fVertex4fvSUN, (tc, c, n, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4fColor4fNormal3fVertex4fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fColor4fNormal3fVertex4fvSUN, "(%p, %p, %p, %p)", (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_defined
#endif
#ifndef glTexCoord4fVertex4fSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4fVertex4fSUN, (s, t, p, q, x, y, z, w), (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4fVertex4fSUN_debug(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fVertex4fSUN, "(%f, %f, %f, %f, %f, %f, %f, %f)", (float)s, (float)t, (float)p, (float)q, (float)x, (float)y, (float)z, (float)w)
    glatter_glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4fVertex4fSUN_defined
#endif
#ifndef glTexCoord4fVertex4fvSUN_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoord4fVertex4fvSUN, (tc, v), (const GLfloat *tc, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glTexCoord4fVertex4fvSUN_debug(const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fVertex4fvSUN, "(%p, %p)", (void*)tc, (void*)v)
    glatter_glTexCoord4fVertex4fvSUN(tc, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoord4fVertex4fvSUN_defined
#endif
#endif // defined(GL_SUN_vertex)
#if defined(GL_VERSION_1_2)
#ifndef glCopyTexSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3D, "(%s, %d, %d, %d, %d, %d, %d, %d, %d)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTexSubImage3D_defined
#endif
#ifndef glDrawRangeElements_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawRangeElements, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
GLATTER_INLINE_OR_NOT void glatter_glDrawRangeElements_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElements, "(%s, %u, %u, %d, %s, %p)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElements(mode, start, end, count, type, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawRangeElements_defined
#endif
#ifndef glTexImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexImage3D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3D, "(%s, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage3D_defined
#endif
#ifndef glTexSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3D, "(%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexSubImage3D_defined
#endif
#endif // defined(GL_VERSION_1_2)
#if defined(GL_VERSION_1_3)
#ifndef glActiveTexture_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveTexture, (texture), (GLenum texture))
GLATTER_INLINE_OR_NOT void glatter_glActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTexture, "(%s)", enum_to_string_GL(texture))
    glatter_glActiveTexture(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveTexture_defined
#endif
#ifndef glClientActiveTexture_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClientActiveTexture, (texture), (GLenum texture))
GLATTER_INLINE_OR_NOT void glatter_glClientActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveTexture, "(%s)", enum_to_string_GL(texture))
    glatter_glClientActiveTexture(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClientActiveTexture_defined
#endif
#ifndef glCompressedTexImage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage1D, (target, level, internalformat, width, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage1D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage1D, "(%s, %d, %s, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage1D_defined
#endif
#ifndef glCompressedTexImage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage2D, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2D, "(%s, %d, %s, %d, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage2D_defined
#endif
#ifndef glCompressedTexImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexImage3D, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexImage3D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3D, "(%s, %d, %s, %d, %d, %d, %d, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexImage3D_defined
#endif
#ifndef glCompressedTexSubImage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage1D, (target, level, xoffset, width, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage1D, "(%s, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage1D_defined
#endif
#ifndef glCompressedTexSubImage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2D, "(%s, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage2D_defined
#endif
#ifndef glCompressedTexSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3D, "(%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p)", enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTexSubImage3D_defined
#endif
#ifndef glGetCompressedTexImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedTexImage, (target, level, img), (GLenum target, GLint level, void *img))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedTexImage_debug(GLenum target, GLint level, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTexImage, "(%s, %d, %p)", enum_to_string_GL(target), (int)level, (void*)img)
    glatter_glGetCompressedTexImage(target, level, img);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedTexImage_defined
#endif
#ifndef glLoadTransposeMatrixd_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadTransposeMatrixd, (m), (const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadTransposeMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixd, "(%p)", (void*)m)
    glatter_glLoadTransposeMatrixd(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadTransposeMatrixd_defined
#endif
#ifndef glLoadTransposeMatrixf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLoadTransposeMatrixf, (m), (const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glLoadTransposeMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixf, "(%p)", (void*)m)
    glatter_glLoadTransposeMatrixf(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLoadTransposeMatrixf_defined
#endif
#ifndef glMultTransposeMatrixd_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultTransposeMatrixd, (m), (const GLdouble *m))
GLATTER_INLINE_OR_NOT void glatter_glMultTransposeMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixd, "(%p)", (void*)m)
    glatter_glMultTransposeMatrixd(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultTransposeMatrixd_defined
#endif
#ifndef glMultTransposeMatrixf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultTransposeMatrixf, (m), (const GLfloat *m))
GLATTER_INLINE_OR_NOT void glatter_glMultTransposeMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixf, "(%p)", (void*)m)
    glatter_glMultTransposeMatrixf(m);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultTransposeMatrixf_defined
#endif
#ifndef glMultiTexCoord1d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1d, (target, s), (GLenum target, GLdouble s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1d_debug(GLenum target, GLdouble s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1d, "(%s, %f)", enum_to_string_GL(target), (double)s)
    glatter_glMultiTexCoord1d(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1d_defined
#endif
#ifndef glMultiTexCoord1dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1dv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1dv_defined
#endif
#ifndef glMultiTexCoord1f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1f, (target, s), (GLenum target, GLfloat s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1f_debug(GLenum target, GLfloat s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1f, "(%s, %f)", enum_to_string_GL(target), (float)s)
    glatter_glMultiTexCoord1f(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1f_defined
#endif
#ifndef glMultiTexCoord1fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1fv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1fv_defined
#endif
#ifndef glMultiTexCoord1i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1i, (target, s), (GLenum target, GLint s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1i_debug(GLenum target, GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1i, "(%s, %d)", enum_to_string_GL(target), (int)s)
    glatter_glMultiTexCoord1i(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1i_defined
#endif
#ifndef glMultiTexCoord1iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1iv, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1iv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1iv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1iv_defined
#endif
#ifndef glMultiTexCoord1s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1s, (target, s), (GLenum target, GLshort s))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1s_debug(GLenum target, GLshort s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1s, "(%s, %hi)", enum_to_string_GL(target), (short)s)
    glatter_glMultiTexCoord1s(target, s);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1s_defined
#endif
#ifndef glMultiTexCoord1sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord1sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord1sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1sv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1sv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord1sv_defined
#endif
#ifndef glMultiTexCoord2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2d, (target, s, t), (GLenum target, GLdouble s, GLdouble t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2d_debug(GLenum target, GLdouble s, GLdouble t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2d, "(%s, %f, %f)", enum_to_string_GL(target), (double)s, (double)t)
    glatter_glMultiTexCoord2d(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2d_defined
#endif
#ifndef glMultiTexCoord2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2dv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2dv_defined
#endif
#ifndef glMultiTexCoord2f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2f, (target, s, t), (GLenum target, GLfloat s, GLfloat t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2f_debug(GLenum target, GLfloat s, GLfloat t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2f, "(%s, %f, %f)", enum_to_string_GL(target), (float)s, (float)t)
    glatter_glMultiTexCoord2f(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2f_defined
#endif
#ifndef glMultiTexCoord2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2fv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2fv_defined
#endif
#ifndef glMultiTexCoord2i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2i, (target, s, t), (GLenum target, GLint s, GLint t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2i_debug(GLenum target, GLint s, GLint t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2i, "(%s, %d, %d)", enum_to_string_GL(target), (int)s, (int)t)
    glatter_glMultiTexCoord2i(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2i_defined
#endif
#ifndef glMultiTexCoord2iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2iv, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2iv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2iv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2iv_defined
#endif
#ifndef glMultiTexCoord2s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2s, (target, s, t), (GLenum target, GLshort s, GLshort t))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2s_debug(GLenum target, GLshort s, GLshort t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2s, "(%s, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t)
    glatter_glMultiTexCoord2s(target, s, t);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2s_defined
#endif
#ifndef glMultiTexCoord2sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord2sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord2sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2sv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2sv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord2sv_defined
#endif
#ifndef glMultiTexCoord3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3d, (target, s, t, r), (GLenum target, GLdouble s, GLdouble t, GLdouble r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3d_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3d, "(%s, %f, %f, %f)", enum_to_string_GL(target), (double)s, (double)t, (double)r)
    glatter_glMultiTexCoord3d(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3d_defined
#endif
#ifndef glMultiTexCoord3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3dv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3dv_defined
#endif
#ifndef glMultiTexCoord3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3f, (target, s, t, r), (GLenum target, GLfloat s, GLfloat t, GLfloat r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3f_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3f, "(%s, %f, %f, %f)", enum_to_string_GL(target), (float)s, (float)t, (float)r)
    glatter_glMultiTexCoord3f(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3f_defined
#endif
#ifndef glMultiTexCoord3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3fv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3fv_defined
#endif
#ifndef glMultiTexCoord3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3i, (target, s, t, r), (GLenum target, GLint s, GLint t, GLint r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3i_debug(GLenum target, GLint s, GLint t, GLint r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3i, "(%s, %d, %d, %d)", enum_to_string_GL(target), (int)s, (int)t, (int)r)
    glatter_glMultiTexCoord3i(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3i_defined
#endif
#ifndef glMultiTexCoord3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3iv, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3iv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3iv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3iv_defined
#endif
#ifndef glMultiTexCoord3s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3s, (target, s, t, r), (GLenum target, GLshort s, GLshort t, GLshort r))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3s_debug(GLenum target, GLshort s, GLshort t, GLshort r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3s, "(%s, %hi, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t, (short)r)
    glatter_glMultiTexCoord3s(target, s, t, r);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3s_defined
#endif
#ifndef glMultiTexCoord3sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord3sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord3sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3sv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3sv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord3sv_defined
#endif
#ifndef glMultiTexCoord4d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4d, (target, s, t, r, q), (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4d_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4d, "(%s, %f, %f, %f, %f)", enum_to_string_GL(target), (double)s, (double)t, (double)r, (double)q)
    glatter_glMultiTexCoord4d(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4d_defined
#endif
#ifndef glMultiTexCoord4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4dv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4dv_defined
#endif
#ifndef glMultiTexCoord4f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4f, (target, s, t, r, q), (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4f_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4f, "(%s, %f, %f, %f, %f)", enum_to_string_GL(target), (float)s, (float)t, (float)r, (float)q)
    glatter_glMultiTexCoord4f(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4f_defined
#endif
#ifndef glMultiTexCoord4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4fv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4fv_defined
#endif
#ifndef glMultiTexCoord4i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4i, (target, s, t, r, q), (GLenum target, GLint s, GLint t, GLint r, GLint q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4i_debug(GLenum target, GLint s, GLint t, GLint r, GLint q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4i, "(%s, %d, %d, %d, %d)", enum_to_string_GL(target), (int)s, (int)t, (int)r, (int)q)
    glatter_glMultiTexCoord4i(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4i_defined
#endif
#ifndef glMultiTexCoord4iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4iv, (target, v), (GLenum target, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4iv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4iv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4iv_defined
#endif
#ifndef glMultiTexCoord4s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4s, (target, s, t, r, q), (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4s_debug(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4s, "(%s, %hi, %hi, %hi, %hi)", enum_to_string_GL(target), (short)s, (short)t, (short)r, (short)q)
    glatter_glMultiTexCoord4s(target, s, t, r, q);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4s_defined
#endif
#ifndef glMultiTexCoord4sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoord4sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoord4sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4sv, "(%s, %p)", enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4sv(target, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoord4sv_defined
#endif
#ifndef glSampleCoverage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleCoverage, (value, invert), (GLfloat value, GLboolean invert))
GLATTER_INLINE_OR_NOT void glatter_glSampleCoverage_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverage, "(%f, %u)", (float)value, (unsigned char)invert)
    glatter_glSampleCoverage(value, invert);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleCoverage_defined
#endif
#endif // defined(GL_VERSION_1_3)
#if defined(GL_VERSION_1_4)
#ifndef glBlendColor_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColor, "(%f, %f, %f, %f)", (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColor(red, green, blue, alpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendColor_defined
#endif
#ifndef glBlendEquation_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquation, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquation_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquation, "(%s)", enum_to_string_GL(mode))
    glatter_glBlendEquation(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquation_defined
#endif
#ifndef glBlendFuncSeparate_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparate, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparate_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparate, "(%s, %s, %s, %s)", enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparate_defined
#endif
#ifndef glFogCoordPointer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordPointer, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordPointer_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointer, "(%s, %d, %p)", enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glFogCoordPointer(type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordPointer_defined
#endif
#ifndef glFogCoordd_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordd, (coord), (GLdouble coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordd_debug(GLdouble coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordd, "(%f)", (double)coord)
    glatter_glFogCoordd(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordd_defined
#endif
#ifndef glFogCoorddv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoorddv, (coord), (const GLdouble *coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoorddv_debug(const GLdouble *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddv, "(%p)", (void*)coord)
    glatter_glFogCoorddv(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoorddv_defined
#endif
#ifndef glFogCoordf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordf, (coord), (GLfloat coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordf_debug(GLfloat coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordf, "(%f)", (float)coord)
    glatter_glFogCoordf(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordf_defined
#endif
#ifndef glFogCoordfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFogCoordfv, (coord), (const GLfloat *coord))
GLATTER_INLINE_OR_NOT void glatter_glFogCoordfv_debug(const GLfloat *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfv, "(%p)", (void*)coord)
    glatter_glFogCoordfv(coord);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFogCoordfv_defined
#endif
#ifndef glMultiDrawArrays_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArrays, (mode, first, count, drawcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArrays_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArrays, "(%s, %p, %p, %d)", enum_to_string_GL(mode), (void*)first, (void*)count, (int)drawcount)
    glatter_glMultiDrawArrays(mode, first, count, drawcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArrays_defined
#endif
#ifndef glMultiDrawElements_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElements, (mode, count, type, indices, drawcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElements_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElements, "(%s, %p, %s, %p, %d)", enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount)
    glatter_glMultiDrawElements(mode, count, type, indices, drawcount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElements_defined
#endif
#ifndef glPointParameterf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterf, "(%s, %f)", enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterf(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterf_defined
#endif
#ifndef glPointParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameterfv, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameterfv_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfv, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfv(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameterfv_defined
#endif
#ifndef glPointParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameteri, (pname, param), (GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glPointParameteri_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteri, "(%s, %d)", enum_to_string_GL(pname), (int)param)
    glatter_glPointParameteri(pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameteri_defined
#endif
#ifndef glPointParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPointParameteriv, (pname, params), (GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glPointParameteriv_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteriv, "(%s, %p)", enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameteriv(pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPointParameteriv_defined
#endif
#ifndef glSecondaryColor3b_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3b, (red, green, blue), (GLbyte red, GLbyte green, GLbyte blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3b_debug(GLbyte red, GLbyte green, GLbyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3b, "(%d, %d, %d)", (signed char)red, (signed char)green, (signed char)blue)
    glatter_glSecondaryColor3b(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3b_defined
#endif
#ifndef glSecondaryColor3bv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3bv, (v), (const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3bv_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bv, "(%p)", (void*)v)
    glatter_glSecondaryColor3bv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3bv_defined
#endif
#ifndef glSecondaryColor3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3d, (red, green, blue), (GLdouble red, GLdouble green, GLdouble blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3d_debug(GLdouble red, GLdouble green, GLdouble blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3d, "(%f, %f, %f)", (double)red, (double)green, (double)blue)
    glatter_glSecondaryColor3d(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3d_defined
#endif
#ifndef glSecondaryColor3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3dv, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dv, "(%p)", (void*)v)
    glatter_glSecondaryColor3dv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3dv_defined
#endif
#ifndef glSecondaryColor3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3f, (red, green, blue), (GLfloat red, GLfloat green, GLfloat blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3f_debug(GLfloat red, GLfloat green, GLfloat blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3f, "(%f, %f, %f)", (float)red, (float)green, (float)blue)
    glatter_glSecondaryColor3f(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3f_defined
#endif
#ifndef glSecondaryColor3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3fv, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fv, "(%p)", (void*)v)
    glatter_glSecondaryColor3fv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3fv_defined
#endif
#ifndef glSecondaryColor3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3i, (red, green, blue), (GLint red, GLint green, GLint blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3i_debug(GLint red, GLint green, GLint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3i, "(%d, %d, %d)", (int)red, (int)green, (int)blue)
    glatter_glSecondaryColor3i(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3i_defined
#endif
#ifndef glSecondaryColor3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3iv, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3iv, "(%p)", (void*)v)
    glatter_glSecondaryColor3iv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3iv_defined
#endif
#ifndef glSecondaryColor3s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3s, (red, green, blue), (GLshort red, GLshort green, GLshort blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3s_debug(GLshort red, GLshort green, GLshort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3s, "(%hi, %hi, %hi)", (short)red, (short)green, (short)blue)
    glatter_glSecondaryColor3s(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3s_defined
#endif
#ifndef glSecondaryColor3sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3sv, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3sv, "(%p)", (void*)v)
    glatter_glSecondaryColor3sv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3sv_defined
#endif
#ifndef glSecondaryColor3ub_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ub, (red, green, blue), (GLubyte red, GLubyte green, GLubyte blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ub_debug(GLubyte red, GLubyte green, GLubyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ub, "(%u, %u, %u)", (unsigned char)red, (unsigned char)green, (unsigned char)blue)
    glatter_glSecondaryColor3ub(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ub_defined
#endif
#ifndef glSecondaryColor3ubv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ubv, (v), (const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ubv_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubv, "(%p)", (void*)v)
    glatter_glSecondaryColor3ubv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ubv_defined
#endif
#ifndef glSecondaryColor3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3ui, (red, green, blue), (GLuint red, GLuint green, GLuint blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3ui_debug(GLuint red, GLuint green, GLuint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ui, "(%u, %u, %u)", (unsigned int)red, (unsigned int)green, (unsigned int)blue)
    glatter_glSecondaryColor3ui(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3ui_defined
#endif
#ifndef glSecondaryColor3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3uiv, (v), (const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3uiv_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uiv, "(%p)", (void*)v)
    glatter_glSecondaryColor3uiv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3uiv_defined
#endif
#ifndef glSecondaryColor3us_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3us, (red, green, blue), (GLushort red, GLushort green, GLushort blue))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3us_debug(GLushort red, GLushort green, GLushort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3us, "(%hu, %hu, %hu)", (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3us(red, green, blue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3us_defined
#endif
#ifndef glSecondaryColor3usv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColor3usv, (v), (const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColor3usv_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usv, "(%p)", (void*)v)
    glatter_glSecondaryColor3usv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColor3usv_defined
#endif
#ifndef glSecondaryColorPointer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorPointer, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorPointer_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointer, "(%d, %s, %d, %p)", (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glSecondaryColorPointer(size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorPointer_defined
#endif
#ifndef glWindowPos2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2d, (x, y), (GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2d_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2d, "(%f, %f)", (double)x, (double)y)
    glatter_glWindowPos2d(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2d_defined
#endif
#ifndef glWindowPos2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2dv, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dv, "(%p)", (void*)v)
    glatter_glWindowPos2dv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2dv_defined
#endif
#ifndef glWindowPos2f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2f, (x, y), (GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2f_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2f, "(%f, %f)", (float)x, (float)y)
    glatter_glWindowPos2f(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2f_defined
#endif
#ifndef glWindowPos2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2fv, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fv, "(%p)", (void*)v)
    glatter_glWindowPos2fv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2fv_defined
#endif
#ifndef glWindowPos2i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2i, (x, y), (GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2i_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2i, "(%d, %d)", (int)x, (int)y)
    glatter_glWindowPos2i(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2i_defined
#endif
#ifndef glWindowPos2iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2iv, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iv, "(%p)", (void*)v)
    glatter_glWindowPos2iv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2iv_defined
#endif
#ifndef glWindowPos2s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2s, (x, y), (GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2s_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2s, "(%hi, %hi)", (short)x, (short)y)
    glatter_glWindowPos2s(x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2s_defined
#endif
#ifndef glWindowPos2sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos2sv, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos2sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sv, "(%p)", (void*)v)
    glatter_glWindowPos2sv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos2sv_defined
#endif
#ifndef glWindowPos3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3d, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3d_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3d, "(%f, %f, %f)", (double)x, (double)y, (double)z)
    glatter_glWindowPos3d(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3d_defined
#endif
#ifndef glWindowPos3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3dv, (v), (const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dv, "(%p)", (void*)v)
    glatter_glWindowPos3dv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3dv_defined
#endif
#ifndef glWindowPos3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3f, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3f_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3f, "(%f, %f, %f)", (float)x, (float)y, (float)z)
    glatter_glWindowPos3f(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3f_defined
#endif
#ifndef glWindowPos3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3fv, (v), (const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fv, "(%p)", (void*)v)
    glatter_glWindowPos3fv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3fv_defined
#endif
#ifndef glWindowPos3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3i, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3i_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3i, "(%d, %d, %d)", (int)x, (int)y, (int)z)
    glatter_glWindowPos3i(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3i_defined
#endif
#ifndef glWindowPos3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3iv, (v), (const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iv, "(%p)", (void*)v)
    glatter_glWindowPos3iv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3iv_defined
#endif
#ifndef glWindowPos3s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3s, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3s_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3s, "(%hi, %hi, %hi)", (short)x, (short)y, (short)z)
    glatter_glWindowPos3s(x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3s_defined
#endif
#ifndef glWindowPos3sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWindowPos3sv, (v), (const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glWindowPos3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sv, "(%p)", (void*)v)
    glatter_glWindowPos3sv(v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWindowPos3sv_defined
#endif
#endif // defined(GL_VERSION_1_4)
#if defined(GL_VERSION_1_5)
#ifndef glBeginQuery_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginQuery, (target, id), (GLenum target, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBeginQuery_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQuery, "(%s, %u)", enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQuery(target, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginQuery_defined
#endif
#ifndef glBindBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBuffer, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glBindBuffer_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffer, "(%s, %u)", enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBuffer(target, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBuffer_defined
#endif
#ifndef glBufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferData, (target, size, data, usage), (GLenum target, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_INLINE_OR_NOT void glatter_glBufferData_debug(GLenum target, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferData, "(%s, %s, %p, %s)", enum_to_string_GL(target), GET_PRS(size), (void*)data, enum_to_string_GL(usage))
    glatter_glBufferData(target, size, data, usage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferData_defined
#endif
#ifndef glBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubData, "(%s, %s, %s, %p)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glBufferSubData(target, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferSubData_defined
#endif
#ifndef glDeleteBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteBuffers, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteBuffers_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffers, "(%d, %p)", (int)n, (void*)buffers)
    glatter_glDeleteBuffers(n, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteBuffers_defined
#endif
#ifndef glDeleteQueries_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteQueries, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glDeleteQueries_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueries, "(%d, %p)", (int)n, (void*)ids)
    glatter_glDeleteQueries(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteQueries_defined
#endif
#ifndef glEndQuery_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndQuery, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glEndQuery_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQuery, "(%s)", enum_to_string_GL(target))
    glatter_glEndQuery(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndQuery_defined
#endif
#ifndef glGenBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glGenBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffers, "(%d, %p)", (int)n, (void*)buffers)
    glatter_glGenBuffers(n, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenBuffers_defined
#endif
#ifndef glGenQueries_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenQueries, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glGenQueries_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueries, "(%d, %p)", (int)n, (void*)ids)
    glatter_glGenQueries(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenQueries_defined
#endif
#ifndef glGetBufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferParameteriv_defined
#endif
#ifndef glGetBufferPointerv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferPointerv, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferPointerv_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointerv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointerv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferPointerv_defined
#endif
#ifndef glGetBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferSubData, "(%s, %s, %s, %p)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glGetBufferSubData(target, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferSubData_defined
#endif
#ifndef glGetQueryObjectiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectiv, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectiv_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectiv, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectiv(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectiv_defined
#endif
#ifndef glGetQueryObjectuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectuiv, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectuiv_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuiv, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuiv(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectuiv_defined
#endif
#ifndef glGetQueryiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryiv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryiv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryiv_defined
#endif
#ifndef glIsBuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsBuffer, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBuffer, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glIsBuffer(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsBuffer_defined
#endif
#ifndef glIsQuery_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsQuery, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsQuery_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQuery, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsQuery(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsQuery_defined
#endif
#ifndef glMapBuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapBuffer, (target, access), (GLenum target, GLenum access))
GLATTER_INLINE_OR_NOT void * glatter_glMapBuffer_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBuffer, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBuffer(target, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapBuffer_defined
#endif
#ifndef glUnmapBuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glUnmapBuffer, (target), (GLenum target))
GLATTER_INLINE_OR_NOT GLboolean glatter_glUnmapBuffer_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBuffer, "(%s)", enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBuffer(target);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glUnmapBuffer_defined
#endif
#endif // defined(GL_VERSION_1_5)
#if defined(GL_VERSION_2_0)
#ifndef glAttachShader_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glAttachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_INLINE_OR_NOT void glatter_glAttachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachShader, "(%u, %u)", (unsigned int)program, (unsigned int)shader)
    glatter_glAttachShader(program, shader);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glAttachShader_defined
#endif
#ifndef glBindAttribLocation_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindAttribLocation, (program, index, name), (GLuint program, GLuint index, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glBindAttribLocation_debug(GLuint program, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocation, "(%u, %u, %p)", (unsigned int)program, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocation(program, index, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindAttribLocation_defined
#endif
#ifndef glBlendEquationSeparate_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationSeparate, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationSeparate_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparate, "(%s, %s)", enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparate(modeRGB, modeAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationSeparate_defined
#endif
#ifndef glCompileShader_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompileShader, (shader), (GLuint shader))
GLATTER_INLINE_OR_NOT void glatter_glCompileShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShader, "(%u)", (unsigned int)shader)
    glatter_glCompileShader(shader);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompileShader_defined
#endif
#ifndef glCreateProgram_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glCreateProgram, (), (void))
GLATTER_INLINE_OR_NOT GLuint glatter_glCreateProgram_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgram, "()")
    GLuint rval = glatter_glCreateProgram();
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateProgram_defined
#endif
#ifndef glCreateShader_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glCreateShader, (type), (GLenum type))
GLATTER_INLINE_OR_NOT GLuint glatter_glCreateShader_debug(GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShader, "(%s)", enum_to_string_GL(type))
    GLuint rval = glatter_glCreateShader(type);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateShader_defined
#endif
#ifndef glDeleteProgram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteProgram, (program), (GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glDeleteProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgram, "(%u)", (unsigned int)program)
    glatter_glDeleteProgram(program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteProgram_defined
#endif
#ifndef glDeleteShader_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteShader, (shader), (GLuint shader))
GLATTER_INLINE_OR_NOT void glatter_glDeleteShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteShader, "(%u)", (unsigned int)shader)
    glatter_glDeleteShader(shader);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteShader_defined
#endif
#ifndef glDetachShader_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDetachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_INLINE_OR_NOT void glatter_glDetachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachShader, "(%u, %u)", (unsigned int)program, (unsigned int)shader)
    glatter_glDetachShader(program, shader);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDetachShader_defined
#endif
#ifndef glDisableVertexAttribArray_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexAttribArray, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArray, "(%u)", (unsigned int)index)
    glatter_glDisableVertexAttribArray(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexAttribArray_defined
#endif
#ifndef glDrawBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawBuffers, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_INLINE_OR_NOT void glatter_glDrawBuffers_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffers, "(%d, %p)", (int)n, (void*)bufs)
    glatter_glDrawBuffers(n, bufs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawBuffers_defined
#endif
#ifndef glEnableVertexAttribArray_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexAttribArray, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArray, "(%u)", (unsigned int)index)
    glatter_glEnableVertexAttribArray(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexAttribArray_defined
#endif
#ifndef glGetActiveAttrib_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveAttrib, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveAttrib_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttrib, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttrib(program, index, bufSize, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveAttrib_defined
#endif
#ifndef glGetActiveUniform_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniform, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniform_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniform, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniform(program, index, bufSize, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniform_defined
#endif
#ifndef glGetAttachedShaders_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetAttachedShaders, (program, maxCount, count, shaders), (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders))
GLATTER_INLINE_OR_NOT void glatter_glGetAttachedShaders_debug(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedShaders, "(%u, %d, %p, %p)", (unsigned int)program, (int)maxCount, (void*)count, (void*)shaders)
    glatter_glGetAttachedShaders(program, maxCount, count, shaders);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetAttachedShaders_defined
#endif
#ifndef glGetAttribLocation_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetAttribLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetAttribLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocation, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetAttribLocation(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetAttribLocation_defined
#endif
#ifndef glGetProgramInfoLog_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramInfoLog, (program, bufSize, length, infoLog), (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramInfoLog_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInfoLog, "(%u, %d, %p, %p)", (unsigned int)program, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramInfoLog(program, bufSize, length, infoLog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramInfoLog_defined
#endif
#ifndef glGetProgramiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramiv, (program, pname, params), (GLuint program, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramiv_debug(GLuint program, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramiv, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramiv(program, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramiv_defined
#endif
#ifndef glGetShaderInfoLog_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShaderInfoLog, (shader, bufSize, length, infoLog), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_INLINE_OR_NOT void glatter_glGetShaderInfoLog_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderInfoLog, "(%u, %d, %p, %p)", (unsigned int)shader, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetShaderInfoLog(shader, bufSize, length, infoLog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShaderInfoLog_defined
#endif
#ifndef glGetShaderSource_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShaderSource, (shader, bufSize, length, source), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source))
GLATTER_INLINE_OR_NOT void glatter_glGetShaderSource_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSource, "(%u, %d, %p, %p)", (unsigned int)shader, (int)bufSize, (void*)length, (void*)source)
    glatter_glGetShaderSource(shader, bufSize, length, source);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShaderSource_defined
#endif
#ifndef glGetShaderiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShaderiv, (shader, pname, params), (GLuint shader, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetShaderiv_debug(GLuint shader, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderiv, "(%u, %s, %p)", (unsigned int)shader, enum_to_string_GL(pname), (void*)params)
    glatter_glGetShaderiv(shader, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShaderiv_defined
#endif
#ifndef glGetUniformLocation_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetUniformLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetUniformLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocation, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetUniformLocation(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetUniformLocation_defined
#endif
#ifndef glGetUniformfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformfv, (program, location, params), (GLuint program, GLint location, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformfv_debug(GLuint program, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfv, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformfv(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformfv_defined
#endif
#ifndef glGetUniformiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformiv, (program, location, params), (GLuint program, GLint location, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformiv_debug(GLuint program, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformiv, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformiv(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformiv_defined
#endif
#ifndef glGetVertexAttribPointerv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribPointerv, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribPointerv_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointerv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointerv(index, pname, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribPointerv_defined
#endif
#ifndef glGetVertexAttribdv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribdv_defined
#endif
#ifndef glGetVertexAttribfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribfv, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribfv_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribfv_defined
#endif
#ifndef glGetVertexAttribiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribiv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribiv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribiv_defined
#endif
#ifndef glIsProgram_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsProgram, (program), (GLuint program))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgram, "(%u)", (unsigned int)program)
    GLboolean rval = glatter_glIsProgram(program);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsProgram_defined
#endif
#ifndef glIsShader_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsShader, (shader), (GLuint shader))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsShader, "(%u)", (unsigned int)shader)
    GLboolean rval = glatter_glIsShader(shader);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsShader_defined
#endif
#ifndef glLinkProgram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glLinkProgram, (program), (GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glLinkProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgram, "(%u)", (unsigned int)program)
    glatter_glLinkProgram(program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glLinkProgram_defined
#endif
#ifndef glShaderSource_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderSource, (shader, count, string, length), (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length))
GLATTER_INLINE_OR_NOT void glatter_glShaderSource_debug(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSource, "(%u, %d, %p, %p)", (unsigned int)shader, (int)count, (void*)string, (void*)length)
    glatter_glShaderSource(shader, count, string, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderSource_defined
#endif
#ifndef glStencilFuncSeparate_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilFuncSeparate, (face, func, ref, mask), (GLenum face, GLenum func, GLint ref, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glStencilFuncSeparate_debug(GLenum face, GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparate, "(%s, %s, %d, %u)", enum_to_string_GL(face), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparate(face, func, ref, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilFuncSeparate_defined
#endif
#ifndef glStencilMaskSeparate_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilMaskSeparate, (face, mask), (GLenum face, GLuint mask))
GLATTER_INLINE_OR_NOT void glatter_glStencilMaskSeparate_debug(GLenum face, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMaskSeparate, "(%s, %u)", enum_to_string_GL(face), (unsigned int)mask)
    glatter_glStencilMaskSeparate(face, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilMaskSeparate_defined
#endif
#ifndef glStencilOpSeparate_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glStencilOpSeparate, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
GLATTER_INLINE_OR_NOT void glatter_glStencilOpSeparate_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparate, "(%s, %s, %s, %s)", enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparate(face, sfail, dpfail, dppass);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glStencilOpSeparate_defined
#endif
#ifndef glUniform1f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1f, (location, v0), (GLint location, GLfloat v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1f_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1f, "(%d, %f)", (int)location, (float)v0)
    glatter_glUniform1f(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1f_defined
#endif
#ifndef glUniform1fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1fv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1fv_defined
#endif
#ifndef glUniform1i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1i, (location, v0), (GLint location, GLint v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1i_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i, "(%d, %d)", (int)location, (int)v0)
    glatter_glUniform1i(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1i_defined
#endif
#ifndef glUniform1iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1iv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1iv_defined
#endif
#ifndef glUniform2f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2f, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2f_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2f, "(%d, %f, %f)", (int)location, (float)v0, (float)v1)
    glatter_glUniform2f(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2f_defined
#endif
#ifndef glUniform2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2fv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2fv_defined
#endif
#ifndef glUniform2i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2i, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2i_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i, "(%d, %d, %d)", (int)location, (int)v0, (int)v1)
    glatter_glUniform2i(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2i_defined
#endif
#ifndef glUniform2iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2iv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2iv_defined
#endif
#ifndef glUniform3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3f, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3f, "(%d, %f, %f, %f)", (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3f(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3f_defined
#endif
#ifndef glUniform3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3fv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3fv_defined
#endif
#ifndef glUniform3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3i, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3i_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i, "(%d, %d, %d, %d)", (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3i(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3i_defined
#endif
#ifndef glUniform3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3iv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3iv_defined
#endif
#ifndef glUniform4f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4f, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4f, "(%d, %f, %f, %f, %f)", (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4f(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4f_defined
#endif
#ifndef glUniform4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4fv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4fv_defined
#endif
#ifndef glUniform4i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4i, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4i_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i, "(%d, %d, %d, %d, %d)", (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4i(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4i_defined
#endif
#ifndef glUniform4iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4iv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4iv_defined
#endif
#ifndef glUniformMatrix2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2fv_defined
#endif
#ifndef glUniformMatrix3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3fv_defined
#endif
#ifndef glUniformMatrix4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4fv_defined
#endif
#ifndef glUseProgram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUseProgram, (program), (GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glUseProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgram, "(%u)", (unsigned int)program)
    glatter_glUseProgram(program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUseProgram_defined
#endif
#ifndef glValidateProgram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glValidateProgram, (program), (GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glValidateProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgram, "(%u)", (unsigned int)program)
    glatter_glValidateProgram(program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glValidateProgram_defined
#endif
#ifndef glVertexAttrib1d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1d, (index, x), (GLuint index, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1d, "(%u, %f)", (unsigned int)index, (double)x)
    glatter_glVertexAttrib1d(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1d_defined
#endif
#ifndef glVertexAttrib1dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1dv_defined
#endif
#ifndef glVertexAttrib1f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1f, (index, x), (GLuint index, GLfloat x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1f_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1f, "(%u, %f)", (unsigned int)index, (float)x)
    glatter_glVertexAttrib1f(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1f_defined
#endif
#ifndef glVertexAttrib1fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1fv_defined
#endif
#ifndef glVertexAttrib1s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1s, (index, x), (GLuint index, GLshort x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1s_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1s, "(%u, %hi)", (unsigned int)index, (short)x)
    glatter_glVertexAttrib1s(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1s_defined
#endif
#ifndef glVertexAttrib1sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib1sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib1sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1sv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib1sv_defined
#endif
#ifndef glVertexAttrib2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2d, "(%u, %f, %f)", (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2d(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2d_defined
#endif
#ifndef glVertexAttrib2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2dv_defined
#endif
#ifndef glVertexAttrib2f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2f, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2f_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2f, "(%u, %f, %f)", (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2f(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2f_defined
#endif
#ifndef glVertexAttrib2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2fv_defined
#endif
#ifndef glVertexAttrib2s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2s, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2s_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2s, "(%u, %hi, %hi)", (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2s(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2s_defined
#endif
#ifndef glVertexAttrib2sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib2sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib2sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2sv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib2sv_defined
#endif
#ifndef glVertexAttrib3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3d, "(%u, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3d(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3d_defined
#endif
#ifndef glVertexAttrib3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3dv_defined
#endif
#ifndef glVertexAttrib3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3f, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3f, "(%u, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3f(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3f_defined
#endif
#ifndef glVertexAttrib3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3fv_defined
#endif
#ifndef glVertexAttrib3s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3s, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3s_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3s, "(%u, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3s(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3s_defined
#endif
#ifndef glVertexAttrib3sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib3sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib3sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3sv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib3sv_defined
#endif
#ifndef glVertexAttrib4Nbv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nbv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nbv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nbv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nbv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nbv_defined
#endif
#ifndef glVertexAttrib4Niv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Niv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Niv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Niv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Niv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Niv_defined
#endif
#ifndef glVertexAttrib4Nsv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nsv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nsv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nsv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nsv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nsv_defined
#endif
#ifndef glVertexAttrib4Nub_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nub, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nub_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nub, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4Nub(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nub_defined
#endif
#ifndef glVertexAttrib4Nubv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nubv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nubv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nubv_defined
#endif
#ifndef glVertexAttrib4Nuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nuiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nuiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nuiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nuiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nuiv_defined
#endif
#ifndef glVertexAttrib4Nusv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4Nusv, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4Nusv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nusv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nusv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4Nusv_defined
#endif
#ifndef glVertexAttrib4bv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4bv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4bv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4bv_defined
#endif
#ifndef glVertexAttrib4d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4d, "(%u, %f, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4d(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4d_defined
#endif
#ifndef glVertexAttrib4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4dv_defined
#endif
#ifndef glVertexAttrib4f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4f, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4f, "(%u, %f, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4f(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4f_defined
#endif
#ifndef glVertexAttrib4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4fv_defined
#endif
#ifndef glVertexAttrib4iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4iv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4iv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4iv_defined
#endif
#ifndef glVertexAttrib4s_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4s, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4s_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4s, "(%u, %hi, %hi, %hi, %hi)", (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4s(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4s_defined
#endif
#ifndef glVertexAttrib4sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4sv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4sv_defined
#endif
#ifndef glVertexAttrib4ubv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4ubv_defined
#endif
#ifndef glVertexAttrib4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4uiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4uiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4uiv_defined
#endif
#ifndef glVertexAttrib4usv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttrib4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttrib4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4usv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4usv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttrib4usv_defined
#endif
#ifndef glVertexAttribPointer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribPointer, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribPointer_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointer, "(%u, %d, %s, %u, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointer(index, size, type, normalized, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribPointer_defined
#endif
#endif // defined(GL_VERSION_2_0)
#if defined(GL_VERSION_2_1)
#ifndef glUniformMatrix2x3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2x3fv_defined
#endif
#ifndef glUniformMatrix2x4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2x4fv_defined
#endif
#ifndef glUniformMatrix3x2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3x2fv_defined
#endif
#ifndef glUniformMatrix3x4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3x4fv_defined
#endif
#ifndef glUniformMatrix4x2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4x2fv_defined
#endif
#ifndef glUniformMatrix4x3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3fv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3fv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4x3fv_defined
#endif
#endif // defined(GL_VERSION_2_1)
#if defined(GL_VERSION_3_0)
#ifndef glBeginConditionalRender_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginConditionalRender, (id, mode), (GLuint id, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBeginConditionalRender_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRender, "(%u, %s)", (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRender(id, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginConditionalRender_defined
#endif
#ifndef glBeginTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginTransformFeedback, (primitiveMode), (GLenum primitiveMode))
GLATTER_INLINE_OR_NOT void glatter_glBeginTransformFeedback_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedback, "(%s)", enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedback(primitiveMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginTransformFeedback_defined
#endif
#ifndef glBindBufferBase_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferBase, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferBase_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBase, "(%s, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBase(target, index, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferBase_defined
#endif
#ifndef glBindBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBufferRange, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glBindBufferRange_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRange, "(%s, %u, %u, %s, %s)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glBindBufferRange(target, index, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBufferRange_defined
#endif
#ifndef glBindFragDataLocation_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFragDataLocation, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glBindFragDataLocation_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocation, "(%u, %u, %p)", (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocation(program, color, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFragDataLocation_defined
#endif
#ifndef glBindFramebuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFramebuffer, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_INLINE_OR_NOT void glatter_glBindFramebuffer_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebuffer, "(%s, %u)", enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebuffer(target, framebuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFramebuffer_defined
#endif
#ifndef glBindRenderbuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindRenderbuffer, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glBindRenderbuffer_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbuffer, "(%s, %u)", enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbuffer(target, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindRenderbuffer_defined
#endif
#ifndef glBindVertexArray_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVertexArray, (array), (GLuint array))
GLATTER_INLINE_OR_NOT void glatter_glBindVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArray, "(%u)", (unsigned int)array)
    glatter_glBindVertexArray(array);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVertexArray_defined
#endif
#ifndef glBlitFramebuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlitFramebuffer, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glBlitFramebuffer_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebuffer, "(%d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlitFramebuffer_defined
#endif
#ifndef glCheckFramebufferStatus_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glCheckFramebufferStatus, (target), (GLenum target))
GLATTER_INLINE_OR_NOT GLenum glatter_glCheckFramebufferStatus_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatus, "(%s)", enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatus(target);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCheckFramebufferStatus_defined
#endif
#ifndef glClampColor_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClampColor, (target, clamp), (GLenum target, GLenum clamp))
GLATTER_INLINE_OR_NOT void glatter_glClampColor_debug(GLenum target, GLenum clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClampColor, "(%s, %s)", enum_to_string_GL(target), enum_to_string_GL(clamp))
    glatter_glClampColor(target, clamp);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClampColor_defined
#endif
#ifndef glClearBufferfi_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferfi, (buffer, drawbuffer, depth, stencil), (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferfi_debug(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfi, "(%s, %d, %f, %d)", enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearBufferfi(buffer, drawbuffer, depth, stencil);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferfi_defined
#endif
#ifndef glClearBufferfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferfv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferfv_debug(GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfv, "(%s, %d, %p)", enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferfv(buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferfv_defined
#endif
#ifndef glClearBufferiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferiv_debug(GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferiv, "(%s, %d, %p)", enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferiv(buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferiv_defined
#endif
#ifndef glClearBufferuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferuiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferuiv_debug(GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferuiv, "(%s, %d, %p)", enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferuiv(buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferuiv_defined
#endif
#ifndef glColorMaski_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorMaski, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_INLINE_OR_NOT void glatter_glColorMaski_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaski, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaski(index, r, g, b, a);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorMaski_defined
#endif
#ifndef glDeleteFramebuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteFramebuffers, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteFramebuffers_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffers, "(%d, %p)", (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffers(n, framebuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteFramebuffers_defined
#endif
#ifndef glDeleteRenderbuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteRenderbuffers, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteRenderbuffers_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffers, "(%d, %p)", (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffers(n, renderbuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteRenderbuffers_defined
#endif
#ifndef glDeleteVertexArrays_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteVertexArrays, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_INLINE_OR_NOT void glatter_glDeleteVertexArrays_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArrays, "(%d, %p)", (int)n, (void*)arrays)
    glatter_glDeleteVertexArrays(n, arrays);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteVertexArrays_defined
#endif
#ifndef glDisablei_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisablei, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisablei, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisablei(target, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisablei_defined
#endif
#ifndef glEnablei_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnablei, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnablei, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnablei(target, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnablei_defined
#endif
#ifndef glEndConditionalRender_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndConditionalRender, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndConditionalRender_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRender, "()")
    glatter_glEndConditionalRender();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndConditionalRender_defined
#endif
#ifndef glEndTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndTransformFeedback, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glEndTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedback, "()")
    glatter_glEndTransformFeedback();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndTransformFeedback_defined
#endif
#ifndef glFlushMappedBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushMappedBufferRange, (target, offset, length), (GLenum target, GLintptr offset, GLsizeiptr length))
GLATTER_INLINE_OR_NOT void glatter_glFlushMappedBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRange, "(%s, %s, %s)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(length))
    glatter_glFlushMappedBufferRange(target, offset, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushMappedBufferRange_defined
#endif
#ifndef glFramebufferRenderbuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferRenderbuffer, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferRenderbuffer_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbuffer, "(%s, %s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferRenderbuffer_defined
#endif
#ifndef glFramebufferTexture1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture1D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture1D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture1D, "(%s, %s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture1D(target, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture1D_defined
#endif
#ifndef glFramebufferTexture2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture2D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture2D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2D, "(%s, %s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2D(target, attachment, textarget, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture2D_defined
#endif
#ifndef glFramebufferTexture3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture3D, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture3D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3D, "(%s, %s, %s, %u, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture3D_defined
#endif
#ifndef glFramebufferTextureLayer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTextureLayer, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTextureLayer_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayer, "(%s, %s, %u, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayer(target, attachment, texture, level, layer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTextureLayer_defined
#endif
#ifndef glGenFramebuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_INLINE_OR_NOT void glatter_glGenFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffers, "(%d, %p)", (int)n, (void*)framebuffers)
    glatter_glGenFramebuffers(n, framebuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenFramebuffers_defined
#endif
#ifndef glGenRenderbuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_INLINE_OR_NOT void glatter_glGenRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffers, "(%d, %p)", (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffers(n, renderbuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenRenderbuffers_defined
#endif
#ifndef glGenVertexArrays_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_INLINE_OR_NOT void glatter_glGenVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArrays, "(%d, %p)", (int)n, (void*)arrays)
    glatter_glGenVertexArrays(n, arrays);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenVertexArrays_defined
#endif
#ifndef glGenerateMipmap_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenerateMipmap, (target), (GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glGenerateMipmap_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmap, "(%s)", enum_to_string_GL(target))
    glatter_glGenerateMipmap(target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenerateMipmap_defined
#endif
#ifndef glGetBooleani_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBooleani_v, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_INLINE_OR_NOT void glatter_glGetBooleani_v_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleani_v, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleani_v(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBooleani_v_defined
#endif
#ifndef glGetFragDataLocation_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetFragDataLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetFragDataLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocation, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocation(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetFragDataLocation_defined
#endif
#ifndef glGetFramebufferAttachmentParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferAttachmentParameteriv, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferAttachmentParameteriv_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameteriv, "(%s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferAttachmentParameteriv_defined
#endif
#ifndef glGetIntegeri_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetIntegeri_v, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_INLINE_OR_NOT void glatter_glGetIntegeri_v_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegeri_v, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegeri_v(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetIntegeri_v_defined
#endif
#ifndef glGetRenderbufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetRenderbufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetRenderbufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetRenderbufferParameteriv_defined
#endif
#ifndef glGetStringi_defined
GLATTER_FBLOCK(return, GL, GLAPI, const GLubyte *, APIENTRY, glGetStringi, (name, index), (GLenum name, GLuint index))
GLATTER_INLINE_OR_NOT const GLubyte * glatter_glGetStringi_debug(GLenum name, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStringi, "(%s, %u)", enum_to_string_GL(name), (unsigned int)index)
    const GLubyte * rval = glatter_glGetStringi(name, index);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetStringi_defined
#endif
#ifndef glGetTexParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterIiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIiv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIiv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterIiv_defined
#endif
#ifndef glGetTexParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTexParameterIuiv_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuiv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuiv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTexParameterIuiv_defined
#endif
#ifndef glGetTransformFeedbackVarying_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbackVarying, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbackVarying_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVarying, "(%u, %u, %d, %p, %p, %p, %p)", (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbackVarying_defined
#endif
#ifndef glGetUniformuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformuiv, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformuiv_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuiv, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuiv(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformuiv_defined
#endif
#ifndef glGetVertexAttribIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribIiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribIiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIiv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIiv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribIiv_defined
#endif
#ifndef glGetVertexAttribIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribIuiv, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribIuiv_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuiv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuiv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribIuiv_defined
#endif
#ifndef glIsEnabledi_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsEnabledi, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsEnabledi_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledi, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledi(target, index);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsEnabledi_defined
#endif
#ifndef glIsFramebuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsFramebuffer, (framebuffer), (GLuint framebuffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsFramebuffer_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebuffer, "(%u)", (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebuffer(framebuffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsFramebuffer_defined
#endif
#ifndef glIsRenderbuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsRenderbuffer, (renderbuffer), (GLuint renderbuffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsRenderbuffer_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbuffer, "(%u)", (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbuffer(renderbuffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsRenderbuffer_defined
#endif
#ifndef glIsVertexArray_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsVertexArray, (array), (GLuint array))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArray, "(%u)", (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArray(array);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsVertexArray_defined
#endif
#ifndef glMapBufferRange_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapBufferRange, (target, offset, length, access), (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_INLINE_OR_NOT void * glatter_glMapBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferRange, "(%s, %s, %s, %u)", enum_to_string_GL(target), GET_PRS(offset), GET_PRS(length), (unsigned int)access)
    void * rval = glatter_glMapBufferRange(target, offset, length, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapBufferRange_defined
#endif
#ifndef glRenderbufferStorage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorage, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorage_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorage, "(%s, %s, %d, %d)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorage(target, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorage_defined
#endif
#ifndef glRenderbufferStorageMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glRenderbufferStorageMultisample, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glRenderbufferStorageMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisample, "(%s, %d, %s, %d, %d)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glRenderbufferStorageMultisample_defined
#endif
#ifndef glTexParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterIiv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIiv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIiv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterIiv_defined
#endif
#ifndef glTexParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glTexParameterIuiv_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuiv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuiv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexParameterIuiv_defined
#endif
#ifndef glTransformFeedbackVaryings_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackVaryings, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackVaryings_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryings, "(%u, %d, %p, %s)", (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryings(program, count, varyings, bufferMode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackVaryings_defined
#endif
#ifndef glUniform1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1ui, (location, v0), (GLint location, GLuint v0))
GLATTER_INLINE_OR_NOT void glatter_glUniform1ui_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui, "(%d, %u)", (int)location, (unsigned int)v0)
    glatter_glUniform1ui(location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1ui_defined
#endif
#ifndef glUniform1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1uiv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1uiv_defined
#endif
#ifndef glUniform2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2ui, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_INLINE_OR_NOT void glatter_glUniform2ui_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui, "(%d, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2ui(location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2ui_defined
#endif
#ifndef glUniform2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2uiv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2uiv_defined
#endif
#ifndef glUniform3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3ui, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_INLINE_OR_NOT void glatter_glUniform3ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui, "(%d, %u, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3ui(location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3ui_defined
#endif
#ifndef glUniform3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3uiv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3uiv_defined
#endif
#ifndef glUniform4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4ui, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_INLINE_OR_NOT void glatter_glUniform4ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui, "(%d, %u, %u, %u, %u)", (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4ui(location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4ui_defined
#endif
#ifndef glUniform4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4uiv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4uiv_defined
#endif
#ifndef glVertexAttribI1i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1i, (index, x), (GLuint index, GLint x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1i_debug(GLuint index, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1i, "(%u, %d)", (unsigned int)index, (int)x)
    glatter_glVertexAttribI1i(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1i_defined
#endif
#ifndef glVertexAttribI1iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1iv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1iv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1iv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1iv_defined
#endif
#ifndef glVertexAttribI1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1ui, (index, x), (GLuint index, GLuint x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1ui_debug(GLuint index, GLuint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1ui, "(%u, %u)", (unsigned int)index, (unsigned int)x)
    glatter_glVertexAttribI1ui(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1ui_defined
#endif
#ifndef glVertexAttribI1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI1uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI1uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1uiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI1uiv_defined
#endif
#ifndef glVertexAttribI2i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2i, (index, x, y), (GLuint index, GLint x, GLint y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2i_debug(GLuint index, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2i, "(%u, %d, %d)", (unsigned int)index, (int)x, (int)y)
    glatter_glVertexAttribI2i(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2i_defined
#endif
#ifndef glVertexAttribI2iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2iv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2iv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2iv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2iv_defined
#endif
#ifndef glVertexAttribI2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2ui, (index, x, y), (GLuint index, GLuint x, GLuint y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2ui_debug(GLuint index, GLuint x, GLuint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2ui, "(%u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y)
    glatter_glVertexAttribI2ui(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2ui_defined
#endif
#ifndef glVertexAttribI2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI2uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI2uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2uiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI2uiv_defined
#endif
#ifndef glVertexAttribI3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3i, (index, x, y, z), (GLuint index, GLint x, GLint y, GLint z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3i_debug(GLuint index, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3i, "(%u, %d, %d, %d)", (unsigned int)index, (int)x, (int)y, (int)z)
    glatter_glVertexAttribI3i(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3i_defined
#endif
#ifndef glVertexAttribI3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3iv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3iv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3iv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3iv_defined
#endif
#ifndef glVertexAttribI3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3ui, (index, x, y, z), (GLuint index, GLuint x, GLuint y, GLuint z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3ui, "(%u, %u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z)
    glatter_glVertexAttribI3ui(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3ui_defined
#endif
#ifndef glVertexAttribI3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI3uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI3uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3uiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI3uiv_defined
#endif
#ifndef glVertexAttribI4bv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4bv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4bv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4bv_defined
#endif
#ifndef glVertexAttribI4i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4i, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4i_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4i, "(%u, %d, %d, %d, %d)", (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4i(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4i_defined
#endif
#ifndef glVertexAttribI4iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4iv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4iv_defined
#endif
#ifndef glVertexAttribI4sv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4sv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4sv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4sv_defined
#endif
#ifndef glVertexAttribI4ubv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ubv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ubv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4ubv_defined
#endif
#ifndef glVertexAttribI4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4ui, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ui, "(%u, %u, %u, %u, %u)", (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4ui(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4ui_defined
#endif
#ifndef glVertexAttribI4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uiv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4uiv_defined
#endif
#ifndef glVertexAttribI4usv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribI4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribI4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4usv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4usv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribI4usv_defined
#endif
#ifndef glVertexAttribIPointer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribIPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribIPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointer, "(%u, %d, %s, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointer(index, size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribIPointer_defined
#endif
#endif // defined(GL_VERSION_3_0)
#if defined(GL_VERSION_3_1)
#ifndef glCopyBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyBufferSubData, (readTarget, writeTarget, readOffset, writeOffset, size), (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glCopyBufferSubData_debug(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyBufferSubData, "(%s, %s, %s, %s, %s)", enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyBufferSubData_defined
#endif
#ifndef glDrawArraysInstanced_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysInstanced, (mode, first, count, instancecount), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysInstanced_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstanced, "(%s, %d, %d, %d)", enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount)
    glatter_glDrawArraysInstanced(mode, first, count, instancecount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysInstanced_defined
#endif
#ifndef glDrawElementsInstanced_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstanced, (mode, count, type, indices, instancecount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstanced_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstanced, "(%s, %d, %s, %p, %d)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount)
    glatter_glDrawElementsInstanced(mode, count, type, indices, instancecount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstanced_defined
#endif
#ifndef glGetActiveUniformBlockName_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniformBlockName, (program, uniformBlockIndex, bufSize, length, uniformBlockName), (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniformBlockName_debug(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockName, "(%u, %u, %d, %p, %p)", (unsigned int)program, (unsigned int)uniformBlockIndex, (int)bufSize, (void*)length, (void*)uniformBlockName)
    glatter_glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniformBlockName_defined
#endif
#ifndef glGetActiveUniformBlockiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniformBlockiv, (program, uniformBlockIndex, pname, params), (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniformBlockiv_debug(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockiv, "(%u, %u, %s, %p)", (unsigned int)program, (unsigned int)uniformBlockIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniformBlockiv_defined
#endif
#ifndef glGetActiveUniformName_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniformName, (program, uniformIndex, bufSize, length, uniformName), (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniformName_debug(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformName, "(%u, %u, %d, %p, %p)", (unsigned int)program, (unsigned int)uniformIndex, (int)bufSize, (void*)length, (void*)uniformName)
    glatter_glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniformName_defined
#endif
#ifndef glGetActiveUniformsiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveUniformsiv, (program, uniformCount, uniformIndices, pname, params), (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveUniformsiv_debug(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformsiv, "(%u, %d, %p, %s, %p)", (unsigned int)program, (int)uniformCount, (void*)uniformIndices, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveUniformsiv_defined
#endif
#ifndef glGetUniformBlockIndex_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetUniformBlockIndex, (program, uniformBlockName), (GLuint program, const GLchar *uniformBlockName))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetUniformBlockIndex_debug(GLuint program, const GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBlockIndex, "(%u, %p)", (unsigned int)program, (void*)uniformBlockName)
    GLuint rval = glatter_glGetUniformBlockIndex(program, uniformBlockName);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetUniformBlockIndex_defined
#endif
#ifndef glGetUniformIndices_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformIndices, (program, uniformCount, uniformNames, uniformIndices), (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformIndices_debug(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformIndices, "(%u, %d, %p, %p)", (unsigned int)program, (int)uniformCount, (void*)uniformNames, (void*)uniformIndices)
    glatter_glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformIndices_defined
#endif
#ifndef glPrimitiveRestartIndex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPrimitiveRestartIndex, (index), (GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glPrimitiveRestartIndex_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartIndex, "(%u)", (unsigned int)index)
    glatter_glPrimitiveRestartIndex(index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPrimitiveRestartIndex_defined
#endif
#ifndef glTexBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBuffer, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTexBuffer_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBuffer, "(%s, %s, %u)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBuffer(target, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBuffer_defined
#endif
#ifndef glUniformBlockBinding_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformBlockBinding, (program, uniformBlockIndex, uniformBlockBinding), (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding))
GLATTER_INLINE_OR_NOT void glatter_glUniformBlockBinding_debug(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBlockBinding, "(%u, %u, %u)", (unsigned int)program, (unsigned int)uniformBlockIndex, (unsigned int)uniformBlockBinding)
    glatter_glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformBlockBinding_defined
#endif
#endif // defined(GL_VERSION_3_1)
#if defined(GL_VERSION_3_2)
#ifndef glClientWaitSync_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glClientWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_INLINE_OR_NOT GLenum glatter_glClientWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSync, "(%p, %u, %s)", (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    GLenum rval = glatter_glClientWaitSync(sync, flags, timeout);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glClientWaitSync_defined
#endif
#ifndef glDeleteSync_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteSync, (sync), (GLsync sync))
GLATTER_INLINE_OR_NOT void glatter_glDeleteSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSync, "(%p)", (void*)sync)
    glatter_glDeleteSync(sync);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteSync_defined
#endif
#ifndef glDrawElementsBaseVertex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsBaseVertex, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertex, "(%s, %d, %s, %p, %d)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsBaseVertex_defined
#endif
#ifndef glDrawElementsInstancedBaseVertex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstancedBaseVertex, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstancedBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertex, "(%s, %d, %s, %p, %d, %d)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstancedBaseVertex_defined
#endif
#ifndef glDrawRangeElementsBaseVertex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawRangeElementsBaseVertex, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_INLINE_OR_NOT void glatter_glDrawRangeElementsBaseVertex_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertex, "(%s, %u, %u, %d, %s, %p, %d)", enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawRangeElementsBaseVertex_defined
#endif
#ifndef glFenceSync_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLsync, APIENTRY, glFenceSync, (condition, flags), (GLenum condition, GLbitfield flags))
GLATTER_INLINE_OR_NOT GLsync glatter_glFenceSync_debug(GLenum condition, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFenceSync, "(%s, %u)", enum_to_string_GL(condition), (unsigned int)flags)
    GLsync rval = glatter_glFenceSync(condition, flags);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glFenceSync_defined
#endif
#ifndef glFramebufferTexture_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferTexture, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferTexture_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture, "(%s, %s, %u, %d)", enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture(target, attachment, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferTexture_defined
#endif
#ifndef glGetBufferParameteri64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetBufferParameteri64v, (target, pname, params), (GLenum target, GLenum pname, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetBufferParameteri64v_debug(GLenum target, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteri64v, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteri64v(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetBufferParameteri64v_defined
#endif
#ifndef glGetInteger64i_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInteger64i_v, (target, index, data), (GLenum target, GLuint index, GLint64 *data))
GLATTER_INLINE_OR_NOT void glatter_glGetInteger64i_v_debug(GLenum target, GLuint index, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64i_v, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetInteger64i_v(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInteger64i_v_defined
#endif
#ifndef glGetInteger64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInteger64v, (pname, data), (GLenum pname, GLint64 *data))
GLATTER_INLINE_OR_NOT void glatter_glGetInteger64v_debug(GLenum pname, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64v, "(%s, %p)", enum_to_string_GL(pname), (void*)data)
    glatter_glGetInteger64v(pname, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInteger64v_defined
#endif
#ifndef glGetMultisamplefv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetMultisamplefv, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_INLINE_OR_NOT void glatter_glGetMultisamplefv_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefv, "(%s, %u, %p)", enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefv(pname, index, val);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetMultisamplefv_defined
#endif
#ifndef glGetSynciv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSynciv, (sync, pname, count, length, values), (GLsync sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values))
GLATTER_INLINE_OR_NOT void glatter_glGetSynciv_debug(GLsync sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSynciv, "(%p, %s, %d, %p, %p)", (void*)sync, enum_to_string_GL(pname), (int)count, (void*)length, (void*)values)
    glatter_glGetSynciv(sync, pname, count, length, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSynciv_defined
#endif
#ifndef glIsSync_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsSync, (sync), (GLsync sync))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSync, "(%p)", (void*)sync)
    GLboolean rval = glatter_glIsSync(sync);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsSync_defined
#endif
#ifndef glMultiDrawElementsBaseVertex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsBaseVertex, (mode, count, type, indices, drawcount, basevertex), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsBaseVertex_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsBaseVertex, "(%s, %p, %s, %p, %d, %p)", enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount, (void*)basevertex)
    glatter_glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsBaseVertex_defined
#endif
#ifndef glProvokingVertex_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProvokingVertex, (mode), (GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glProvokingVertex_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProvokingVertex, "(%s)", enum_to_string_GL(mode))
    glatter_glProvokingVertex(mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProvokingVertex_defined
#endif
#ifndef glSampleMaski_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSampleMaski, (maskNumber, mask), (GLuint maskNumber, GLbitfield mask))
GLATTER_INLINE_OR_NOT void glatter_glSampleMaski_debug(GLuint maskNumber, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaski, "(%u, %u)", (unsigned int)maskNumber, (unsigned int)mask)
    glatter_glSampleMaski(maskNumber, mask);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSampleMaski_defined
#endif
#ifndef glTexImage2DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTexImage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2DMultisample, "(%s, %d, %s, %d, %d, %u)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage2DMultisample_defined
#endif
#ifndef glTexImage3DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexImage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTexImage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DMultisample, "(%s, %d, %s, %d, %d, %d, %u)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexImage3DMultisample_defined
#endif
#ifndef glWaitSync_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_INLINE_OR_NOT void glatter_glWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSync, "(%p, %u, %s)", (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    glatter_glWaitSync(sync, flags, timeout);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glWaitSync_defined
#endif
#endif // defined(GL_VERSION_3_2)
#if defined(GL_VERSION_3_3)
#ifndef glBindFragDataLocationIndexed_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindFragDataLocationIndexed, (program, colorNumber, index, name), (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glBindFragDataLocationIndexed_debug(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationIndexed, "(%u, %u, %u, %p)", (unsigned int)program, (unsigned int)colorNumber, (unsigned int)index, (void*)name)
    glatter_glBindFragDataLocationIndexed(program, colorNumber, index, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindFragDataLocationIndexed_defined
#endif
#ifndef glBindSampler_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindSampler, (unit, sampler), (GLuint unit, GLuint sampler))
GLATTER_INLINE_OR_NOT void glatter_glBindSampler_debug(GLuint unit, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSampler, "(%u, %u)", (unsigned int)unit, (unsigned int)sampler)
    glatter_glBindSampler(unit, sampler);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindSampler_defined
#endif
#ifndef glColorP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorP3ui, (type, color), (GLenum type, GLuint color))
GLATTER_INLINE_OR_NOT void glatter_glColorP3ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP3ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)color)
    glatter_glColorP3ui(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorP3ui_defined
#endif
#ifndef glColorP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorP3uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_INLINE_OR_NOT void glatter_glColorP3uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP3uiv, "(%s, %p)", enum_to_string_GL(type), (void*)color)
    glatter_glColorP3uiv(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorP3uiv_defined
#endif
#ifndef glColorP4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorP4ui, (type, color), (GLenum type, GLuint color))
GLATTER_INLINE_OR_NOT void glatter_glColorP4ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP4ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)color)
    glatter_glColorP4ui(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorP4ui_defined
#endif
#ifndef glColorP4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glColorP4uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_INLINE_OR_NOT void glatter_glColorP4uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP4uiv, "(%s, %p)", enum_to_string_GL(type), (void*)color)
    glatter_glColorP4uiv(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glColorP4uiv_defined
#endif
#ifndef glDeleteSamplers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteSamplers, (count, samplers), (GLsizei count, const GLuint *samplers))
GLATTER_INLINE_OR_NOT void glatter_glDeleteSamplers_debug(GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSamplers, "(%d, %p)", (int)count, (void*)samplers)
    glatter_glDeleteSamplers(count, samplers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteSamplers_defined
#endif
#ifndef glGenSamplers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenSamplers, (count, samplers), (GLsizei count, GLuint *samplers))
GLATTER_INLINE_OR_NOT void glatter_glGenSamplers_debug(GLsizei count, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSamplers, "(%d, %p)", (int)count, (void*)samplers)
    glatter_glGenSamplers(count, samplers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenSamplers_defined
#endif
#ifndef glGetFragDataIndex_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetFragDataIndex, (program, name), (GLuint program, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetFragDataIndex_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataIndex, "(%u, %p)", (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataIndex(program, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetFragDataIndex_defined
#endif
#ifndef glGetQueryObjecti64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjecti64v, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjecti64v_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64v, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64v(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjecti64v_defined
#endif
#ifndef glGetQueryObjectui64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryObjectui64v, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryObjectui64v_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64v, "(%u, %s, %p)", (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64v(id, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryObjectui64v_defined
#endif
#ifndef glGetSamplerParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSamplerParameterIiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSamplerParameterIiv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIiv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIiv(sampler, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSamplerParameterIiv_defined
#endif
#ifndef glGetSamplerParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSamplerParameterIuiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuiv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuiv(sampler, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSamplerParameterIuiv_defined
#endif
#ifndef glGetSamplerParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSamplerParameterfv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSamplerParameterfv_debug(GLuint sampler, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterfv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterfv(sampler, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSamplerParameterfv_defined
#endif
#ifndef glGetSamplerParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetSamplerParameteriv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetSamplerParameteriv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameteriv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameteriv(sampler, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetSamplerParameteriv_defined
#endif
#ifndef glIsSampler_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsSampler, (sampler), (GLuint sampler))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsSampler_debug(GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSampler, "(%u)", (unsigned int)sampler)
    GLboolean rval = glatter_glIsSampler(sampler);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsSampler_defined
#endif
#ifndef glMultiTexCoordP1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP1ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP1ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP1ui, "(%s, %s, %u)", enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP1ui(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP1ui_defined
#endif
#ifndef glMultiTexCoordP1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP1uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP1uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP1uiv, "(%s, %s, %p)", enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP1uiv(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP1uiv_defined
#endif
#ifndef glMultiTexCoordP2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP2ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP2ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP2ui, "(%s, %s, %u)", enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP2ui(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP2ui_defined
#endif
#ifndef glMultiTexCoordP2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP2uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP2uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP2uiv, "(%s, %s, %p)", enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP2uiv(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP2uiv_defined
#endif
#ifndef glMultiTexCoordP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP3ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP3ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP3ui, "(%s, %s, %u)", enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP3ui(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP3ui_defined
#endif
#ifndef glMultiTexCoordP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP3uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP3uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP3uiv, "(%s, %s, %p)", enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP3uiv(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP3uiv_defined
#endif
#ifndef glMultiTexCoordP4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP4ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP4ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP4ui, "(%s, %s, %u)", enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP4ui(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP4ui_defined
#endif
#ifndef glMultiTexCoordP4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiTexCoordP4uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glMultiTexCoordP4uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP4uiv, "(%s, %s, %p)", enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP4uiv(texture, type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiTexCoordP4uiv_defined
#endif
#ifndef glNormalP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalP3ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalP3ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalP3ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)coords)
    glatter_glNormalP3ui(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalP3ui_defined
#endif
#ifndef glNormalP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNormalP3uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glNormalP3uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalP3uiv, "(%s, %p)", enum_to_string_GL(type), (void*)coords)
    glatter_glNormalP3uiv(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNormalP3uiv_defined
#endif
#ifndef glQueryCounter_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glQueryCounter, (id, target), (GLuint id, GLenum target))
GLATTER_INLINE_OR_NOT void glatter_glQueryCounter_debug(GLuint id, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryCounter, "(%u, %s)", (unsigned int)id, enum_to_string_GL(target))
    glatter_glQueryCounter(id, target);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glQueryCounter_defined
#endif
#ifndef glSamplerParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameterIiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameterIiv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIiv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIiv(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameterIiv_defined
#endif
#ifndef glSamplerParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameterIuiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuiv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuiv(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameterIuiv_defined
#endif
#ifndef glSamplerParameterf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameterf, (sampler, pname, param), (GLuint sampler, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameterf_debug(GLuint sampler, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterf, "(%u, %s, %f)", (unsigned int)sampler, enum_to_string_GL(pname), (float)param)
    glatter_glSamplerParameterf(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameterf_defined
#endif
#ifndef glSamplerParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameterfv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLfloat *param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameterfv_debug(GLuint sampler, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterfv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterfv(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameterfv_defined
#endif
#ifndef glSamplerParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameteri, (sampler, pname, param), (GLuint sampler, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameteri_debug(GLuint sampler, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteri, "(%u, %s, %d)", (unsigned int)sampler, enum_to_string_GL(pname), (int)param)
    glatter_glSamplerParameteri(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameteri_defined
#endif
#ifndef glSamplerParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSamplerParameteriv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glSamplerParameteriv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteriv, "(%u, %s, %p)", (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameteriv(sampler, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSamplerParameteriv_defined
#endif
#ifndef glSecondaryColorP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorP3ui, (type, color), (GLenum type, GLuint color))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorP3ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorP3ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)color)
    glatter_glSecondaryColorP3ui(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorP3ui_defined
#endif
#ifndef glSecondaryColorP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSecondaryColorP3uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_INLINE_OR_NOT void glatter_glSecondaryColorP3uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorP3uiv, "(%s, %p)", enum_to_string_GL(type), (void*)color)
    glatter_glSecondaryColorP3uiv(type, color);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSecondaryColorP3uiv_defined
#endif
#ifndef glTexCoordP1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP1ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP1ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP1ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP1ui(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP1ui_defined
#endif
#ifndef glTexCoordP1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP1uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP1uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP1uiv, "(%s, %p)", enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP1uiv(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP1uiv_defined
#endif
#ifndef glTexCoordP2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP2ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP2ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP2ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP2ui(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP2ui_defined
#endif
#ifndef glTexCoordP2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP2uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP2uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP2uiv, "(%s, %p)", enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP2uiv(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP2uiv_defined
#endif
#ifndef glTexCoordP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP3ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP3ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP3ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP3ui(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP3ui_defined
#endif
#ifndef glTexCoordP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP3uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP3uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP3uiv, "(%s, %p)", enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP3uiv(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP3uiv_defined
#endif
#ifndef glTexCoordP4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP4ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP4ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP4ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP4ui(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP4ui_defined
#endif
#ifndef glTexCoordP4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexCoordP4uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_INLINE_OR_NOT void glatter_glTexCoordP4uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP4uiv, "(%s, %p)", enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP4uiv(type, coords);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexCoordP4uiv_defined
#endif
#ifndef glVertexAttribDivisor_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribDivisor, (index, divisor), (GLuint index, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribDivisor_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisor, "(%u, %u)", (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisor(index, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribDivisor_defined
#endif
#ifndef glVertexAttribP1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP1ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP1ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1ui, "(%u, %s, %u, %u)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP1ui(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP1ui_defined
#endif
#ifndef glVertexAttribP1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP1uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP1uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1uiv, "(%u, %s, %u, %p)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP1uiv(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP1uiv_defined
#endif
#ifndef glVertexAttribP2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP2ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP2ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2ui, "(%u, %s, %u, %u)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP2ui(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP2ui_defined
#endif
#ifndef glVertexAttribP2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP2uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP2uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2uiv, "(%u, %s, %u, %p)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP2uiv(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP2uiv_defined
#endif
#ifndef glVertexAttribP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP3ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP3ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3ui, "(%u, %s, %u, %u)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP3ui(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP3ui_defined
#endif
#ifndef glVertexAttribP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP3uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP3uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3uiv, "(%u, %s, %u, %p)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP3uiv(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP3uiv_defined
#endif
#ifndef glVertexAttribP4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP4ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP4ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4ui, "(%u, %s, %u, %u)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP4ui(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP4ui_defined
#endif
#ifndef glVertexAttribP4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribP4uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribP4uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4uiv, "(%u, %s, %u, %p)", (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP4uiv(index, type, normalized, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribP4uiv_defined
#endif
#ifndef glVertexP2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP2ui, (type, value), (GLenum type, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP2ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP2ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP2ui(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP2ui_defined
#endif
#ifndef glVertexP2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP2uiv, (type, value), (GLenum type, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP2uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP2uiv, "(%s, %p)", enum_to_string_GL(type), (void*)value)
    glatter_glVertexP2uiv(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP2uiv_defined
#endif
#ifndef glVertexP3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP3ui, (type, value), (GLenum type, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP3ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP3ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP3ui(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP3ui_defined
#endif
#ifndef glVertexP3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP3uiv, (type, value), (GLenum type, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP3uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP3uiv, "(%s, %p)", enum_to_string_GL(type), (void*)value)
    glatter_glVertexP3uiv(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP3uiv_defined
#endif
#ifndef glVertexP4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP4ui, (type, value), (GLenum type, GLuint value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP4ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP4ui, "(%s, %u)", enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP4ui(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP4ui_defined
#endif
#ifndef glVertexP4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexP4uiv, (type, value), (GLenum type, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glVertexP4uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP4uiv, "(%s, %p)", enum_to_string_GL(type), (void*)value)
    glatter_glVertexP4uiv(type, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexP4uiv_defined
#endif
#endif // defined(GL_VERSION_3_3)
#if defined(GL_VERSION_4_0)
#ifndef glBeginQueryIndexed_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBeginQueryIndexed, (target, index, id), (GLenum target, GLuint index, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBeginQueryIndexed_debug(GLenum target, GLuint index, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryIndexed, "(%s, %u, %u)", enum_to_string_GL(target), (unsigned int)index, (unsigned int)id)
    glatter_glBeginQueryIndexed(target, index, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBeginQueryIndexed_defined
#endif
#ifndef glBindTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindTransformFeedback, (target, id), (GLenum target, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glBindTransformFeedback_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedback, "(%s, %u)", enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedback(target, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindTransformFeedback_defined
#endif
#ifndef glBlendEquationSeparatei_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationSeparatei, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationSeparatei_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparatei, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationSeparatei_defined
#endif
#ifndef glBlendEquationi_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendEquationi, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_INLINE_OR_NOT void glatter_glBlendEquationi_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationi, "(%u, %s)", (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationi(buf, mode);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendEquationi_defined
#endif
#ifndef glBlendFuncSeparatei_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFuncSeparatei, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_INLINE_OR_NOT void glatter_glBlendFuncSeparatei_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparatei, "(%u, %s, %s, %s, %s)", (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFuncSeparatei_defined
#endif
#ifndef glBlendFunci_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlendFunci, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_INLINE_OR_NOT void glatter_glBlendFunci_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunci, "(%u, %s, %s)", (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunci(buf, src, dst);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlendFunci_defined
#endif
#ifndef glDeleteTransformFeedbacks_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteTransformFeedbacks, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glDeleteTransformFeedbacks_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacks, "(%d, %p)", (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacks(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteTransformFeedbacks_defined
#endif
#ifndef glDrawArraysIndirect_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysIndirect, (mode, indirect), (GLenum mode, const void *indirect))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysIndirect_debug(GLenum mode, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysIndirect, "(%s, %p)", enum_to_string_GL(mode), (void*)indirect)
    glatter_glDrawArraysIndirect(mode, indirect);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysIndirect_defined
#endif
#ifndef glDrawElementsIndirect_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsIndirect, (mode, type, indirect), (GLenum mode, GLenum type, const void *indirect))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsIndirect, "(%s, %s, %p)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect)
    glatter_glDrawElementsIndirect(mode, type, indirect);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsIndirect_defined
#endif
#ifndef glDrawTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTransformFeedback, (mode, id), (GLenum mode, GLuint id))
GLATTER_INLINE_OR_NOT void glatter_glDrawTransformFeedback_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedback, "(%s, %u)", enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedback(mode, id);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTransformFeedback_defined
#endif
#ifndef glDrawTransformFeedbackStream_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTransformFeedbackStream, (mode, id, stream), (GLenum mode, GLuint id, GLuint stream))
GLATTER_INLINE_OR_NOT void glatter_glDrawTransformFeedbackStream_debug(GLenum mode, GLuint id, GLuint stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStream, "(%s, %u, %u)", enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream)
    glatter_glDrawTransformFeedbackStream(mode, id, stream);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTransformFeedbackStream_defined
#endif
#ifndef glEndQueryIndexed_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEndQueryIndexed, (target, index), (GLenum target, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEndQueryIndexed_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryIndexed, "(%s, %u)", enum_to_string_GL(target), (unsigned int)index)
    glatter_glEndQueryIndexed(target, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEndQueryIndexed_defined
#endif
#ifndef glGenTransformFeedbacks_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glGenTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacks, "(%d, %p)", (int)n, (void*)ids)
    glatter_glGenTransformFeedbacks(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenTransformFeedbacks_defined
#endif
#ifndef glGetActiveSubroutineName_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveSubroutineName, (program, shadertype, index, bufSize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveSubroutineName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineName, "(%u, %s, %u, %d, %p, %p)", (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineName(program, shadertype, index, bufSize, length, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveSubroutineName_defined
#endif
#ifndef glGetActiveSubroutineUniformName_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveSubroutineUniformName, (program, shadertype, index, bufSize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveSubroutineUniformName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformName, "(%u, %s, %u, %d, %p, %p)", (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineUniformName(program, shadertype, index, bufSize, length, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveSubroutineUniformName_defined
#endif
#ifndef glGetActiveSubroutineUniformiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveSubroutineUniformiv, (program, shadertype, index, pname, values), (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveSubroutineUniformiv_debug(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformiv, "(%u, %s, %u, %s, %p)", (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, enum_to_string_GL(pname), (void*)values)
    glatter_glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveSubroutineUniformiv_defined
#endif
#ifndef glGetProgramStageiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramStageiv, (program, shadertype, pname, values), (GLuint program, GLenum shadertype, GLenum pname, GLint *values))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramStageiv_debug(GLuint program, GLenum shadertype, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStageiv, "(%u, %s, %s, %p)", (unsigned int)program, enum_to_string_GL(shadertype), enum_to_string_GL(pname), (void*)values)
    glatter_glGetProgramStageiv(program, shadertype, pname, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramStageiv_defined
#endif
#ifndef glGetQueryIndexediv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryIndexediv, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryIndexediv_debug(GLenum target, GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryIndexediv, "(%s, %u, %s, %p)", enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryIndexediv(target, index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryIndexediv_defined
#endif
#ifndef glGetSubroutineIndex_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetSubroutineIndex, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetSubroutineIndex_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineIndex, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLuint rval = glatter_glGetSubroutineIndex(program, shadertype, name);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetSubroutineIndex_defined
#endif
#ifndef glGetSubroutineUniformLocation_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetSubroutineUniformLocation, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetSubroutineUniformLocation_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineUniformLocation, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLint rval = glatter_glGetSubroutineUniformLocation(program, shadertype, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetSubroutineUniformLocation_defined
#endif
#ifndef glGetUniformSubroutineuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformSubroutineuiv, (shadertype, location, params), (GLenum shadertype, GLint location, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformSubroutineuiv_debug(GLenum shadertype, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformSubroutineuiv, "(%s, %d, %p)", enum_to_string_GL(shadertype), (int)location, (void*)params)
    glatter_glGetUniformSubroutineuiv(shadertype, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformSubroutineuiv_defined
#endif
#ifndef glGetUniformdv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetUniformdv, (program, location, params), (GLuint program, GLint location, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetUniformdv_debug(GLuint program, GLint location, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformdv, "(%u, %d, %p)", (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformdv(program, location, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetUniformdv_defined
#endif
#ifndef glIsTransformFeedback_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsTransformFeedback, (id), (GLuint id))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsTransformFeedback_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedback, "(%u)", (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedback(id);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsTransformFeedback_defined
#endif
#ifndef glMinSampleShading_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMinSampleShading, (value), (GLfloat value))
GLATTER_INLINE_OR_NOT void glatter_glMinSampleShading_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShading, "(%f)", (float)value)
    glatter_glMinSampleShading(value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMinSampleShading_defined
#endif
#ifndef glPatchParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPatchParameterfv, (pname, values), (GLenum pname, const GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glPatchParameterfv_debug(GLenum pname, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameterfv, "(%s, %p)", enum_to_string_GL(pname), (void*)values)
    glatter_glPatchParameterfv(pname, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPatchParameterfv_defined
#endif
#ifndef glPatchParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPatchParameteri, (pname, value), (GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glPatchParameteri_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteri, "(%s, %d)", enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteri(pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPatchParameteri_defined
#endif
#ifndef glPauseTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPauseTransformFeedback, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glPauseTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedback, "()")
    glatter_glPauseTransformFeedback();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPauseTransformFeedback_defined
#endif
#ifndef glResumeTransformFeedback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glResumeTransformFeedback, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glResumeTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedback, "()")
    glatter_glResumeTransformFeedback();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glResumeTransformFeedback_defined
#endif
#ifndef glUniform1d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1d, (location, x), (GLint location, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glUniform1d_debug(GLint location, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1d, "(%d, %f)", (int)location, (double)x)
    glatter_glUniform1d(location, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1d_defined
#endif
#ifndef glUniform1dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform1dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform1dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1dv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform1dv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform1dv_defined
#endif
#ifndef glUniform2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2d, (location, x, y), (GLint location, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glUniform2d_debug(GLint location, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2d, "(%d, %f, %f)", (int)location, (double)x, (double)y)
    glatter_glUniform2d(location, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2d_defined
#endif
#ifndef glUniform2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform2dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform2dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2dv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform2dv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform2dv_defined
#endif
#ifndef glUniform3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3d, (location, x, y, z), (GLint location, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glUniform3d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3d, "(%d, %f, %f, %f)", (int)location, (double)x, (double)y, (double)z)
    glatter_glUniform3d(location, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3d_defined
#endif
#ifndef glUniform3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform3dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform3dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3dv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform3dv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform3dv_defined
#endif
#ifndef glUniform4d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4d, (location, x, y, z, w), (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glUniform4d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4d, "(%d, %f, %f, %f, %f)", (int)location, (double)x, (double)y, (double)z, (double)w)
    glatter_glUniform4d(location, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4d_defined
#endif
#ifndef glUniform4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniform4dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniform4dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4dv, "(%d, %d, %p)", (int)location, (int)count, (void*)value)
    glatter_glUniform4dv(location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniform4dv_defined
#endif
#ifndef glUniformMatrix2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2dv_defined
#endif
#ifndef glUniformMatrix2x3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2x3dv_defined
#endif
#ifndef glUniformMatrix2x4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix2x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix2x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix2x4dv_defined
#endif
#ifndef glUniformMatrix3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3dv_defined
#endif
#ifndef glUniformMatrix3x2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3x2dv_defined
#endif
#ifndef glUniformMatrix3x4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix3x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix3x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix3x4dv_defined
#endif
#ifndef glUniformMatrix4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4dv_defined
#endif
#ifndef glUniformMatrix4x2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4x2dv_defined
#endif
#ifndef glUniformMatrix4x3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformMatrix4x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glUniformMatrix4x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3dv, "(%d, %d, %u, %p)", (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3dv(location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformMatrix4x3dv_defined
#endif
#ifndef glUniformSubroutinesuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUniformSubroutinesuiv, (shadertype, count, indices), (GLenum shadertype, GLsizei count, const GLuint *indices))
GLATTER_INLINE_OR_NOT void glatter_glUniformSubroutinesuiv_debug(GLenum shadertype, GLsizei count, const GLuint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformSubroutinesuiv, "(%s, %d, %p)", enum_to_string_GL(shadertype), (int)count, (void*)indices)
    glatter_glUniformSubroutinesuiv(shadertype, count, indices);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUniformSubroutinesuiv_defined
#endif
#endif // defined(GL_VERSION_4_0)
#if defined(GL_VERSION_4_1)
#ifndef glActiveShaderProgram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glActiveShaderProgram, (pipeline, program), (GLuint pipeline, GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glActiveShaderProgram_debug(GLuint pipeline, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveShaderProgram, "(%u, %u)", (unsigned int)pipeline, (unsigned int)program)
    glatter_glActiveShaderProgram(pipeline, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glActiveShaderProgram_defined
#endif
#ifndef glBindProgramPipeline_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_INLINE_OR_NOT void glatter_glBindProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramPipeline, "(%u)", (unsigned int)pipeline)
    glatter_glBindProgramPipeline(pipeline);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindProgramPipeline_defined
#endif
#ifndef glClearDepthf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearDepthf, (d), (GLfloat d))
GLATTER_INLINE_OR_NOT void glatter_glClearDepthf_debug(GLfloat d, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthf, "(%f)", (float)d)
    glatter_glClearDepthf(d);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearDepthf_defined
#endif
#ifndef glCreateShaderProgramv_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glCreateShaderProgramv, (type, count, strings), (GLenum type, GLsizei count, const GLchar *const*strings))
GLATTER_INLINE_OR_NOT GLuint glatter_glCreateShaderProgramv_debug(GLenum type, GLsizei count, const GLchar *const*strings, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramv, "(%s, %d, %p)", enum_to_string_GL(type), (int)count, (void*)strings)
    GLuint rval = glatter_glCreateShaderProgramv(type, count, strings);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCreateShaderProgramv_defined
#endif
#ifndef glDeleteProgramPipelines_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDeleteProgramPipelines, (n, pipelines), (GLsizei n, const GLuint *pipelines))
GLATTER_INLINE_OR_NOT void glatter_glDeleteProgramPipelines_debug(GLsizei n, const GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramPipelines, "(%d, %p)", (int)n, (void*)pipelines)
    glatter_glDeleteProgramPipelines(n, pipelines);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDeleteProgramPipelines_defined
#endif
#ifndef glDepthRangeArrayv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangeArrayv, (first, count, v), (GLuint first, GLsizei count, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangeArrayv_debug(GLuint first, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArrayv, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArrayv(first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangeArrayv_defined
#endif
#ifndef glDepthRangeIndexed_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangeIndexed, (index, n, f), (GLuint index, GLdouble n, GLdouble f))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangeIndexed_debug(GLuint index, GLdouble n, GLdouble f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexed, "(%u, %f, %f)", (unsigned int)index, (double)n, (double)f)
    glatter_glDepthRangeIndexed(index, n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangeIndexed_defined
#endif
#ifndef glDepthRangef_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDepthRangef, (n, f), (GLfloat n, GLfloat f))
GLATTER_INLINE_OR_NOT void glatter_glDepthRangef_debug(GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangef, "(%f, %f)", (float)n, (float)f)
    glatter_glDepthRangef(n, f);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDepthRangef_defined
#endif
#ifndef glGenProgramPipelines_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_INLINE_OR_NOT void glatter_glGenProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramPipelines, "(%d, %p)", (int)n, (void*)pipelines)
    glatter_glGenProgramPipelines(n, pipelines);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenProgramPipelines_defined
#endif
#ifndef glGetDoublei_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetDoublei_v, (target, index, data), (GLenum target, GLuint index, GLdouble *data))
GLATTER_INLINE_OR_NOT void glatter_glGetDoublei_v_debug(GLenum target, GLuint index, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublei_v, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetDoublei_v(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetDoublei_v_defined
#endif
#ifndef glGetFloati_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFloati_v, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_INLINE_OR_NOT void glatter_glGetFloati_v_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_v, "(%s, %u, %p)", enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloati_v(target, index, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFloati_v_defined
#endif
#ifndef glGetProgramBinary_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramBinary, (program, bufSize, length, binaryFormat, binary), (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramBinary_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramBinary, "(%u, %d, %p, %p, %p)", (unsigned int)program, (int)bufSize, (void*)length, (void*)binaryFormat, (void*)binary)
    glatter_glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramBinary_defined
#endif
#ifndef glGetProgramPipelineInfoLog_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramPipelineInfoLog, (pipeline, bufSize, length, infoLog), (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramPipelineInfoLog_debug(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineInfoLog, "(%u, %d, %p, %p)", (unsigned int)pipeline, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramPipelineInfoLog_defined
#endif
#ifndef glGetProgramPipelineiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramPipelineiv, (pipeline, pname, params), (GLuint pipeline, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramPipelineiv_debug(GLuint pipeline, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineiv, "(%u, %s, %p)", (unsigned int)pipeline, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramPipelineiv(pipeline, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramPipelineiv_defined
#endif
#ifndef glGetShaderPrecisionFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetShaderPrecisionFormat, (shadertype, precisiontype, range, precision), (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision))
GLATTER_INLINE_OR_NOT void glatter_glGetShaderPrecisionFormat_debug(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderPrecisionFormat, "(%s, %s, %p, %p)", enum_to_string_GL(shadertype), enum_to_string_GL(precisiontype), (void*)range, (void*)precision)
    glatter_glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetShaderPrecisionFormat_defined
#endif
#ifndef glGetVertexAttribLdv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexAttribLdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexAttribLdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLdv, "(%u, %s, %p)", (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLdv(index, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexAttribLdv_defined
#endif
#ifndef glIsProgramPipeline_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glIsProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_INLINE_OR_NOT GLboolean glatter_glIsProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramPipeline, "(%u)", (unsigned int)pipeline)
    GLboolean rval = glatter_glIsProgramPipeline(pipeline);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glIsProgramPipeline_defined
#endif
#ifndef glProgramBinary_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramBinary, (program, binaryFormat, binary, length), (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length))
GLATTER_INLINE_OR_NOT void glatter_glProgramBinary_debug(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBinary, "(%u, %s, %p, %d)", (unsigned int)program, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glProgramBinary(program, binaryFormat, binary, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramBinary_defined
#endif
#ifndef glProgramParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramParameteri, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_INLINE_OR_NOT void glatter_glProgramParameteri_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteri, "(%u, %s, %d)", (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteri(program, pname, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramParameteri_defined
#endif
#ifndef glProgramUniform1d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1d, (program, location, v0), (GLuint program, GLint location, GLdouble v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1d_debug(GLuint program, GLint location, GLdouble v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1d, "(%u, %d, %f)", (unsigned int)program, (int)location, (double)v0)
    glatter_glProgramUniform1d(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1d_defined
#endif
#ifndef glProgramUniform1dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1dv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1dv_defined
#endif
#ifndef glProgramUniform1f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1f, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1f_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1f, "(%u, %d, %f)", (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1f(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1f_defined
#endif
#ifndef glProgramUniform1fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1fv_defined
#endif
#ifndef glProgramUniform1i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1i, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1i_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i, "(%u, %d, %d)", (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1i(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1i_defined
#endif
#ifndef glProgramUniform1iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1iv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1iv_defined
#endif
#ifndef glProgramUniform1ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1ui, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1ui_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui, "(%u, %d, %u)", (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1ui(program, location, v0);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1ui_defined
#endif
#ifndef glProgramUniform1uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform1uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform1uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uiv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform1uiv_defined
#endif
#ifndef glProgramUniform2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2d, (program, location, v0, v1), (GLuint program, GLint location, GLdouble v0, GLdouble v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2d, "(%u, %d, %f, %f)", (unsigned int)program, (int)location, (double)v0, (double)v1)
    glatter_glProgramUniform2d(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2d_defined
#endif
#ifndef glProgramUniform2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2dv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2dv_defined
#endif
#ifndef glProgramUniform2f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2f, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2f, "(%u, %d, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2f(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2f_defined
#endif
#ifndef glProgramUniform2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2fv_defined
#endif
#ifndef glProgramUniform2i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2i, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2i_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i, "(%u, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2i(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2i_defined
#endif
#ifndef glProgramUniform2iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2iv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2iv_defined
#endif
#ifndef glProgramUniform2ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2ui, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui, "(%u, %d, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2ui(program, location, v0, v1);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2ui_defined
#endif
#ifndef glProgramUniform2uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform2uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform2uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uiv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform2uiv_defined
#endif
#ifndef glProgramUniform3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3d, (program, location, v0, v1, v2), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3d, "(%u, %d, %f, %f, %f)", (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2)
    glatter_glProgramUniform3d(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3d_defined
#endif
#ifndef glProgramUniform3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3dv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3dv_defined
#endif
#ifndef glProgramUniform3f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3f, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3f, "(%u, %d, %f, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3f(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3f_defined
#endif
#ifndef glProgramUniform3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3fv_defined
#endif
#ifndef glProgramUniform3i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3i, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i, "(%u, %d, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3i(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3i_defined
#endif
#ifndef glProgramUniform3iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3iv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3iv_defined
#endif
#ifndef glProgramUniform3ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3ui, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui, "(%u, %d, %u, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3ui(program, location, v0, v1, v2);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3ui_defined
#endif
#ifndef glProgramUniform3uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform3uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform3uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uiv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform3uiv_defined
#endif
#ifndef glProgramUniform4d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4d, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4d, "(%u, %d, %f, %f, %f, %f)", (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2, (double)v3)
    glatter_glProgramUniform4d(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4d_defined
#endif
#ifndef glProgramUniform4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4dv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4dv_defined
#endif
#ifndef glProgramUniform4f_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4f, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4f, "(%u, %d, %f, %f, %f, %f)", (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4f(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4f_defined
#endif
#ifndef glProgramUniform4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4fv_defined
#endif
#ifndef glProgramUniform4i_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4i, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i, "(%u, %d, %d, %d, %d, %d)", (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4i(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4i_defined
#endif
#ifndef glProgramUniform4iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4iv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4iv_defined
#endif
#ifndef glProgramUniform4ui_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4ui, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui, "(%u, %d, %u, %u, %u, %u)", (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4ui(program, location, v0, v1, v2, v3);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4ui_defined
#endif
#ifndef glProgramUniform4uiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniform4uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniform4uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uiv(program, location, count, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniform4uiv_defined
#endif
#ifndef glProgramUniformMatrix2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2dv_defined
#endif
#ifndef glProgramUniformMatrix2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2fv_defined
#endif
#ifndef glProgramUniformMatrix2x3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x3dv_defined
#endif
#ifndef glProgramUniformMatrix2x3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x3fv_defined
#endif
#ifndef glProgramUniformMatrix2x4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x4dv_defined
#endif
#ifndef glProgramUniformMatrix2x4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix2x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix2x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix2x4fv_defined
#endif
#ifndef glProgramUniformMatrix3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3dv_defined
#endif
#ifndef glProgramUniformMatrix3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3fv_defined
#endif
#ifndef glProgramUniformMatrix3x2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x2dv_defined
#endif
#ifndef glProgramUniformMatrix3x2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x2fv_defined
#endif
#ifndef glProgramUniformMatrix3x4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x4dv_defined
#endif
#ifndef glProgramUniformMatrix3x4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix3x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix3x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix3x4fv_defined
#endif
#ifndef glProgramUniformMatrix4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4dv_defined
#endif
#ifndef glProgramUniformMatrix4fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4fv_defined
#endif
#ifndef glProgramUniformMatrix4x2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x2dv_defined
#endif
#ifndef glProgramUniformMatrix4x2fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x2fv_defined
#endif
#ifndef glProgramUniformMatrix4x3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3dv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x3dv_defined
#endif
#ifndef glProgramUniformMatrix4x3fv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glProgramUniformMatrix4x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glProgramUniformMatrix4x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fv, "(%u, %d, %d, %u, %p)", (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glProgramUniformMatrix4x3fv_defined
#endif
#ifndef glReleaseShaderCompiler_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReleaseShaderCompiler, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glReleaseShaderCompiler_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReleaseShaderCompiler, "()")
    glatter_glReleaseShaderCompiler();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReleaseShaderCompiler_defined
#endif
#ifndef glScissorArrayv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScissorArrayv, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glScissorArrayv_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorArrayv, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorArrayv(first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScissorArrayv_defined
#endif
#ifndef glScissorIndexed_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScissorIndexed, (index, left, bottom, width, height), (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glScissorIndexed_debug(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexed, "(%u, %d, %d, %d, %d)", (unsigned int)index, (int)left, (int)bottom, (int)width, (int)height)
    glatter_glScissorIndexed(index, left, bottom, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScissorIndexed_defined
#endif
#ifndef glScissorIndexedv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glScissorIndexedv, (index, v), (GLuint index, const GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glScissorIndexedv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glScissorIndexedv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glScissorIndexedv_defined
#endif
#ifndef glShaderBinary_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderBinary, (count, shaders, binaryFormat, binary, length), (GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length))
GLATTER_INLINE_OR_NOT void glatter_glShaderBinary_debug(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderBinary, "(%d, %p, %s, %p, %d)", (int)count, (void*)shaders, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glShaderBinary(count, shaders, binaryFormat, binary, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderBinary_defined
#endif
#ifndef glUseProgramStages_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glUseProgramStages, (pipeline, stages, program), (GLuint pipeline, GLbitfield stages, GLuint program))
GLATTER_INLINE_OR_NOT void glatter_glUseProgramStages_debug(GLuint pipeline, GLbitfield stages, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramStages, "(%u, %u, %u)", (unsigned int)pipeline, (unsigned int)stages, (unsigned int)program)
    glatter_glUseProgramStages(pipeline, stages, program);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glUseProgramStages_defined
#endif
#ifndef glValidateProgramPipeline_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glValidateProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_INLINE_OR_NOT void glatter_glValidateProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramPipeline, "(%u)", (unsigned int)pipeline)
    glatter_glValidateProgramPipeline(pipeline);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glValidateProgramPipeline_defined
#endif
#ifndef glVertexAttribL1d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1d, (index, x), (GLuint index, GLdouble x))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1d, "(%u, %f)", (unsigned int)index, (double)x)
    glatter_glVertexAttribL1d(index, x);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1d_defined
#endif
#ifndef glVertexAttribL1dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL1dv_defined
#endif
#ifndef glVertexAttribL2d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2d, "(%u, %f, %f)", (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttribL2d(index, x, y);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2d_defined
#endif
#ifndef glVertexAttribL2dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL2dv_defined
#endif
#ifndef glVertexAttribL3d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3d, "(%u, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttribL3d(index, x, y, z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3d_defined
#endif
#ifndef glVertexAttribL3dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL3dv_defined
#endif
#ifndef glVertexAttribL4d_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4d, "(%u, %f, %f, %f, %f)", (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttribL4d(index, x, y, z, w);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4d_defined
#endif
#ifndef glVertexAttribL4dv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribL4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribL4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4dv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribL4dv_defined
#endif
#ifndef glVertexAttribLPointer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribLPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribLPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLPointer, "(%u, %d, %s, %d, %p)", (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribLPointer(index, size, type, stride, pointer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribLPointer_defined
#endif
#ifndef glViewportArrayv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glViewportArrayv, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glViewportArrayv_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportArrayv, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)v)
    glatter_glViewportArrayv(first, count, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glViewportArrayv_defined
#endif
#ifndef glViewportIndexedf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glViewportIndexedf, (index, x, y, w, h), (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h))
GLATTER_INLINE_OR_NOT void glatter_glViewportIndexedf_debug(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedf, "(%u, %f, %f, %f, %f)", (unsigned int)index, (float)x, (float)y, (float)w, (float)h)
    glatter_glViewportIndexedf(index, x, y, w, h);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glViewportIndexedf_defined
#endif
#ifndef glViewportIndexedfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glViewportIndexedfv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glViewportIndexedfv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfv, "(%u, %p)", (unsigned int)index, (void*)v)
    glatter_glViewportIndexedfv(index, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glViewportIndexedfv_defined
#endif
#endif // defined(GL_VERSION_4_1)
#if defined(GL_VERSION_4_2)
#ifndef glBindImageTexture_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindImageTexture, (unit, texture, level, layered, layer, access, format), (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format))
GLATTER_INLINE_OR_NOT void glatter_glBindImageTexture_debug(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTexture, "(%u, %u, %d, %u, %d, %s, %s)", (unsigned int)unit, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), enum_to_string_GL(format))
    glatter_glBindImageTexture(unit, texture, level, layered, layer, access, format);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindImageTexture_defined
#endif
#ifndef glDrawArraysInstancedBaseInstance_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawArraysInstancedBaseInstance, (mode, first, count, instancecount, baseinstance), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance))
GLATTER_INLINE_OR_NOT void glatter_glDrawArraysInstancedBaseInstance_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedBaseInstance, "(%s, %d, %d, %d, %u)", enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawArraysInstancedBaseInstance_defined
#endif
#ifndef glDrawElementsInstancedBaseInstance_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstancedBaseInstance, (mode, count, type, indices, instancecount, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstancedBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseInstance, "(%s, %d, %s, %p, %d, %u)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstancedBaseInstance_defined
#endif
#ifndef glDrawElementsInstancedBaseVertexBaseInstance_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawElementsInstancedBaseVertexBaseInstance, (mode, count, type, indices, instancecount, basevertex, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance))
GLATTER_INLINE_OR_NOT void glatter_glDrawElementsInstancedBaseVertexBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexBaseInstance, "(%s, %d, %s, %p, %d, %d, %u)", enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawElementsInstancedBaseVertexBaseInstance_defined
#endif
#ifndef glDrawTransformFeedbackInstanced_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTransformFeedbackInstanced, (mode, id, instancecount), (GLenum mode, GLuint id, GLsizei instancecount))
GLATTER_INLINE_OR_NOT void glatter_glDrawTransformFeedbackInstanced_debug(GLenum mode, GLuint id, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackInstanced, "(%s, %u, %d)", enum_to_string_GL(mode), (unsigned int)id, (int)instancecount)
    glatter_glDrawTransformFeedbackInstanced(mode, id, instancecount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTransformFeedbackInstanced_defined
#endif
#ifndef glDrawTransformFeedbackStreamInstanced_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDrawTransformFeedbackStreamInstanced, (mode, id, stream, instancecount), (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount))
GLATTER_INLINE_OR_NOT void glatter_glDrawTransformFeedbackStreamInstanced_debug(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStreamInstanced, "(%s, %u, %u, %d)", enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream, (int)instancecount)
    glatter_glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDrawTransformFeedbackStreamInstanced_defined
#endif
#ifndef glGetActiveAtomicCounterBufferiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetActiveAtomicCounterBufferiv, (program, bufferIndex, pname, params), (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetActiveAtomicCounterBufferiv_debug(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAtomicCounterBufferiv, "(%u, %u, %s, %p)", (unsigned int)program, (unsigned int)bufferIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetActiveAtomicCounterBufferiv_defined
#endif
#ifndef glGetInternalformativ_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInternalformativ, (target, internalformat, pname, count, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetInternalformativ_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformativ, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)count, (void*)params)
    glatter_glGetInternalformativ(target, internalformat, pname, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInternalformativ_defined
#endif
#ifndef glMemoryBarrier_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMemoryBarrier, (barriers), (GLbitfield barriers))
GLATTER_INLINE_OR_NOT void glatter_glMemoryBarrier_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrier, "(%u)", (unsigned int)barriers)
    glatter_glMemoryBarrier(barriers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMemoryBarrier_defined
#endif
#ifndef glTexStorage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage1D, (target, levels, internalformat, width), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage1D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage1D, "(%s, %d, %s, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTexStorage1D(target, levels, internalformat, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage1D_defined
#endif
#ifndef glTexStorage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage2D, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage2D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2D, "(%s, %d, %s, %d, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2D(target, levels, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage2D_defined
#endif
#ifndef glTexStorage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage3D, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage3D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3D, "(%s, %d, %s, %d, %d, %d)", enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3D(target, levels, internalformat, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage3D_defined
#endif
#endif // defined(GL_VERSION_4_2)
#if defined(GL_VERSION_4_3)
#ifndef glBindVertexBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVertexBuffer, (bindingindex, buffer, offset, stride), (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glBindVertexBuffer_debug(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffer, "(%u, %u, %s, %d)", (unsigned int)bindingindex, (unsigned int)buffer, GET_PRS(offset), (int)stride)
    glatter_glBindVertexBuffer(bindingindex, buffer, offset, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVertexBuffer_defined
#endif
#ifndef glClearBufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferData, (target, internalformat, format, type, data), (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferData_debug(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferData, "(%s, %s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferData(target, internalformat, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferData_defined
#endif
#ifndef glClearBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearBufferSubData, (target, internalformat, offset, size, format, type, data), (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearBufferSubData_debug(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferSubData, "(%s, %s, %s, %s, %s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), GET_PRS(offset), GET_PRS(size), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferSubData(target, internalformat, offset, size, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearBufferSubData_defined
#endif
#ifndef glCopyImageSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyImageSubData, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
GLATTER_INLINE_OR_NOT void glatter_glCopyImageSubData_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubData, "(%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyImageSubData_defined
#endif
#ifndef glDebugMessageCallback_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageCallback, (callback, userParam), (GLDEBUGPROC callback, const void *userParam))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageCallback_debug(GLDEBUGPROC callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallback, "(%s, %p)", GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallback(callback, userParam);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageCallback_defined
#endif
#ifndef glDebugMessageControl_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageControl, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageControl_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControl, "(%s, %s, %s, %d, %p, %u)", enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControl(source, type, severity, count, ids, enabled);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageControl_defined
#endif
#ifndef glDebugMessageInsert_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDebugMessageInsert, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_INLINE_OR_NOT void glatter_glDebugMessageInsert_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsert, "(%s, %s, %u, %s, %d, %p)", enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsert(source, type, id, severity, length, buf);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDebugMessageInsert_defined
#endif
#ifndef glDispatchCompute_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDispatchCompute, (num_groups_x, num_groups_y, num_groups_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z))
GLATTER_INLINE_OR_NOT void glatter_glDispatchCompute_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchCompute, "(%u, %u, %u)", (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z)
    glatter_glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDispatchCompute_defined
#endif
#ifndef glDispatchComputeIndirect_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDispatchComputeIndirect, (indirect), (GLintptr indirect))
GLATTER_INLINE_OR_NOT void glatter_glDispatchComputeIndirect_debug(GLintptr indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeIndirect, "(%s)", GET_PRS(indirect))
    glatter_glDispatchComputeIndirect(indirect);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDispatchComputeIndirect_defined
#endif
#ifndef glFramebufferParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFramebufferParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glFramebufferParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferParameteri, "(%s, %s, %d)", enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glFramebufferParameteri(target, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFramebufferParameteri_defined
#endif
#ifndef glGetDebugMessageLog_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetDebugMessageLog, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetDebugMessageLog_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLog, "(%u, %d, %p, %p, %p, %p, %p, %p)", (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetDebugMessageLog_defined
#endif
#ifndef glGetFramebufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetFramebufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetFramebufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameteriv, "(%s, %s, %p)", enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameteriv(target, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetFramebufferParameteriv_defined
#endif
#ifndef glGetInternalformati64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetInternalformati64v, (target, internalformat, pname, count, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetInternalformati64v_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformati64v, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)count, (void*)params)
    glatter_glGetInternalformati64v(target, internalformat, pname, count, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetInternalformati64v_defined
#endif
#ifndef glGetObjectLabel_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectLabel, (identifier, name, bufSize, length, label), (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectLabel_debug(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabel, "(%s, %u, %d, %p, %p)", enum_to_string_GL(identifier), (unsigned int)name, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabel(identifier, name, bufSize, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectLabel_defined
#endif
#ifndef glGetObjectPtrLabel_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetObjectPtrLabel, (ptr, bufSize, length, label), (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glGetObjectPtrLabel_debug(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectPtrLabel, "(%p, %d, %p, %p)", (void*)ptr, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectPtrLabel(ptr, bufSize, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetObjectPtrLabel_defined
#endif
#ifndef glGetProgramInterfaceiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramInterfaceiv, (program, programInterface, pname, params), (GLuint program, GLenum programInterface, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramInterfaceiv_debug(GLuint program, GLenum programInterface, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInterfaceiv, "(%u, %s, %s, %p)", (unsigned int)program, enum_to_string_GL(programInterface), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramInterfaceiv(program, programInterface, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramInterfaceiv_defined
#endif
#ifndef glGetProgramResourceIndex_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLuint, APIENTRY, glGetProgramResourceIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_INLINE_OR_NOT GLuint glatter_glGetProgramResourceIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceIndex, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLuint rval = glatter_glGetProgramResourceIndex(program, programInterface, name);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetProgramResourceIndex_defined
#endif
#ifndef glGetProgramResourceLocation_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetProgramResourceLocation, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetProgramResourceLocation_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocation, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocation(program, programInterface, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetProgramResourceLocation_defined
#endif
#ifndef glGetProgramResourceLocationIndex_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLint, APIENTRY, glGetProgramResourceLocationIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_INLINE_OR_NOT GLint glatter_glGetProgramResourceLocationIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocationIndex, "(%u, %s, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocationIndex(program, programInterface, name);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetProgramResourceLocationIndex_defined
#endif
#ifndef glGetProgramResourceName_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramResourceName, (program, programInterface, index, bufSize, length, name), (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramResourceName_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceName, "(%u, %s, %u, %d, %p, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramResourceName_defined
#endif
#ifndef glGetProgramResourceiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetProgramResourceiv, (program, programInterface, index, propCount, props, count, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetProgramResourceiv_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceiv, "(%u, %s, %u, %d, %p, %d, %p, %p)", (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)count, (void*)length, (void*)params)
    glatter_glGetProgramResourceiv(program, programInterface, index, propCount, props, count, length, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetProgramResourceiv_defined
#endif
#ifndef glInvalidateBufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateBufferData, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateBufferData_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferData, "(%u)", (unsigned int)buffer)
    glatter_glInvalidateBufferData(buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateBufferData_defined
#endif
#ifndef glInvalidateBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateBufferSubData, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferSubData, "(%u, %s, %s)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(length))
    glatter_glInvalidateBufferSubData(buffer, offset, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateBufferSubData_defined
#endif
#ifndef glInvalidateFramebuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateFramebuffer, (target, numAttachments, attachments), (GLenum target, GLsizei numAttachments, const GLenum *attachments))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateFramebuffer, "(%s, %d, %p)", enum_to_string_GL(target), (int)numAttachments, (void*)attachments)
    glatter_glInvalidateFramebuffer(target, numAttachments, attachments);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateFramebuffer_defined
#endif
#ifndef glInvalidateSubFramebuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateSubFramebuffer, (target, numAttachments, attachments, x, y, width, height), (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateSubFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateSubFramebuffer, "(%s, %d, %p, %d, %d, %d, %d)", enum_to_string_GL(target), (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateSubFramebuffer_defined
#endif
#ifndef glInvalidateTexImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateTexImage, (texture, level), (GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateTexImage_debug(GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexImage, "(%u, %d)", (unsigned int)texture, (int)level)
    glatter_glInvalidateTexImage(texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateTexImage_defined
#endif
#ifndef glInvalidateTexSubImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexSubImage, "(%u, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth)
    glatter_glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateTexSubImage_defined
#endif
#ifndef glMultiDrawArraysIndirect_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirect, (mode, indirect, drawcount, stride), (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirect_debug(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirect, "(%s, %p, %d, %d)", enum_to_string_GL(mode), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirect_defined
#endif
#ifndef glMultiDrawElementsIndirect_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirect, (mode, type, indirect, drawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirect, "(%s, %s, %p, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirect_defined
#endif
#ifndef glObjectLabel_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glObjectLabel, (identifier, name, length, label), (GLenum identifier, GLuint name, GLsizei length, const GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glObjectLabel_debug(GLenum identifier, GLuint name, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectLabel, "(%s, %u, %d, %p)", enum_to_string_GL(identifier), (unsigned int)name, (int)length, (void*)label)
    glatter_glObjectLabel(identifier, name, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glObjectLabel_defined
#endif
#ifndef glObjectPtrLabel_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glObjectPtrLabel, (ptr, length, label), (const void *ptr, GLsizei length, const GLchar *label))
GLATTER_INLINE_OR_NOT void glatter_glObjectPtrLabel_debug(const void *ptr, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPtrLabel, "(%p, %d, %p)", (void*)ptr, (int)length, (void*)label)
    glatter_glObjectPtrLabel(ptr, length, label);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glObjectPtrLabel_defined
#endif
#ifndef glPopDebugGroup_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPopDebugGroup, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glPopDebugGroup_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopDebugGroup, "()")
    glatter_glPopDebugGroup();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPopDebugGroup_defined
#endif
#ifndef glPushDebugGroup_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPushDebugGroup, (source, id, length, message), (GLenum source, GLuint id, GLsizei length, const GLchar *message))
GLATTER_INLINE_OR_NOT void glatter_glPushDebugGroup_debug(GLenum source, GLuint id, GLsizei length, const GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushDebugGroup, "(%s, %u, %d, %p)", enum_to_string_GL(source), (unsigned int)id, (int)length, (void*)message)
    glatter_glPushDebugGroup(source, id, length, message);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPushDebugGroup_defined
#endif
#ifndef glShaderStorageBlockBinding_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glShaderStorageBlockBinding, (program, storageBlockIndex, storageBlockBinding), (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding))
GLATTER_INLINE_OR_NOT void glatter_glShaderStorageBlockBinding_debug(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderStorageBlockBinding, "(%u, %u, %u)", (unsigned int)program, (unsigned int)storageBlockIndex, (unsigned int)storageBlockBinding)
    glatter_glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glShaderStorageBlockBinding_defined
#endif
#ifndef glTexBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexBufferRange, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glTexBufferRange_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRange, "(%s, %s, %u, %s, %s)", enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glTexBufferRange(target, internalformat, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexBufferRange_defined
#endif
#ifndef glTexStorage2DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DMultisample, "(%s, %d, %s, %d, %d, %u)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage2DMultisample_defined
#endif
#ifndef glTexStorage3DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTexStorage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTexStorage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DMultisample, "(%s, %d, %s, %d, %d, %d, %u)", enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTexStorage3DMultisample_defined
#endif
#ifndef glTextureView_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureView, (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers))
GLATTER_INLINE_OR_NOT void glatter_glTextureView_debug(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureView, "(%u, %s, %u, %s, %u, %u, %u, %u)", (unsigned int)texture, enum_to_string_GL(target), (unsigned int)origtexture, enum_to_string_GL(internalformat), (unsigned int)minlevel, (unsigned int)numlevels, (unsigned int)minlayer, (unsigned int)numlayers)
    glatter_glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureView_defined
#endif
#ifndef glVertexAttribBinding_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribBinding, (attribindex, bindingindex), (GLuint attribindex, GLuint bindingindex))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribBinding_debug(GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribBinding, "(%u, %u)", (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexAttribBinding(attribindex, bindingindex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribBinding_defined
#endif
#ifndef glVertexAttribFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribFormat, (attribindex, size, type, normalized, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribFormat_debug(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormat, "(%u, %d, %s, %u, %u)", (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribFormat_defined
#endif
#ifndef glVertexAttribIFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribIFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribIFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormat, "(%u, %d, %s, %u)", (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribIFormat(attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribIFormat_defined
#endif
#ifndef glVertexAttribLFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexAttribLFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexAttribLFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLFormat, "(%u, %d, %s, %u)", (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribLFormat(attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexAttribLFormat_defined
#endif
#ifndef glVertexBindingDivisor_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexBindingDivisor, (bindingindex, divisor), (GLuint bindingindex, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexBindingDivisor_debug(GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBindingDivisor, "(%u, %u)", (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexBindingDivisor(bindingindex, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexBindingDivisor_defined
#endif
#endif // defined(GL_VERSION_4_3)
#if defined(GL_VERSION_4_4)
#ifndef glBindBuffersBase_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBuffersBase, (target, first, count, buffers), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glBindBuffersBase_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersBase, "(%s, %u, %d, %p)", enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers)
    glatter_glBindBuffersBase(target, first, count, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBuffersBase_defined
#endif
#ifndef glBindBuffersRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindBuffersRange, (target, first, count, buffers, offsets, sizes), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes))
GLATTER_INLINE_OR_NOT void glatter_glBindBuffersRange_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersRange, "(%s, %u, %d, %p, %p, %p)", enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)sizes)
    glatter_glBindBuffersRange(target, first, count, buffers, offsets, sizes);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindBuffersRange_defined
#endif
#ifndef glBindImageTextures_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindImageTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_INLINE_OR_NOT void glatter_glBindImageTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTextures, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindImageTextures(first, count, textures);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindImageTextures_defined
#endif
#ifndef glBindSamplers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindSamplers, (first, count, samplers), (GLuint first, GLsizei count, const GLuint *samplers))
GLATTER_INLINE_OR_NOT void glatter_glBindSamplers_debug(GLuint first, GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSamplers, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)samplers)
    glatter_glBindSamplers(first, count, samplers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindSamplers_defined
#endif
#ifndef glBindTextures_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_INLINE_OR_NOT void glatter_glBindTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextures, "(%u, %d, %p)", (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindTextures(first, count, textures);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindTextures_defined
#endif
#ifndef glBindVertexBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindVertexBuffers, (first, count, buffers, offsets, strides), (GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
GLATTER_INLINE_OR_NOT void glatter_glBindVertexBuffers_debug(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffers, "(%u, %d, %p, %p, %p)", (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glBindVertexBuffers(first, count, buffers, offsets, strides);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindVertexBuffers_defined
#endif
#ifndef glBufferStorage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBufferStorage, (target, size, data, flags), (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glBufferStorage_debug(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorage, "(%s, %s, %p, %u)", enum_to_string_GL(target), GET_PRS(size), (void*)data, (unsigned int)flags)
    glatter_glBufferStorage(target, size, data, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBufferStorage_defined
#endif
#ifndef glClearTexImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearTexImage, (texture, level, format, type, data), (GLuint texture, GLint level, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearTexImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexImage, "(%u, %d, %s, %s, %p)", (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexImage(texture, level, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearTexImage_defined
#endif
#ifndef glClearTexSubImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexSubImage, "(%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearTexSubImage_defined
#endif
#endif // defined(GL_VERSION_4_4)
#if defined(GL_VERSION_4_5)
#ifndef glBindTextureUnit_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBindTextureUnit, (unit, texture), (GLuint unit, GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glBindTextureUnit_debug(GLuint unit, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureUnit, "(%u, %u)", (unsigned int)unit, (unsigned int)texture)
    glatter_glBindTextureUnit(unit, texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBindTextureUnit_defined
#endif
#ifndef glBlitNamedFramebuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glBlitNamedFramebuffer, (readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glBlitNamedFramebuffer_debug(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitNamedFramebuffer, "(%u, %u, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (unsigned int)readFramebuffer, (unsigned int)drawFramebuffer, (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glBlitNamedFramebuffer_defined
#endif
#ifndef glCheckNamedFramebufferStatus_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glCheckNamedFramebufferStatus, (framebuffer, target), (GLuint framebuffer, GLenum target))
GLATTER_INLINE_OR_NOT GLenum glatter_glCheckNamedFramebufferStatus_debug(GLuint framebuffer, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckNamedFramebufferStatus, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(target))
    GLenum rval = glatter_glCheckNamedFramebufferStatus(framebuffer, target);
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glCheckNamedFramebufferStatus_defined
#endif
#ifndef glClearNamedBufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedBufferData, (buffer, internalformat, format, type, data), (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedBufferData_debug(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferData, "(%u, %s, %s, %s, %p)", (unsigned int)buffer, enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferData(buffer, internalformat, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedBufferData_defined
#endif
#ifndef glClearNamedBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedBufferSubData, (buffer, internalformat, offset, size, format, type, data), (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedBufferSubData_debug(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferSubData, "(%u, %s, %s, %s, %s, %s, %p)", (unsigned int)buffer, enum_to_string_GL(internalformat), GET_PRS(offset), GET_PRS(size), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedBufferSubData_defined
#endif
#ifndef glClearNamedFramebufferfi_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedFramebufferfi, (framebuffer, buffer, drawbuffer, depth, stencil), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedFramebufferfi_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfi, "(%u, %s, %d, %f, %d)", (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedFramebufferfi_defined
#endif
#ifndef glClearNamedFramebufferfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedFramebufferfv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedFramebufferfv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfv, "(%u, %s, %d, %p)", (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedFramebufferfv_defined
#endif
#ifndef glClearNamedFramebufferiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedFramebufferiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedFramebufferiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferiv, "(%u, %s, %d, %p)", (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedFramebufferiv_defined
#endif
#ifndef glClearNamedFramebufferuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClearNamedFramebufferuiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_INLINE_OR_NOT void glatter_glClearNamedFramebufferuiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferuiv, "(%u, %s, %d, %p)", (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClearNamedFramebufferuiv_defined
#endif
#ifndef glClipControl_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glClipControl, (origin, depth), (GLenum origin, GLenum depth))
GLATTER_INLINE_OR_NOT void glatter_glClipControl_debug(GLenum origin, GLenum depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipControl, "(%s, %s)", enum_to_string_GL(origin), enum_to_string_GL(depth))
    glatter_glClipControl(origin, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glClipControl_defined
#endif
#ifndef glCompressedTextureSubImage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage1D, (texture, level, xoffset, width, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage1D, "(%u, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage1D_defined
#endif
#ifndef glCompressedTextureSubImage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage2D, "(%u, %d, %d, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage2D_defined
#endif
#ifndef glCompressedTextureSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCompressedTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glCompressedTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage3D, "(%u, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCompressedTextureSubImage3D_defined
#endif
#ifndef glCopyNamedBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyNamedBufferSubData, (readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glCopyNamedBufferSubData_debug(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyNamedBufferSubData, "(%u, %u, %s, %s, %s)", (unsigned int)readBuffer, (unsigned int)writeBuffer, GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyNamedBufferSubData_defined
#endif
#ifndef glCopyTextureSubImage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage1D, (texture, level, xoffset, x, y, width), (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage1D, "(%u, %d, %d, %d, %d, %d)", (unsigned int)texture, (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage1D_defined
#endif
#ifndef glCopyTextureSubImage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage2D, (texture, level, xoffset, yoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage2D, "(%u, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage2D_defined
#endif
#ifndef glCopyTextureSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCopyTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glCopyTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage3D, "(%u, %d, %d, %d, %d, %d, %d, %d, %d)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCopyTextureSubImage3D_defined
#endif
#ifndef glCreateBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_INLINE_OR_NOT void glatter_glCreateBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateBuffers, "(%d, %p)", (int)n, (void*)buffers)
    glatter_glCreateBuffers(n, buffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateBuffers_defined
#endif
#ifndef glCreateFramebuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_INLINE_OR_NOT void glatter_glCreateFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateFramebuffers, "(%d, %p)", (int)n, (void*)framebuffers)
    glatter_glCreateFramebuffers(n, framebuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateFramebuffers_defined
#endif
#ifndef glCreateProgramPipelines_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_INLINE_OR_NOT void glatter_glCreateProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgramPipelines, "(%d, %p)", (int)n, (void*)pipelines)
    glatter_glCreateProgramPipelines(n, pipelines);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateProgramPipelines_defined
#endif
#ifndef glCreateQueries_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateQueries, (target, n, ids), (GLenum target, GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glCreateQueries_debug(GLenum target, GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateQueries, "(%s, %d, %p)", enum_to_string_GL(target), (int)n, (void*)ids)
    glatter_glCreateQueries(target, n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateQueries_defined
#endif
#ifndef glCreateRenderbuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_INLINE_OR_NOT void glatter_glCreateRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateRenderbuffers, "(%d, %p)", (int)n, (void*)renderbuffers)
    glatter_glCreateRenderbuffers(n, renderbuffers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateRenderbuffers_defined
#endif
#ifndef glCreateSamplers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateSamplers, (n, samplers), (GLsizei n, GLuint *samplers))
GLATTER_INLINE_OR_NOT void glatter_glCreateSamplers_debug(GLsizei n, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSamplers, "(%d, %p)", (int)n, (void*)samplers)
    glatter_glCreateSamplers(n, samplers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateSamplers_defined
#endif
#ifndef glCreateTextures_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateTextures, (target, n, textures), (GLenum target, GLsizei n, GLuint *textures))
GLATTER_INLINE_OR_NOT void glatter_glCreateTextures_debug(GLenum target, GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTextures, "(%s, %d, %p)", enum_to_string_GL(target), (int)n, (void*)textures)
    glatter_glCreateTextures(target, n, textures);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateTextures_defined
#endif
#ifndef glCreateTransformFeedbacks_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_INLINE_OR_NOT void glatter_glCreateTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTransformFeedbacks, "(%d, %p)", (int)n, (void*)ids)
    glatter_glCreateTransformFeedbacks(n, ids);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateTransformFeedbacks_defined
#endif
#ifndef glCreateVertexArrays_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glCreateVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_INLINE_OR_NOT void glatter_glCreateVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateVertexArrays, "(%d, %p)", (int)n, (void*)arrays)
    glatter_glCreateVertexArrays(n, arrays);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glCreateVertexArrays_defined
#endif
#ifndef glDisableVertexArrayAttrib_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glDisableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glDisableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayAttrib, "(%u, %u)", (unsigned int)vaobj, (unsigned int)index)
    glatter_glDisableVertexArrayAttrib(vaobj, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glDisableVertexArrayAttrib_defined
#endif
#ifndef glEnableVertexArrayAttrib_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glEnableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_INLINE_OR_NOT void glatter_glEnableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayAttrib, "(%u, %u)", (unsigned int)vaobj, (unsigned int)index)
    glatter_glEnableVertexArrayAttrib(vaobj, index);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glEnableVertexArrayAttrib_defined
#endif
#ifndef glFlushMappedNamedBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glFlushMappedNamedBufferRange, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_INLINE_OR_NOT void glatter_glFlushMappedNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedNamedBufferRange, "(%u, %s, %s)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(length))
    glatter_glFlushMappedNamedBufferRange(buffer, offset, length);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glFlushMappedNamedBufferRange_defined
#endif
#ifndef glGenerateTextureMipmap_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGenerateTextureMipmap, (texture), (GLuint texture))
GLATTER_INLINE_OR_NOT void glatter_glGenerateTextureMipmap_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateTextureMipmap, "(%u)", (unsigned int)texture)
    glatter_glGenerateTextureMipmap(texture);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGenerateTextureMipmap_defined
#endif
#ifndef glGetCompressedTextureImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedTextureImage, (texture, level, bufSize, pixels), (GLuint texture, GLint level, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedTextureImage_debug(GLuint texture, GLint level, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureImage, "(%u, %d, %d, %p)", (unsigned int)texture, (int)level, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureImage(texture, level, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedTextureImage_defined
#endif
#ifndef glGetCompressedTextureSubImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetCompressedTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetCompressedTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureSubImage, "(%u, %d, %d, %d, %d, %d, %d, %d, %d, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetCompressedTextureSubImage_defined
#endif
#ifndef glGetGraphicsResetStatus_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLenum, APIENTRY, glGetGraphicsResetStatus, (), (void))
GLATTER_INLINE_OR_NOT GLenum glatter_glGetGraphicsResetStatus_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatus, "()")
    GLenum rval = glatter_glGetGraphicsResetStatus();
    GLATTER_RBLOCK("%s\n", enum_to_string_GL(rval));
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glGetGraphicsResetStatus_defined
#endif
#ifndef glGetNamedBufferParameteri64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferParameteri64v, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint64 *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferParameteri64v_debug(GLuint buffer, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteri64v, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteri64v(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferParameteri64v_defined
#endif
#ifndef glGetNamedBufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferParameteriv, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferParameteriv_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteriv, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteriv(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferParameteriv_defined
#endif
#ifndef glGetNamedBufferPointerv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferPointerv, (buffer, pname, params), (GLuint buffer, GLenum pname, void **params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferPointerv_debug(GLuint buffer, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferPointerv, "(%u, %s, %p)", (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferPointerv(buffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferPointerv_defined
#endif
#ifndef glGetNamedBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferSubData, "(%u, %s, %s, %p)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glGetNamedBufferSubData(buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedBufferSubData_defined
#endif
#ifndef glGetNamedFramebufferAttachmentParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedFramebufferAttachmentParameteriv, (framebuffer, attachment, pname, params), (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedFramebufferAttachmentParameteriv_debug(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferAttachmentParameteriv, "(%u, %s, %s, %p)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedFramebufferAttachmentParameteriv_defined
#endif
#ifndef glGetNamedFramebufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedFramebufferParameteriv, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedFramebufferParameteriv_debug(GLuint framebuffer, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameteriv, "(%u, %s, %p)", (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)param)
    glatter_glGetNamedFramebufferParameteriv(framebuffer, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedFramebufferParameteriv_defined
#endif
#ifndef glGetNamedRenderbufferParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetNamedRenderbufferParameteriv, (renderbuffer, pname, params), (GLuint renderbuffer, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetNamedRenderbufferParameteriv_debug(GLuint renderbuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedRenderbufferParameteriv, "(%u, %s, %p)", (unsigned int)renderbuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetNamedRenderbufferParameteriv_defined
#endif
#ifndef glGetQueryBufferObjecti64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryBufferObjecti64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryBufferObjecti64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjecti64v, "(%u, %u, %s, %s)", (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), GET_PRS(offset))
    glatter_glGetQueryBufferObjecti64v(id, buffer, pname, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryBufferObjecti64v_defined
#endif
#ifndef glGetQueryBufferObjectiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryBufferObjectiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryBufferObjectiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectiv, "(%u, %u, %s, %s)", (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), GET_PRS(offset))
    glatter_glGetQueryBufferObjectiv(id, buffer, pname, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryBufferObjectiv_defined
#endif
#ifndef glGetQueryBufferObjectui64v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryBufferObjectui64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryBufferObjectui64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectui64v, "(%u, %u, %s, %s)", (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), GET_PRS(offset))
    glatter_glGetQueryBufferObjectui64v(id, buffer, pname, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryBufferObjectui64v_defined
#endif
#ifndef glGetQueryBufferObjectuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetQueryBufferObjectuiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_INLINE_OR_NOT void glatter_glGetQueryBufferObjectuiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectuiv, "(%u, %u, %s, %s)", (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), GET_PRS(offset))
    glatter_glGetQueryBufferObjectuiv(id, buffer, pname, offset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetQueryBufferObjectuiv_defined
#endif
#ifndef glGetTextureImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureImage, (texture, level, format, type, bufSize, pixels), (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureImage, "(%u, %d, %s, %s, %d, %p)", (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureImage(texture, level, format, type, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureImage_defined
#endif
#ifndef glGetTextureLevelParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureLevelParameterfv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureLevelParameterfv_debug(GLuint texture, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterfv, "(%u, %d, %s, %p)", (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterfv(texture, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureLevelParameterfv_defined
#endif
#ifndef glGetTextureLevelParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureLevelParameteriv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureLevelParameteriv_debug(GLuint texture, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameteriv, "(%u, %d, %s, %p)", (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameteriv(texture, level, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureLevelParameteriv_defined
#endif
#ifndef glGetTextureParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterIiv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIiv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIiv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterIiv_defined
#endif
#ifndef glGetTextureParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterIuiv_debug(GLuint texture, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIuiv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIuiv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterIuiv_defined
#endif
#ifndef glGetTextureParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameterfv, (texture, pname, params), (GLuint texture, GLenum pname, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameterfv_debug(GLuint texture, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterfv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterfv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameterfv_defined
#endif
#ifndef glGetTextureParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureParameteriv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureParameteriv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameteriv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameteriv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureParameteriv_defined
#endif
#ifndef glGetTextureSubImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSubImage, "(%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %d, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTextureSubImage_defined
#endif
#ifndef glGetTransformFeedbacki64_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbacki64_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint64 *param))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbacki64_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki64_v, "(%u, %s, %u, %p)", (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki64_v(xfb, pname, index, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbacki64_v_defined
#endif
#ifndef glGetTransformFeedbacki_v_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbacki_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbacki_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki_v, "(%u, %s, %u, %p)", (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki_v(xfb, pname, index, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbacki_v_defined
#endif
#ifndef glGetTransformFeedbackiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetTransformFeedbackiv, (xfb, pname, param), (GLuint xfb, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetTransformFeedbackiv_debug(GLuint xfb, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackiv, "(%u, %s, %p)", (unsigned int)xfb, enum_to_string_GL(pname), (void*)param)
    glatter_glGetTransformFeedbackiv(xfb, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetTransformFeedbackiv_defined
#endif
#ifndef glGetVertexArrayIndexed64iv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayIndexed64iv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint64 *param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayIndexed64iv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexed64iv, "(%u, %u, %s, %p)", (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayIndexed64iv_defined
#endif
#ifndef glGetVertexArrayIndexediv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayIndexediv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayIndexediv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexediv, "(%u, %u, %s, %p)", (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexediv(vaobj, index, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayIndexediv_defined
#endif
#ifndef glGetVertexArrayiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetVertexArrayiv, (vaobj, pname, param), (GLuint vaobj, GLenum pname, GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glGetVertexArrayiv_debug(GLuint vaobj, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayiv, "(%u, %s, %p)", (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayiv(vaobj, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetVertexArrayiv_defined
#endif
#ifndef glGetnColorTable_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnColorTable, (target, format, type, bufSize, table), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table))
GLATTER_INLINE_OR_NOT void glatter_glGetnColorTable_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnColorTable, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)table)
    glatter_glGetnColorTable(target, format, type, bufSize, table);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnColorTable_defined
#endif
#ifndef glGetnCompressedTexImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnCompressedTexImage, (target, lod, bufSize, pixels), (GLenum target, GLint lod, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetnCompressedTexImage_debug(GLenum target, GLint lod, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImage, "(%s, %d, %d, %p)", enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)pixels)
    glatter_glGetnCompressedTexImage(target, lod, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnCompressedTexImage_defined
#endif
#ifndef glGetnConvolutionFilter_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnConvolutionFilter, (target, format, type, bufSize, image), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image))
GLATTER_INLINE_OR_NOT void glatter_glGetnConvolutionFilter_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnConvolutionFilter, "(%s, %s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)image)
    glatter_glGetnConvolutionFilter(target, format, type, bufSize, image);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnConvolutionFilter_defined
#endif
#ifndef glGetnHistogram_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnHistogram, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnHistogram_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnHistogram, "(%s, %u, %s, %s, %d, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnHistogram(target, reset, format, type, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnHistogram_defined
#endif
#ifndef glGetnMapdv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapdv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapdv_debug(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapdv, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapdv(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapdv_defined
#endif
#ifndef glGetnMapfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapfv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapfv_debug(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapfv, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapfv(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapfv_defined
#endif
#ifndef glGetnMapiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMapiv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLint *v))
GLATTER_INLINE_OR_NOT void glatter_glGetnMapiv_debug(GLenum target, GLenum query, GLsizei bufSize, GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapiv, "(%s, %s, %d, %p)", enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapiv(target, query, bufSize, v);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMapiv_defined
#endif
#ifndef glGetnMinmax_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnMinmax, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnMinmax_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMinmax, "(%s, %u, %s, %s, %d, %p)", enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnMinmax(target, reset, format, type, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnMinmax_defined
#endif
#ifndef glGetnPixelMapfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapfv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLfloat *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapfv_debug(GLenum map, GLsizei bufSize, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapfv, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapfv(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapfv_defined
#endif
#ifndef glGetnPixelMapuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapuiv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLuint *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapuiv_debug(GLenum map, GLsizei bufSize, GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapuiv, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapuiv(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapuiv_defined
#endif
#ifndef glGetnPixelMapusv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPixelMapusv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLushort *values))
GLATTER_INLINE_OR_NOT void glatter_glGetnPixelMapusv_debug(GLenum map, GLsizei bufSize, GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapusv, "(%s, %d, %p)", enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapusv(map, bufSize, values);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPixelMapusv_defined
#endif
#ifndef glGetnPolygonStipple_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnPolygonStipple, (bufSize, pattern), (GLsizei bufSize, GLubyte *pattern))
GLATTER_INLINE_OR_NOT void glatter_glGetnPolygonStipple_debug(GLsizei bufSize, GLubyte *pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPolygonStipple, "(%d, %p)", (int)bufSize, (void*)pattern)
    glatter_glGetnPolygonStipple(bufSize, pattern);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnPolygonStipple_defined
#endif
#ifndef glGetnSeparableFilter_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnSeparableFilter, (target, format, type, rowBufSize, row, columnBufSize, column, span), (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span))
GLATTER_INLINE_OR_NOT void glatter_glGetnSeparableFilter_debug(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnSeparableFilter, "(%s, %s, %s, %d, %p, %d, %p, %p)", enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)rowBufSize, (void*)row, (int)columnBufSize, (void*)column, (void*)span)
    glatter_glGetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnSeparableFilter_defined
#endif
#ifndef glGetnTexImage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnTexImage, (target, level, format, type, bufSize, pixels), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glGetnTexImage_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImage, "(%s, %d, %s, %s, %d, %p)", enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetnTexImage(target, level, format, type, bufSize, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnTexImage_defined
#endif
#ifndef glGetnUniformdv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformdv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformdv_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdv(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformdv_defined
#endif
#ifndef glGetnUniformfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformfv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformfv_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfv(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformfv_defined
#endif
#ifndef glGetnUniformiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformiv_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformiv(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformiv_defined
#endif
#ifndef glGetnUniformuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glGetnUniformuiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glGetnUniformuiv_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuiv, "(%u, %d, %d, %p)", (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuiv(program, location, bufSize, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glGetnUniformuiv_defined
#endif
#ifndef glInvalidateNamedFramebufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateNamedFramebufferData, (framebuffer, numAttachments, attachments), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateNamedFramebufferData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferData, "(%u, %d, %p)", (unsigned int)framebuffer, (int)numAttachments, (void*)attachments)
    glatter_glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateNamedFramebufferData_defined
#endif
#ifndef glInvalidateNamedFramebufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glInvalidateNamedFramebufferSubData, (framebuffer, numAttachments, attachments, x, y, width, height), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glInvalidateNamedFramebufferSubData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferSubData, "(%u, %d, %p, %d, %d, %d, %d)", (unsigned int)framebuffer, (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glInvalidateNamedFramebufferSubData_defined
#endif
#ifndef glMapNamedBuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapNamedBuffer, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_INLINE_OR_NOT void * glatter_glMapNamedBuffer_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBuffer, "(%u, %s)", (unsigned int)buffer, enum_to_string_GL(access))
    void * rval = glatter_glMapNamedBuffer(buffer, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapNamedBuffer_defined
#endif
#ifndef glMapNamedBufferRange_defined
GLATTER_FBLOCK(return, GL, GLAPI, void *, APIENTRY, glMapNamedBufferRange, (buffer, offset, length, access), (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_INLINE_OR_NOT void * glatter_glMapNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferRange, "(%u, %s, %s, %u)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(length), (unsigned int)access)
    void * rval = glatter_glMapNamedBufferRange(buffer, offset, length, access);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glMapNamedBufferRange_defined
#endif
#ifndef glMemoryBarrierByRegion_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMemoryBarrierByRegion, (barriers), (GLbitfield barriers))
GLATTER_INLINE_OR_NOT void glatter_glMemoryBarrierByRegion_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierByRegion, "(%u)", (unsigned int)barriers)
    glatter_glMemoryBarrierByRegion(barriers);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMemoryBarrierByRegion_defined
#endif
#ifndef glNamedBufferData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferData, (buffer, size, data, usage), (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferData_debug(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferData, "(%u, %s, %p, %s)", (unsigned int)buffer, GET_PRS(size), (void*)data, enum_to_string_GL(usage))
    glatter_glNamedBufferData(buffer, size, data, usage);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferData_defined
#endif
#ifndef glNamedBufferStorage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferStorage, (buffer, size, data, flags), (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferStorage_debug(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorage, "(%u, %s, %p, %u)", (unsigned int)buffer, GET_PRS(size), (void*)data, (unsigned int)flags)
    glatter_glNamedBufferStorage(buffer, size, data, flags);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferStorage_defined
#endif
#ifndef glNamedBufferSubData_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_INLINE_OR_NOT void glatter_glNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferSubData, "(%u, %s, %s, %p)", (unsigned int)buffer, GET_PRS(offset), GET_PRS(size), (void*)data)
    glatter_glNamedBufferSubData(buffer, offset, size, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedBufferSubData_defined
#endif
#ifndef glNamedFramebufferDrawBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferDrawBuffer, (framebuffer, buf), (GLuint framebuffer, GLenum buf))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferDrawBuffer_debug(GLuint framebuffer, GLenum buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffer, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(buf))
    glatter_glNamedFramebufferDrawBuffer(framebuffer, buf);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferDrawBuffer_defined
#endif
#ifndef glNamedFramebufferDrawBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferDrawBuffers, (framebuffer, n, bufs), (GLuint framebuffer, GLsizei n, const GLenum *bufs))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferDrawBuffers_debug(GLuint framebuffer, GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffers, "(%u, %d, %p)", (unsigned int)framebuffer, (int)n, (void*)bufs)
    glatter_glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferDrawBuffers_defined
#endif
#ifndef glNamedFramebufferParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferParameteri, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferParameteri_debug(GLuint framebuffer, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferParameteri, "(%u, %s, %d)", (unsigned int)framebuffer, enum_to_string_GL(pname), (int)param)
    glatter_glNamedFramebufferParameteri(framebuffer, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferParameteri_defined
#endif
#ifndef glNamedFramebufferReadBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferReadBuffer, (framebuffer, src), (GLuint framebuffer, GLenum src))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferReadBuffer_debug(GLuint framebuffer, GLenum src, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferReadBuffer, "(%u, %s)", (unsigned int)framebuffer, enum_to_string_GL(src))
    glatter_glNamedFramebufferReadBuffer(framebuffer, src);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferReadBuffer_defined
#endif
#ifndef glNamedFramebufferRenderbuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferRenderbuffer, (framebuffer, attachment, renderbuffertarget, renderbuffer), (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferRenderbuffer_debug(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferRenderbuffer, "(%u, %s, %s, %u)", (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferRenderbuffer_defined
#endif
#ifndef glNamedFramebufferTexture_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTexture, (framebuffer, attachment, texture, level), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTexture_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture, "(%u, %s, %u, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture(framebuffer, attachment, texture, level);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTexture_defined
#endif
#ifndef glNamedFramebufferTextureLayer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedFramebufferTextureLayer, (framebuffer, attachment, texture, level, layer), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_INLINE_OR_NOT void glatter_glNamedFramebufferTextureLayer_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureLayer, "(%u, %s, %u, %d, %d)", (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedFramebufferTextureLayer_defined
#endif
#ifndef glNamedRenderbufferStorage_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorage, (renderbuffer, internalformat, width, height), (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorage_debug(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorage, "(%u, %s, %d, %d)", (unsigned int)renderbuffer, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorage_defined
#endif
#ifndef glNamedRenderbufferStorageMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glNamedRenderbufferStorageMultisample, (renderbuffer, samples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glNamedRenderbufferStorageMultisample_debug(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisample, "(%u, %d, %s, %d, %d)", (unsigned int)renderbuffer, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glNamedRenderbufferStorageMultisample_defined
#endif
#ifndef glReadnPixels_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glReadnPixels, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
GLATTER_INLINE_OR_NOT void glatter_glReadnPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixels, "(%d, %d, %d, %d, %s, %s, %d, %p)", (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixels(x, y, width, height, format, type, bufSize, data);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glReadnPixels_defined
#endif
#ifndef glTextureBarrier_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBarrier, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glTextureBarrier_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBarrier, "()")
    glatter_glTextureBarrier();
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBarrier_defined
#endif
#ifndef glTextureBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBuffer, (texture, internalformat, buffer), (GLuint texture, GLenum internalformat, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTextureBuffer_debug(GLuint texture, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBuffer, "(%u, %s, %u)", (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTextureBuffer(texture, internalformat, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBuffer_defined
#endif
#ifndef glTextureBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureBufferRange, (texture, internalformat, buffer, offset, size), (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glTextureBufferRange_debug(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferRange, "(%u, %s, %u, %s, %s)", (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glTextureBufferRange(texture, internalformat, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureBufferRange_defined
#endif
#ifndef glTextureParameterIiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLint *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterIiv_debug(GLuint texture, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIiv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIiv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterIiv_defined
#endif
#ifndef glTextureParameterIuiv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLuint *params))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterIuiv_debug(GLuint texture, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIuiv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIuiv(texture, pname, params);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterIuiv_defined
#endif
#ifndef glTextureParameterf_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterf, (texture, pname, param), (GLuint texture, GLenum pname, GLfloat param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterf_debug(GLuint texture, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterf, "(%u, %s, %f)", (unsigned int)texture, enum_to_string_GL(pname), (float)param)
    glatter_glTextureParameterf(texture, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterf_defined
#endif
#ifndef glTextureParameterfv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameterfv, (texture, pname, param), (GLuint texture, GLenum pname, const GLfloat *param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameterfv_debug(GLuint texture, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameterfv(texture, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameterfv_defined
#endif
#ifndef glTextureParameteri_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameteri, (texture, pname, param), (GLuint texture, GLenum pname, GLint param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameteri_debug(GLuint texture, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteri, "(%u, %s, %d)", (unsigned int)texture, enum_to_string_GL(pname), (int)param)
    glatter_glTextureParameteri(texture, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameteri_defined
#endif
#ifndef glTextureParameteriv_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureParameteriv, (texture, pname, param), (GLuint texture, GLenum pname, const GLint *param))
GLATTER_INLINE_OR_NOT void glatter_glTextureParameteriv_debug(GLuint texture, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteriv, "(%u, %s, %p)", (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameteriv(texture, pname, param);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureParameteriv_defined
#endif
#ifndef glTextureStorage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage1D, (texture, levels, internalformat, width), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage1D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1D, "(%u, %d, %s, %d)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1D(texture, levels, internalformat, width);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage1D_defined
#endif
#ifndef glTextureStorage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage2D, (texture, levels, internalformat, width, height), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage2D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2D, "(%u, %d, %s, %d, %d)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2D(texture, levels, internalformat, width, height);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage2D_defined
#endif
#ifndef glTextureStorage2DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage2DMultisample, (texture, samples, internalformat, width, height, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage2DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DMultisample, "(%u, %d, %s, %d, %d, %u)", (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage2DMultisample_defined
#endif
#ifndef glTextureStorage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage3D, (texture, levels, internalformat, width, height, depth), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage3D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3D, "(%u, %d, %s, %d, %d, %d)", (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3D(texture, levels, internalformat, width, height, depth);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage3D_defined
#endif
#ifndef glTextureStorage3DMultisample_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureStorage3DMultisample, (texture, samples, internalformat, width, height, depth, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_INLINE_OR_NOT void glatter_glTextureStorage3DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DMultisample, "(%u, %d, %s, %d, %d, %d, %u)", (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureStorage3DMultisample_defined
#endif
#ifndef glTextureSubImage1D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage1D, (texture, level, xoffset, width, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage1D, "(%u, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage1D_defined
#endif
#ifndef glTextureSubImage2D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage2D, "(%u, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage2D_defined
#endif
#ifndef glTextureSubImage3D_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_INLINE_OR_NOT void glatter_glTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage3D, "(%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p)", (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTextureSubImage3D_defined
#endif
#ifndef glTransformFeedbackBufferBase_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackBufferBase, (xfb, index, buffer), (GLuint xfb, GLuint index, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackBufferBase_debug(GLuint xfb, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferBase, "(%u, %u, %u)", (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer)
    glatter_glTransformFeedbackBufferBase(xfb, index, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackBufferBase_defined
#endif
#ifndef glTransformFeedbackBufferRange_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glTransformFeedbackBufferRange, (xfb, index, buffer, offset, size), (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glTransformFeedbackBufferRange_debug(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferRange, "(%u, %u, %u, %s, %s)", (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer, GET_PRS(offset), GET_PRS(size))
    glatter_glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glTransformFeedbackBufferRange_defined
#endif
#ifndef glUnmapNamedBuffer_defined
GLATTER_FBLOCK(return, GL, GLAPI, GLboolean, APIENTRY, glUnmapNamedBuffer, (buffer), (GLuint buffer))
GLATTER_INLINE_OR_NOT GLboolean glatter_glUnmapNamedBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapNamedBuffer, "(%u)", (unsigned int)buffer)
    GLboolean rval = glatter_glUnmapNamedBuffer(buffer);
    GLATTER_RBLOCK("%u\n", (unsigned char)rval);
    GLATTER_CHECK_ERROR(GL, file, line)
    return rval;
}
#define glUnmapNamedBuffer_defined
#endif
#ifndef glVertexArrayAttribBinding_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayAttribBinding, (vaobj, attribindex, bindingindex), (GLuint vaobj, GLuint attribindex, GLuint bindingindex))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayAttribBinding_debug(GLuint vaobj, GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribBinding, "(%u, %u, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayAttribBinding_defined
#endif
#ifndef glVertexArrayAttribFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayAttribFormat, (vaobj, attribindex, size, type, normalized, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayAttribFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribFormat, "(%u, %u, %d, %s, %u, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayAttribFormat_defined
#endif
#ifndef glVertexArrayAttribIFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayAttribIFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayAttribIFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribIFormat, "(%u, %u, %d, %s, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayAttribIFormat_defined
#endif
#ifndef glVertexArrayAttribLFormat_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayAttribLFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayAttribLFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribLFormat, "(%u, %u, %d, %s, %u)", (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayAttribLFormat_defined
#endif
#ifndef glVertexArrayBindingDivisor_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayBindingDivisor, (vaobj, bindingindex, divisor), (GLuint vaobj, GLuint bindingindex, GLuint divisor))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayBindingDivisor_debug(GLuint vaobj, GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayBindingDivisor, "(%u, %u, %u)", (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayBindingDivisor_defined
#endif
#ifndef glVertexArrayElementBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayElementBuffer, (vaobj, buffer), (GLuint vaobj, GLuint buffer))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayElementBuffer_debug(GLuint vaobj, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayElementBuffer, "(%u, %u)", (unsigned int)vaobj, (unsigned int)buffer)
    glatter_glVertexArrayElementBuffer(vaobj, buffer);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayElementBuffer_defined
#endif
#ifndef glVertexArrayVertexBuffer_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexBuffer, (vaobj, bindingindex, buffer, offset, stride), (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexBuffer_debug(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffer, "(%u, %u, %u, %s, %d)", (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)buffer, GET_PRS(offset), (int)stride)
    glatter_glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexBuffer_defined
#endif
#ifndef glVertexArrayVertexBuffers_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glVertexArrayVertexBuffers, (vaobj, first, count, buffers, offsets, strides), (GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
GLATTER_INLINE_OR_NOT void glatter_glVertexArrayVertexBuffers_debug(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffers, "(%u, %u, %d, %p, %p, %p)", (unsigned int)vaobj, (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glVertexArrayVertexBuffers_defined
#endif
#endif // defined(GL_VERSION_4_5)
#if defined(GL_VERSION_4_6)
#ifndef glMultiDrawArraysIndirectCount_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawArraysIndirectCount, (mode, indirect, drawcount, maxdrawcount, stride), (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawArraysIndirectCount_debug(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectCount, "(%s, %p, %s, %d, %d)", enum_to_string_GL(mode), (void*)indirect, GET_PRS(drawcount), (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawArraysIndirectCount_defined
#endif
#ifndef glMultiDrawElementsIndirectCount_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glMultiDrawElementsIndirectCount, (mode, type, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_INLINE_OR_NOT void glatter_glMultiDrawElementsIndirectCount_debug(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectCount, "(%s, %s, %p, %s, %d, %d)", enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, GET_PRS(drawcount), (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawElementsIndirectCount(mode, type, indirect, drawcount, maxdrawcount, stride);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glMultiDrawElementsIndirectCount_defined
#endif
#ifndef glPolygonOffsetClamp_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glPolygonOffsetClamp, (factor, units, clamp), (GLfloat factor, GLfloat units, GLfloat clamp))
GLATTER_INLINE_OR_NOT void glatter_glPolygonOffsetClamp_debug(GLfloat factor, GLfloat units, GLfloat clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetClamp, "(%f, %f, %f)", (float)factor, (float)units, (float)clamp)
    glatter_glPolygonOffsetClamp(factor, units, clamp);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glPolygonOffsetClamp_defined
#endif
#ifndef glSpecializeShader_defined
GLATTER_FBLOCK(, GL, GLAPI, void, APIENTRY, glSpecializeShader, (shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue), (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue))
GLATTER_INLINE_OR_NOT void glatter_glSpecializeShader_debug(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpecializeShader, "(%u, %p, %u, %p, %p)", (unsigned int)shader, (void*)pEntryPoint, (unsigned int)numSpecializationConstants, (void*)pConstantIndex, (void*)pConstantValue)
    glatter_glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    GLATTER_CHECK_ERROR(GL, file, line)
}
#define glSpecializeShader_defined
#endif
#endif // defined(__gl_glext_h_)
#endif // defined(GL_VERSION_4_6)
#endif // GLATTER_GL

